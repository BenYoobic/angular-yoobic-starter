import '../../../stencil.core';
import { EventEmitter } from '../../../stencil.core';
import { ValidatorEntry, AsyncValidator, Validator, IFormCapture, IAlgorithm, IGridSearch } from '../../../interfaces';
export declare class YooFormCaptureComponent implements IFormCapture {
    value: string | Array<string>;
    extraData: any;
    validators: Array<Validator<string> | ValidatorEntry>;
    asyncValidators: Array<AsyncValidator<string>>;
    placeholder: string;
    required: boolean;
    isHistory: boolean;
    readonly: boolean;
    type: 'video' | 'audio' | 'photo';
    multiple: boolean;
    min: number;
    max: number;
    tags: Array<string>;
    maxWidth: number;
    duration: number;
    saveGeoloc: boolean;
    allowLibrary: boolean;
    allowAnnotate: boolean;
    isImageRecognition: boolean;
    algorithm: IAlgorithm;
    algorithmDisplay: any;
    isBackgroundProcess: boolean;
    label: string;
    name: string;
    useGallery: boolean;
    validityChanged: EventEmitter<boolean>;
    inputBlurred: EventEmitter<any>;
    inputFocused: EventEmitter<any>;
    inputChanged: EventEmitter<any>;
    imageRecognition: EventEmitter<any>;
    getGeoloc: EventEmitter<any>;
    getMediaurl: EventEmitter<any>;
    galleryOpened: EventEmitter<number>;
    actionSheetOpened: EventEmitter<number>;
    extraDataChanged: EventEmitter<any>;
    fetchData: EventEmitter<IGridSearch>;
    validity: boolean;
    isProcessing: boolean;
    showImageLoader: boolean;
    imageRecognitionResults: Array<{
        title: string;
        value: any;
        rawValue: any;
        color: string;
        hidden?: boolean;
        key: string;
    }>;
    isSelectorMode: boolean;
    selectedIndex: Array<any>;
    host: HTMLStencilElement;
    private devices;
    private fileInputs;
    private imageRecognitionKpiKeys;
    private overflowOffset;
    private readonlyDiv;
    private moreButtonDiv;
    private cameraStarted;
    private autocomplete;
    updateAutocompleteValues(tags: any): void;
    updateData(value: any, extraData: any): void;
    /** If there is index, the field is a multiphoto */
    setFieldValue(index: number, data: any): void;
    stopImageRecognitionProcess(): void;
    processImageRecognitionResults(retVal: any): void;
    processGeoloc(geolocation: any, index: any): void;
    componentWillLoad(): void;
    componentDidLoad(): void;
    componentWillUpdate(): void;
    componentDidUpdate(): void;
    componentDidUnload(): void;
    initExtraData(): void;
    initMultiObjects(): void;
    initTags(): void;
    getFileInputs(): void;
    removeAllCapture(): void;
    getAddFileInput(): any;
    updateExtraData(extraData: any): void;
    getFieldValue(index: number): string | string[];
    /** for webcam, choose which device to take photo/video */
    capture(device: any, index?: number): void;
    processImageData(imageData: any, index: any): any;
    showPhotoTagDialog(imageSrc: string, value?: any): Promise<import("../../../utils").OverlayEventDetail<any>>;
    updateTagData(tag: any, index?: number): void;
    showCameraPreviewDialog(src: string, quality: number, isImageRecognition: boolean, maxWidth: number, max: number, extraClass?: string, regularMode?: boolean): Promise<any>;
    capturePhoto(useLibrary: boolean, index?: number): Promise<any>;
    captureVideo(): Promise<void>;
    captureAudio(): Promise<void>;
    noAudio(): void;
    fixSessionIdPath(): void;
    fixPathAndSetValue(files: any): Promise<void>;
    captureFromWebcam(device: any, index: any): void;
    captureFromDisk(index?: number): void;
    captureGeoloc(index?: number): void;
    getIcon(): string;
    upload(index?: number): void;
    onFetchGridData(ev: CustomEvent<IGridSearch>): void;
    getTargetElement(index: any): any;
    onFileSelect(ev: any, index?: number): void;
    clearPhotoEdit(index?: number): void;
    clearPhotoTag(index?: number): void;
    openPhotoEditorPreview(index?: number, forceReadonly?: boolean): void;
    /**
     * Need to handle this differently depending on whether we have are opening the preview from the image
     * or whether we are simply viewing the photo in readonly mode
     */
    openPreview(index?: number, forceReadonly?: boolean): void;
    openGallery(index?: number): void;
    onAnnotate(index?: number): void;
    onAfterAnnotate(index: number, retVal: any): void;
    deleteCapture(index?: number): void;
    clearImageRecognition(): void;
    isRequired(index?: number): boolean;
    addCaptureButtons(buttons: Array<any>, index?: number): Promise<void>;
    isValueValid(): boolean;
    onImageRecognition(ev: any): void;
    isStitch(): boolean;
    onShowImageRecoKpis(ev: any): void;
    onShowMaximumCaptureReached(): void;
    onShowActionSheet(value: any, index?: number): Promise<void>;
    hasExtraData(index?: number, isMultiple?: boolean): boolean;
    onAddFileSelect(): void;
    isAllItemSelected(): boolean;
    isItemSelected(index: number): boolean;
    unselectAll(): void;
    selectAll(): void;
    onItemSelect(index: number): void;
    onDeleteSelect(): void;
    toggleSelectorMode(): void;
    getAcceptExtension(): any;
    renderEditIcon(): JSX.Element;
    renderAudio(): JSX.Element;
    renderPreviewPlayIcon(): JSX.Element;
    renderPreview(): JSX.Element;
    handleImageClick(index?: number): void;
    renderMultiplePreview(index: number): void;
    shouldRotateImage(path: any): boolean;
    renderSingle(): JSX.Element;
    renderCaptureStatus(): JSX.Element;
    renderMultiple(): JSX.Element;
    checkImageOverflow(): boolean;
    renderBottomAction(): JSX.Element;
    renderTopAction(): JSX.Element;
    renderCameraContainerInSelectMode(item: any, index: number): JSX.Element;
    renderMultipleInSelectMode(): JSX.Element;
    renderMultipleInNormalMode(): JSX.Element;
    renderAddCameraContainer(index?: number): JSX.Element;
    renderProgressBar(): JSX.Element;
    renderCameraContainer(value: any, extraData: any, index?: any): JSX.Element;
    renderButtonContainer(): JSX.Element[];
    renderReadonly(): JSX.Element[];
    onToggleMore(): void;
    onHasTag(index?: number): boolean;
    shouldTagImage(): boolean;
    renderEditable(): JSX.Element;
    hostData(): {
        class: any;
    };
    render(): JSX.Element;
}
