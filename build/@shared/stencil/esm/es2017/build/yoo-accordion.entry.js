import { h } from '../design-system.core.js';

import { ae as isNullOrUndefined, a8 as setAnimation, a9 as animations, m as translate, af as weekdaysShort, ag as dateAdd, ah as startOf, ai as endOf, ad as isIonic, W as isWeb, aj as isArray, ak as resetTime, al as isDateAfter, am as isDateBefore, an as getYear, A as dateFormat, ao as dateSub, ap as shiftSlidesToNext, aq as shiftSlidesToPrevious, ar as isSameDate, as as isToday, x as getSession, at as showImageModal, _ as cloudinary, k as isCordova, a5 as getAppContext, au as WHITE, av as WHITE_DEVICE, aw as BLACK, ax as hideShowTabbar, Q as closeModal, ay as showAlert, az as compact, aA as FormFieldType, aB as isObject, aC as isString, o as isIOS$1, aD as enableKeyboardResize, aE as dateParse, aF as FormCreatorLeftMenuOptions, aG as DEVICE_LIST, aH as FORM_FIELD_CATEGORIES, aI as MOBILE_FORM_FIELDS, aJ as MOBILE_FORM_FIELDS_ADVANCED, aK as ARROW_PAIR, aL as FormFieldCategory, c as cordova, d as IonicNativePlugin, aM as onInputBlurred, aN as setValidator, aO as getCurrentLanguage, a7 as findParent, a4 as getElementDimensions, L as querySelectorDeep, aP as convertValueForInputType, aQ as setValueAndValidateInput, aR as getTimeDisplayValue, aS as blurActiveElement, v as isAndroid, aT as formatMinMaxDate, aU as onInputFocused, aV as onInputClear, aW as getHours, aX as getMinutes, aY as setDateHours, aZ as setDateMinutes, a_ as showModal, a$ as roundToNearestMinutes, b0 as getRoundedMinutes, aa as querySelectorAllDeep, b1 as createColorClasses, b2 as hostContext, b3 as isEndSide, b4 as ItemSlidingType, a6 as debounce$2, a as createCommonjsModule, b as commonjsGlobal, b5 as unwrapExports, n as global } from './chunk-30364fba.js';
import './chunk-c535de07.js';
import { b as pipes } from './chunk-262e5ad4.js';
import './index.js';

class YooAccordionComponent {
    constructor() {
        /**
         * Enable or disable multiple selection
         */
        this.allowMultipleSelection = false;
        /**
         * If true, each item will have a border bottom of 1px
         */
        this.showBottomBorder = false;
        /**
         * Entries are the strings that will populate each row of the accordion
         */
        this.entries = [];
        this.items = [];
        this.accordionContentContainers = [];
        this.accordionSelectors = [];
        this.shouldAnimateAfterReRender = false;
    }
    onTitlesChange() {
        const newTitle = this.entries.findIndex((title, index) => title.title !== this.items[index].title);
        if (newTitle > -1) {
            this.items = this.populateItems();
        }
    }
    componentWillLoad() {
        this.items = this.populateItems();
    }
    componentDidUpdate() {
        if (this.shouldAnimateAfterReRender) {
            this.animateTransition(this.selectedIndex, false);
            this.shouldAnimateAfterReRender = false;
        }
    }
    populateItems(selectedValue) {
        return this.entries.map((item) => {
            const selected = selectedValue === undefined ? (item.selected ? true : false) : selectedValue;
            return { title: item.title, selected, subItemCount: item.subItemCount, actionButton: item.actionButton };
        });
    }
    reRenderItems() {
        this.items = [...this.items];
    }
    closeSingleSelection(index) {
        if (!isNullOrUndefined(index)) {
            this.items[index].selected = false;
        }
    }
    openItem(index) {
        this.items[index].selected = true;
    }
    isAnItemSelected() {
        return this.items.some(item => item.selected === true);
    }
    handleMultiSelect(item, index) {
        // Multiple Selection turned on
        if (item.selected) {
            this.closeSingleSelection(index);
            this.animateTransition(index, true);
        }
        else {
            // selectedIndex in multi context corresponds to the last item to be selected
            this.selectedIndex = index;
            this.openItem(index);
            this.shouldAnimateAfterReRender = true;
        }
        this.reRenderItems();
    }
    handleSingleDeselect(index) {
        const shouldCollapseUp = true;
        this.selectedIndex = null;
        this.previousSelectedIndex = index;
        this.animateTransition(index, shouldCollapseUp);
        this.closeSingleSelection(index);
        this.reRenderItems();
    }
    handleSingleSelect(index) {
        this.previousSelectedIndex = this.selectedIndex;
        this.selectedIndex = index;
        this.openItem(this.selectedIndex);
        this.closeSingleSelection(this.previousSelectedIndex);
        // When selecting a new item we need the animation to be triggered after the component
        // is rendered
        this.shouldAnimateAfterReRender = true;
        this.reRenderItems();
    }
    onAccordionClick(item, index) {
        if (index >= 0) {
            if (item.selected && !this.allowMultipleSelection) {
                this.handleSingleDeselect(index);
            }
            else if (!item.selected && !this.allowMultipleSelection) {
                this.handleSingleSelect(index);
            }
            else {
                this.handleMultiSelect(item, index);
            }
            this.accordionSelected.emit(index);
        }
        else {
            this.onMasterTitleClicked();
        }
    }
    onMasterTitleClicked() {
        if (this.isAnItemSelected()) {
            this.items = this.populateItems(false);
        }
        else {
            this.items = this.populateItems(true);
        }
        this.reRenderItems();
    }
    animateTransition(currentIndex, isAnimatedUp) {
        const distance = this.accordionContentContainers[currentIndex].clientHeight;
        let count = 0;
        // Animating the items one by one
        this.items.map((_item, itemIndex) => {
            if (this.previousSelectedIndex > currentIndex) {
                const animationNumber = this.previousSelectedIndex - this.selectedIndex;
                if (itemIndex > currentIndex && animationNumber > count) {
                    setAnimation(animations.slideVertical, this.accordionSelectors[itemIndex], { up: false, distance, open: true });
                    count += 1;
                }
            }
            else if (currentIndex > this.previousSelectedIndex && (this.previousSelectedIndex !== null)) {
                const animationNumber = currentIndex - this.previousSelectedIndex;
                if (itemIndex > this.previousSelectedIndex && animationNumber > count) {
                    setAnimation(animations.slideVertical, this.accordionSelectors[itemIndex], { up: true, distance, open: true });
                    count += 1;
                }
            }
            else {
                if (itemIndex > currentIndex) {
                    setAnimation(animations.slideVertical, this.accordionSelectors[itemIndex], { up: isAnimatedUp, distance, open: true });
                }
            }
        });
    }
    renderIconPair(item, buttonPair) {
        return (h("div", { class: "icon" },
            h("yoo-icon", { class: item.selected ? buttonPair[1] : buttonPair[0] })));
    }
    renderAccordionTitle(item, index, masterTitle = false) {
        return (h("div", { class: {
                'title-container': true,
                'master-title': masterTitle,
                'active-title': item.selected
            }, onClick: () => this.onAccordionClick(item, index) },
            h("div", { class: "left-container" },
                this.iconPairLeft && this.renderIconPair(item, this.iconPairLeft),
                h("div", { class: "title" }, translate(item.title)),
                item.subItemCount && h("span", { class: "count" }, item.subItemCount)),
            h("div", { class: "right-container" },
                item.actionButton && this.renderActionButton(item.actionButton),
                this.iconPairRight && this.renderIconPair(item, this.iconPairRight))));
    }
    renderActionButton(actionButton) {
        return (h("yoo-button", { onClick: () => actionButton.handler(), text: actionButton.text, class: actionButton.cssClass || '' }));
    }
    renderSlot(item, index) {
        return (h("div", { ref: el => (this.accordionContentContainers[index] = el), class: item.selected ? 'selected-accordion' : 'undisplayed-accordion' },
            h("slot", { name: item.title })));
    }
    renderMasterTitle() {
        const item = { title: this.masterTitle, selected: this.isAnItemSelected() };
        return this.renderAccordionTitle(item, -1, true);
    }
    hostData() {
        return {
            class: {
                'bottom-border': this.showBottomBorder
            }
        };
    }
    render() {
        return (h("div", { class: "outer-container" },
            this.masterTitle && this.renderMasterTitle(),
            this.items.map((item, index) => h("div", { class: "accordion-selector", ref: (el) => this.accordionSelectors[index] = el },
                this.renderAccordionTitle(item, index),
                this.renderSlot(item, index)))));
    }
    static get is() { return "yoo-accordion"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "allowMultipleSelection": {
            "type": Boolean,
            "attr": "allow-multiple-selection"
        },
        "entries": {
            "type": "Any",
            "attr": "entries",
            "watchCallbacks": ["onTitlesChange"]
        },
        "host": {
            "elementRef": true
        },
        "iconPairLeft": {
            "type": "Any",
            "attr": "icon-pair-left"
        },
        "iconPairRight": {
            "type": "Any",
            "attr": "icon-pair-right"
        },
        "items": {
            "state": true
        },
        "masterTitle": {
            "type": String,
            "attr": "master-title"
        },
        "showBottomBorder": {
            "type": Boolean,
            "attr": "show-bottom-border"
        }
    }; }
    static get events() { return [{
            "name": "accordionSelected",
            "method": "accordionSelected",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return "\@-webkit-keyframes toggle-opacity {\n  0% {\n    opacity: 0; }\n  50% {\n    opacity: 0.5; }\n  100% {\n    opacity: 1; } }\n\n\@keyframes toggle-opacity {\n  0% {\n    opacity: 0; }\n  50% {\n    opacity: 0.5; }\n  100% {\n    opacity: 1; } }\n\n:host() {\n  --title-font-size: var(--font-m, 15px);\n  --outer-container-padding: none;\n  --outer-container-width: 100%;\n  --accordion-background: var(--light, #FFFFFF); }\n\n:host .outer-container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  width: var(--outer-container-width);\n  padding: var(--outer-container-padding);\n  -webkit-transition: all 0.3s;\n  transition: all 0.3s;\n  background: var(--accordion-background); }\n  :host .outer-container .title-container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-align: center;\n    align-items: center;\n    width: 100%;\n    margin: var(--padding-10, 0.625rem) 0; }\n    :host .outer-container .title-container .left-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-align: center;\n      align-items: center; }\n      :host .outer-container .title-container .left-container .icon {\n        padding-right: var(--padding-5, 0.3125rem);\n        font-size: var(--font-xs, 10px); }\n      :host .outer-container .title-container .left-container .title {\n        padding-right: var(--padding-5, 0.3125rem);\n        color: var(--black, #000000);\n        font-size: var(--title-font-size);\n        font-weight: 600; }\n      :host .outer-container .title-container .left-container .count {\n        color: var(--text-color, #807f83);\n        font-weight: 600; }\n    :host .outer-container .title-container .right-container yoo-button.new-page {\n      --color-value: var(--black, #000000);\n      --shadow: none;\n      --border-container: 1px solid var(--stable-light, #f1f1f1); }\n  :host .outer-container .accordion-selector {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n    width: 100%; }\n    :host .outer-container .accordion-selector:first-child .title-container {\n      margin-top: 0; }\n    :host .outer-container .accordion-selector .accordion-title:hover {\n      cursor: pointer; }\n    :host .outer-container .accordion-selector .accordion-title.active-title .icon {\n      -webkit-transition: all 0.3s;\n      transition: all 0.3s; }\n    :host .outer-container .accordion-selector .undisplayed-accordion {\n      display: none; }\n    :host .outer-container .accordion-selector .selected-accordion {\n      display: block;\n      -webkit-transition: all 0.3s;\n      transition: all 0.3s;\n      color: var(--dark, #2b3648);\n      -webkit-animation: toggle-opacity 0.3s ease;\n      animation: toggle-opacity 0.3s ease; }\n\n:host(.bottom-border) .outer-container .title-container {\n  padding-bottom: var(--padding-10, 0.625rem);\n  border-bottom: 1px solid var(--stable-light, #f1f1f1); }\n\n:host(.sub-accordion) .outer-container .accordion-selector .title-container .left-container .title,\n:host(.sub-accordion) .outer-container .accordion-selector .title-container .left-container .count {\n  font-size: var(--font-s, 13px);\n  font-weight: 400; }\n\n:host(.accent) .outer-container {\n  border-color: var(--accent, #1FB6FF); }\n  :host(.accent) .outer-container .accordion-selector .title-container {\n    border-color: var(--accent, #1FB6FF); }\n    :host(.accent) .outer-container .accordion-selector .title-container .icon {\n      color: var(--accent, #1FB6FF); }\n\n:host(.danger) .outer-container {\n  border-color: var(--danger, #ff625f); }\n  :host(.danger) .outer-container .accordion-selector .title-container {\n    border-color: var(--danger, #ff625f); }\n    :host(.danger) .outer-container .accordion-selector .title-container .icon {\n      color: var(--danger, #ff625f); }\n\n:host(.success) .outer-container {\n  border-color: var(--success, #04CC99); }\n  :host(.success) .outer-container .accordion-selector .title-container {\n    border-color: var(--success, #04CC99); }\n    :host(.success) .outer-container .accordion-selector .title-container .icon {\n      color: var(--success, #04CC99); }\n\n:host(.info) .outer-container {\n  border-color: var(--info, #fc459e); }\n  :host(.info) .outer-container .accordion-selector .title-container {\n    border-color: var(--info, #fc459e); }\n    :host(.info) .outer-container .accordion-selector .title-container .icon {\n      color: var(--info, #fc459e); }\n\n:host(.warning) .outer-container {\n  border-color: var(--warning, #ff6402); }\n  :host(.warning) .outer-container .accordion-selector .title-container {\n    border-color: var(--warning, #ff6402); }\n    :host(.warning) .outer-container .accordion-selector .title-container .icon {\n      color: var(--warning, #ff6402); }\n\n:host(.dark) .outer-container {\n  border-color: var(--dark-40, #9cabc4); }\n  :host(.dark) .outer-container .accordion-selector .title-container {\n    border-color: var(--dark-40, #9cabc4); }\n    :host(.dark) .outer-container .accordion-selector .title-container .icon {\n      color: var(--dark-40, #9cabc4); }"; }
}

const MONTHS_TO_ADD = 3;
class YooCalendarComponent {
    constructor() {
        this.displayMode = 'month';
        this.isRange = false;
        this.slideChanged = true;
        this.weekdays = weekdaysShort();
        this.renderedMonths = [-1, 0, 1];
        this.initialSlide = 1;
        this.cachedSlides = 1;
        this.currentSlideIndex = 1;
        this.singleRange = false;
        this.calendarWebTabs = [
            {
                title: translate('TODAY'),
                value: 'today'
            },
            {
                title: translate('WEEK'),
                value: 'week'
            },
            {
                title: translate('MONTH'),
                value: 'month'
            }
        ];
    }
    setActiveDay(day) {
        const prevActiveDay = dateAdd(day, this.displayMode, -1);
        const nextActiveDay = dateAdd(day, this.displayMode, 1);
        if (!this.initialActiveDay) {
            this.initialActiveDay = day;
        }
        let monthStartDay = startOf(day, 'month');
        let monthEndDay = endOf(day, 'month');
        const [previousMonthStartDay, previousMonthEndDay, timeSpanStart, timeSpanEnd, nextMonthStartDay, nextMonthEndDay] = this.generateTimespan(day);
        // Current month
        const [weeks, greyDays] = this.generateCalendarDays(timeSpanStart, timeSpanEnd);
        if (this.isWeekDisplay() && weeks.length === 1) {
            this.activeWeek = weeks;
        }
        // Previous Month 
        const [prevWeeks, prevGreyDays] = this.generateCalendarDays(previousMonthStartDay, previousMonthEndDay);
        // Next Month
        const [nextWeeks, nextGreyDays] = this.generateCalendarDays(nextMonthStartDay, nextMonthEndDay);
        // These variables will always be undefined on mobile but added a check just to be safe
        if ((!this.loadedNextMonthDay && !this.loadedPreviousMonthDay) || isIonic()) {
            this.activeDays = [prevActiveDay, day, nextActiveDay];
            this.weeks = weeks;
            this.renderedMonthsWeeks = [prevWeeks, this.weeks, nextWeeks];
            this.renderedGreyDays = [prevGreyDays, greyDays, nextGreyDays];
        }
        // To ensure we load the markers for 3 months at a time on web, we change the monthStartDay and monthEndDay
        if (isWeb()) {
            monthStartDay = previousMonthStartDay;
            monthEndDay = nextMonthEndDay;
        }
        this.dateChanged.emit({ date: day, startDate: timeSpanStart, endDate: timeSpanEnd, mode: this.displayMode, monthStartDay, monthEndDay });
        this.activeDayState = day;
    }
    setDisplayMode(mode) {
        this.displayMode = mode;
        // Compute the active day to force a re-render
        this.setActiveDay(this.activeDayState);
    }
    componentWillLoad() {
        let _activeDay;
        if (this.isRange && isArray(this.activeDay)) {
            // If we have a range just set the initial active dat to be a new date
            _activeDay = this.activeDay[0];
        }
        else {
            this.activeDay ? _activeDay = this.activeDay : _activeDay = new Date();
        }
        if (this.dateRange) {
            this.rangeLowerBound = resetTime(this.dateRange[0]);
            this.rangeUpperBound = resetTime(this.dateRange[1]);
        }
        if (this.maxDate && isDateAfter(_activeDay, this.maxDate)) {
            _activeDay = this.maxDate;
            this.setActiveDay(_activeDay);
        }
        else if (this.minDate && isDateBefore(_activeDay, this.minDate)) {
            _activeDay = this.minDate;
            this.setActiveDay(_activeDay);
        }
        else {
            this.setActiveDay(_activeDay);
        }
        this.activeYear = getYear(dateFormat(this.activeDayState, 'YYYY'));
    }
    componentDidLoad() {
        if (this.calendarScroll) {
            const CALENDAR_SCROLL_HEIGHT = 250;
            this.calendarScroll.scrollByPoint(0, CALENDAR_SCROLL_HEIGHT, 50);
        }
    }
    isActiveDay(day) {
        return dateFormat(day, 'L') === dateFormat(this.activeDayState, 'L');
    }
    isNextYear(day) {
        let nextYearFromToday = getYear(dateFormat(day, 'YYYY'));
        return this.activeYear < nextYearFromToday;
    }
    isPreviousYear(day) {
        let lastYearFromToday = getYear(dateFormat(day, 'YYYY'));
        return this.activeYear > lastYearFromToday;
    }
    isInDateRange(date, rangeLowerBound, rangeUpperBound) {
        if (isDateBefore(date, rangeLowerBound)) {
            return false;
        }
        if (this.rangeUpperBound ? isDateAfter(date, rangeUpperBound) : isDateAfter(date, rangeLowerBound)) {
            return false;
        }
        // Date is in the range
        return true;
    }
    // Grey days are either not in the current month, below the min date or above the max date
    isGreyDay(day, monthIndex) {
        if (this.minDate && isDateBefore(day, this.minDate)) {
            return true;
        }
        if (this.maxDate && isDateAfter(day, this.maxDate)) {
            return true;
        }
        const dayToCheck = dateFormat(day, 'L');
        return this.renderedGreyDays[monthIndex].indexOf(dayToCheck) > -1;
    }
    isWeekDisplay() {
        return this.displayMode === 'week';
    }
    isMonthDisplay() {
        return this.displayMode === 'month';
    }
    /**
     * Generate the start and end date for 3 months (previous, current, next)
     */
    generateTimespan(day) {
        const timeSpanStart = startOf(day, this.displayMode);
        const timeSpanEnd = endOf(day, this.displayMode);
        const previousMonthStartDay = dateSub(timeSpanStart, `${this.displayMode}s`, 1);
        const previousMonthEndDay = dateSub(timeSpanEnd, `${this.displayMode}s`, 1);
        const nextMonthStartDay = dateAdd(timeSpanStart, `${this.displayMode}s`, 1);
        const nextMonthEndDay = dateAdd(timeSpanEnd, `${this.displayMode}s`, 1);
        return [
            previousMonthStartDay,
            previousMonthEndDay,
            timeSpanStart,
            timeSpanEnd,
            nextMonthStartDay,
            nextMonthEndDay
        ];
    }
    /**
     *
     * @param currentDay the first day of the Month or Week
     * @param endDay the last day of the Month or Week
     */
    generateCalendarDays(currentDay, endDay) {
        let weeks = [
            []
        ];
        let greyDays = [];
        let startCount = 0;
        if (this.isMonthDisplay()) {
            [weeks[0], greyDays] = this.generatePreviousMonthGreyDays(currentDay);
            startCount = greyDays.length;
        }
        weeks = this.generateCurrentMonthDays(currentDay, endDay, weeks, startCount);
        // Keep only populated weeks
        weeks = weeks.filter(w => w.length > 0);
        let lastWeek = weeks[weeks.length - 1];
        let nextMonthGreyDays = [];
        let firstDayInNextMonth = dateAdd(endDay, 'days', 1);
        [lastWeek, nextMonthGreyDays] = this.generateNextMonthGreyDays(firstDayInNextMonth, lastWeek);
        greyDays = [...greyDays, ...nextMonthGreyDays];
        weeks[weeks.length - 1] = lastWeek;
        return [weeks, greyDays];
    }
    generatePreviousMonthGreyDays(currentDay) {
        let firstWeek = [];
        let previousMonthGreyDays = [];
        let count = 0;
        // First day of the current week
        let indexOfStartWeekDay = this.weekdays.indexOf(dateFormat(currentDay, 'eeeeee'));
        if (indexOfStartWeekDay > 0) {
            while (count < indexOfStartWeekDay) {
                // All all days of the last month which belong to the same week as the current day to the display and record them as greyed out
                let dayInLastMonth = dateSub(currentDay, 'days', indexOfStartWeekDay - count);
                previousMonthGreyDays.push(dateFormat(dayInLastMonth, 'L'));
                firstWeek.push(dayInLastMonth);
                count += 1;
            }
        }
        return [firstWeek, previousMonthGreyDays];
    }
    generateCurrentMonthDays(currentDay, endDay, weeks, startCount) {
        let weekIndex = 0, count = startCount;
        while (currentDay <= endDay) {
            weeks[weekIndex].push(currentDay);
            // Increment the day
            currentDay = dateAdd(currentDay, 'days', 1);
            count += 1;
            if (count > 6) {
                // reset count, increment week index
                count = 0;
                weekIndex += 1;
                weeks[weekIndex] = [];
            }
        }
        return weeks;
    }
    generateNextMonthGreyDays(firstDayInNextMonth, lastWeek) {
        let endCount = 0;
        let nextMonthGreyDays = [];
        while (lastWeek.length < 7) {
            let dayInNextMonth = dateAdd(firstDayInNextMonth, 'days', endCount);
            nextMonthGreyDays.push(dateFormat(dayInNextMonth, 'L'));
            lastWeek.push(dayInNextMonth);
            endCount += 1;
        }
        return [lastWeek, nextMonthGreyDays];
    }
    async onSlideChanged(event) {
        if (this.slides) {
            // Initial active index = 1;
            this.slides.getActiveIndex().then(activeIndex => {
                if (activeIndex !== null) {
                    if (activeIndex > this.currentSlideIndex) {
                        this.onNextMobile(activeIndex - 1);
                    }
                    else if (activeIndex < this.currentSlideIndex) {
                        this.onPreviousMobile(activeIndex + 1);
                    }
                }
            });
        }
    }
    onNextMobile(activeSlideIndex) {
        if (this.slides) {
            this.renderedMonths = shiftSlidesToNext(activeSlideIndex, this.renderedMonths, this.cachedSlides);
            try {
                this.slides.slideTo(activeSlideIndex, 0, false);
                this.slides.update();
            }
            catch (err) { }
        }
        this.onNext();
    }
    onPreviousMobile(activeSlideIndex) {
        if (this.slides) {
            this.renderedMonths = shiftSlidesToPrevious(activeSlideIndex, this.renderedMonths, this.cachedSlides);
            try {
                this.slides.slideTo(activeSlideIndex, 0, false);
                this.slides.update();
            }
            catch (err) { }
        }
        this.onPrevious();
    }
    onNext() {
        if (this.isDatePicker) {
            this.renderedMonths.push(this.renderedMonths[this.renderedMonths.length - 1] + 1);
            this.renderedMonths.shift();
        }
        let nextDate = dateAdd(this.activeDayState, this.displayMode, 1);
        if (this.maxDate && isDateAfter(dateFormat(nextDate, 'Ld'), this.maxDate)) {
            this.setActiveDay(this.maxDate);
        }
        else {
            this.setActiveDay(nextDate);
        }
        this.swipeHorizontal.emit('next');
    }
    onPrevious() {
        if (this.isDatePicker) {
            this.renderedMonths.unshift(this.renderedMonths[0] - 1);
            this.renderedMonths.pop();
        }
        let previousDate = dateSub(this.activeDayState, this.displayMode, 1);
        if (this.minDate && isDateBefore(dateFormat(previousDate, 'Ld'), this.minDate)) {
            this.setActiveDay(this.minDate);
        }
        else {
            this.setActiveDay(previousDate);
        }
        this.swipeHorizontal.emit('previous');
    }
    onSetToday() {
        this.setActiveDay(new Date());
        this.todaySelected.emit(this.activeDay);
    }
    onSelectDay(day) {
        this.dayClicked.emit(true);
        if (this.isRange && !this.rangeLowerBound) {
            this.rangeLowerBound = day;
        }
        else if (this.isRange && this.rangeUpperBound) {
            // Different conditions - here if max is defined -min always exists
            this.singleRange = false;
            if (isDateAfter(day, this.rangeUpperBound)) {
                this.rangeUpperBound = day;
            }
            else if (isDateBefore(day, this.rangeLowerBound)) {
                this.rangeLowerBound = day;
            }
            else if (isDateAfter(day, this.rangeLowerBound) && isDateBefore(day, this.rangeUpperBound)) {
                this.rangeUpperBound = day;
            }
            else if (isSameDate(day, this.rangeUpperBound)) {
                this.rangeLowerBound = day;
                this.rangeUpperBound = null;
            }
            else if (isSameDate(day, this.rangeLowerBound)) {
                this.singleRange = true;
                this.rangeLowerBound = day;
                this.rangeUpperBound = null;
            }
            this.emitDateRange();
        }
        else if (this.isRange) {
            this.singleRange = false;
            if (isDateAfter(day, this.rangeLowerBound)) {
                this.rangeUpperBound = day;
            }
            else if (isDateBefore(day, this.rangeLowerBound)) {
                this.rangeLowerBound = day;
            }
            else if (isSameDate(day, this.rangeLowerBound)) {
                // Lower Bound becomes the only selected day in this case
                this.singleRange = true;
                this.rangeLowerBound = day;
            }
            this.emitDateRange();
        }
        else {
            if (isWeb) {
                this.activeDayState = day;
                this.dateChanged.emit({
                    date: day,
                    startDate: startOf(day, this.displayMode),
                    endDate: endOf(day, this.displayMode),
                    mode: this.displayMode,
                    monthStartDay: startOf(day, 'month'),
                    monthEndDay: endOf(day, 'month')
                });
            }
            else {
                this.setActiveDay(day);
            }
        }
    }
    onWebCalendarTabSelected(event) {
        const selectedTab = event.detail;
        this.handleTabChange(selectedTab.value);
    }
    handleTabChange(tabTitle) {
        switch (tabTitle) {
            case 'month':
            case 'week':
                this.setDisplayMode(tabTitle);
                break;
            case 'today':
                this.onSetToday();
        }
    }
    emitDateRange() {
        let lowerBoundChange = { date: this.rangeLowerBound, mode: this.displayMode };
        if (this.singleRange) {
            this.dateRangeChanged.emit([lowerBoundChange, lowerBoundChange]);
        }
        else {
            let upperBoundChange = { date: this.rangeUpperBound, mode: this.displayMode };
            this.dateRangeChanged.emit([lowerBoundChange, upperBoundChange]);
        }
    }
    getMarkers(day) {
        if (this.markers) {
            let marker = this.markers.find(m => m._id === dateFormat(day, 'YYYY-MM-dd'));
            return marker ? true : false;
        }
        return false;
    }
    getDayClass(day, slideIndex) {
        let dayClass = 'day ';
        if (isToday(day)) {
            dayClass += 'today ';
        }
        if ((this.isActiveDay(day) && !this.isRange)) {
            dayClass += 'active ';
        }
        if (this.isGreyDay(day, slideIndex)) {
            dayClass += 'grey-day ';
        }
        if (this.isRange && this.rangeLowerBound && this.isInDateRange(day, this.rangeLowerBound, this.rangeUpperBound) && !this.singleRange) {
            dayClass += 'in-range ';
            if (isSameDate(day, this.rangeLowerBound)) {
                dayClass += 'first-day ';
            }
            else if (isSameDate(day, this.rangeUpperBound)) {
                dayClass += 'last-day ';
            }
        }
        else if (this.isRange && this.singleRange && isSameDate(day, this.rangeLowerBound)) {
            dayClass += 'single-range';
        }
        return dayClass;
    }
    onChangeModeClicked(mode) {
        this.setDisplayMode(mode);
        this.displayModeChanged.emit(mode);
    }
    renderMobileCalendar() {
        return ([
            this.renderCalendarHeaderMobile(),
            this.isDatePicker ?
                this.renderedMonths.map((slide, index) => {
                    if (index === 1) {
                        return h("div", { class: "mobile-days" },
                            this.renderWeekHeader(),
                            this.renderWeekDaysMobile(index));
                    }
                }) :
                h("div", { class: "calendar-container" },
                    h("yoo-ion-slides", { ref: (el) => this.slides = el, initialSlide: this.initialSlide, options: { autoplay: false }, onIonSlideDidChange: (event) => this.onSlideChanged(event) }, this.renderedMonths.map((slide, index) => {
                        return h("yoo-ion-slide", { class: "ion-slide" },
                            h("div", { class: "mobile-days" },
                                this.renderWeekHeader(),
                                this.renderWeekDaysMobile(index)));
                    })))
        ]);
    }
    renderWebCalendar() {
        return ([
            this.renderCalendarHeaderWeb(),
            h("div", { class: "days" },
                this.renderWeekHeader(),
                this.renderWeekDaysWeb())
        ]);
    }
    renderDay(day, monthIndex) {
        return (day &&
            h("div", { class: this.getDayClass(day, monthIndex), onClick: this.onSelectDay.bind(this, day) },
                h("div", { class: "day-number" }, pipes.dateFormat.transform(day, 'd')),
                h("div", { class: "markers" }, this.renderMarkers(day))));
    }
    renderMarkers(day) {
        return ([
            this.getMarkers(day) ? h("div", { class: "marker no-count" }, this.getMarkers(day)) : ''
        ]);
    }
    renderWeekHeader() {
        return (h("div", { class: "week-header" }, this.weeks[0].map((day) => h("div", { class: "day" },
            h("div", { class: "day-text" }, pipes.dateFormat.transform(day, `${isWeb() ? 'eee' : 'eeeeee'}`))))));
    }
    renderWeeks(weeks, monthIndex) {
        return weeks.map((days) => h("div", { class: `week mode-${this.displayMode}` }, days.map(day => this.renderDay(day, monthIndex))));
    }
    renderWeekDaysWeb() {
        return (h("yoo-ion-scroll", { class: "relative", ref: (el) => this.calendarScroll = el, scrollEvents: true, onIonScroll: (event) => this.handleScroll(event.detail) },
            this.isMonthDisplay() ?
                h("div", { class: "months" }, this.renderedMonths.map((value, index) => {
                    return (h("div", { class: "web-days" },
                        this.renderActiveMonth(this.activeDays[index]),
                        this.renderWeeks(this.renderedMonthsWeeks[index], index)));
                })) : this.renderSingleWeekViewWeb(),
            this.renderInfiniteScroll()));
    }
    renderSingleWeekViewWeb() {
        return (h("div", { class: "weeks" },
            h("div", { class: "web-days" }, this.renderWeeks(this.activeWeek, 0))));
    }
    onInfiniteScroll(event) {
        if (this.loadedNextMonthDay) {
            this.loadedNextMonthDay = dateAdd(this.loadedNextMonthDay, 'months', MONTHS_TO_ADD);
        }
        else {
            this.loadedNextMonthDay = dateAdd(this.initialActiveDay, 'months', MONTHS_TO_ADD);
        }
        const [previousMonthStartDay, previousMonthEndDay, timeSpanStart, timeSpanEnd, nextMonthStartDay, nextMonthEndDay] = this.generateTimespan(this.loadedNextMonthDay);
        const [loadedNextMonthWeeks, loadedNextMonthGreyDays] = this.generateCalendarDays(timeSpanStart, timeSpanEnd);
        const [previousMonthWeeks, previousMonthGreyDays] = this.generateCalendarDays(previousMonthStartDay, previousMonthEndDay);
        const [nextMonthWeeks, nextMonthGreyDays] = this.generateCalendarDays(nextMonthStartDay, nextMonthEndDay);
        this.renderedMonthsWeeks = [...this.renderedMonthsWeeks, previousMonthWeeks, loadedNextMonthWeeks, nextMonthWeeks];
        this.renderedMonths = [...this.renderedMonths, 0, 0, 0];
        this.renderedGreyDays = [...this.renderedGreyDays, previousMonthGreyDays, loadedNextMonthGreyDays, nextMonthGreyDays];
        this.activeDays = [...this.activeDays, previousMonthStartDay, timeSpanStart, nextMonthStartDay];
        this.infiniteScroll.complete();
        this.extraMonthsLoaded.emit({
            date: timeSpanStart,
            startDate: startOf(timeSpanStart, this.displayMode),
            endDate: endOf(timeSpanStart, this.displayMode),
            mode: this.displayMode,
            monthStartDay: previousMonthStartDay,
            monthEndDay: nextMonthStartDay
        });
        this.host.forceUpdate();
    }
    handleScroll(event) {
        // Scroll is at his maximum at the top
        if (event.currentY === 0 && this.isMonthDisplay()) {
            if (this.loadedPreviousMonthDay) {
                this.loadedPreviousMonthDay = dateSub(this.loadedPreviousMonthDay, 'months', MONTHS_TO_ADD);
            }
            else {
                this.loadedPreviousMonthDay = dateSub(this.initialActiveDay, 'months', MONTHS_TO_ADD);
            }
            const [previousMonthStartDay, previousMonthEndDay, timeSpanStart, timeSpanEnd, nextMonthStartDay, nextMonthEndDay] = this.generateTimespan(this.loadedPreviousMonthDay);
            const [loadedPreviousMonthWeeks, loadedPreviousMonthGreyDays] = this.generateCalendarDays(timeSpanStart, timeSpanEnd);
            const [previousMonthWeeks, previousMonthGreyDays] = this.generateCalendarDays(previousMonthStartDay, previousMonthEndDay);
            const [nextMonthWeeks, nextMonthGreyDays] = this.generateCalendarDays(nextMonthStartDay, nextMonthEndDay);
            this.renderedMonthsWeeks = [previousMonthWeeks, loadedPreviousMonthWeeks, nextMonthWeeks, ...this.renderedMonthsWeeks];
            this.renderedMonths = [0, 0, 0, ...this.renderedMonths];
            this.renderedGreyDays = [previousMonthGreyDays, loadedPreviousMonthGreyDays, nextMonthGreyDays, ...this.renderedGreyDays];
            this.activeDays = [previousMonthStartDay, timeSpanStart, nextMonthStartDay, ...this.activeDays];
            this.extraMonthsLoaded.emit({
                date: timeSpanStart,
                startDate: startOf(timeSpanStart, this.displayMode),
                endDate: endOf(timeSpanStart, this.displayMode),
                mode: this.displayMode,
                monthStartDay: previousMonthStartDay,
                monthEndDay: nextMonthStartDay
            });
            this.host.forceUpdate();
        }
    }
    renderInfiniteScroll() {
        return (h("yoo-ion-infinite-scroll", { ref: (el) => this.infiniteScroll = el, threshold: '8%', disabled: this.isWeekDisplay(), onIonInfinite: ev => this.onInfiniteScroll(ev) },
            h("yoo-ion-infinite-scroll-content", { loadingSpinner: "dots" })));
    }
    renderCalendarHeaderWeb() {
        return (h("yoo-navbar", { class: "items-space-around small", onTabSelected: (event) => this.onWebCalendarTabSelected(event), selectedTab: this.calendarWebTabs[2], tabs: this.calendarWebTabs }));
    }
    renderWeekDaysMobile(slideIndex) {
        return (this.renderedMonthsWeeks[slideIndex].map(days => h("div", { class: 'week mode-' + this.displayMode }, days.map(day => this.renderDay(day, slideIndex)))));
    }
    renderCalendarModeToggle() {
        return (h("div", { class: "calendar-tools" },
            h("span", { class: 'calendar-toggle today', onClick: this.onSetToday.bind(this) }, translate('TODAY')),
            h("span", { class: {
                    'calendar-toggle': true,
                    'active': this.isWeekDisplay()
                }, onClick: this.onChangeModeClicked.bind(this, 'week') }, translate('WEEK')),
            h("span", { class: {
                    'calendar-toggle': true,
                    'active': this.isMonthDisplay()
                }, onClick: this.onChangeModeClicked.bind(this, 'month') }, translate('MONTH'))));
    }
    renderActiveMonth(activeDay, longMonth = true) {
        return h("span", { class: "active-month" }, activeDay && (this.isPreviousYear(activeDay) || this.isNextYear(activeDay)) ? pipes.dateFormat.transform(activeDay, `MMM${longMonth ? 'M' : ''} YYYY`) : pipes.dateFormat.transform(activeDay, `MMM${longMonth ? 'M' : ''}`));
    }
    renderMobileCalendarControls() {
        return ([
            h("span", { onClick: this.onPrevious.bind(this), class: "prev-month" },
                h("yoo-icon", { class: "yo-left" })),
            this.renderActiveMonth(this.activeDays[1], false),
            h("span", { onClick: this.onNext.bind(this), class: "next-month" },
                h("yoo-icon", { class: "yo-right" }))
        ]);
    }
    renderCalendarHeaderMobile() {
        return (h("div", { class: "mobile-calendar-header" },
            h("div", { class: "active-month-container" }, this.renderMobileCalendarControls()),
            !this.isDatePicker && this.renderCalendarModeToggle()));
    }
    hostData() {
        return {
            class: {
                'range-picker': this.isRange,
                'date-picker': this.isDatePicker,
                'min-max': this.minDate || this.maxDate,
                [this.displayMode]: true,
                'web': isWeb()
            }
        };
    }
    render() {
        return ([
            isIonic() || this.isDatePicker ? this.renderMobileCalendar() : this.renderWebCalendar()
        ]);
    }
    static get is() { return "yoo-calendar"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "activeDay": {
            "type": "Any",
            "attr": "active-day"
        },
        "activeDayState": {
            "state": true
        },
        "dateRange": {
            "type": "Any",
            "attr": "date-range"
        },
        "displayMode": {
            "type": String,
            "attr": "display-mode",
            "mutable": true
        },
        "host": {
            "elementRef": true
        },
        "isDatePicker": {
            "type": Boolean,
            "attr": "is-date-picker"
        },
        "isRange": {
            "type": Boolean,
            "attr": "is-range"
        },
        "markers": {
            "type": "Any",
            "attr": "markers"
        },
        "maxDate": {
            "type": "Any",
            "attr": "max-date"
        },
        "minDate": {
            "type": "Any",
            "attr": "min-date"
        },
        "rangeLowerBound": {
            "state": true
        },
        "rangeUpperBound": {
            "state": true
        },
        "setActiveDay": {
            "method": true
        },
        "setDisplayMode": {
            "method": true
        },
        "slideChanged": {
            "state": true
        }
    }; }
    static get events() { return [{
            "name": "dateChanged",
            "method": "dateChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "dateRangeChanged",
            "method": "dateRangeChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "dayClicked",
            "method": "dayClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "displayModeChanged",
            "method": "displayModeChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "extraMonthsLoaded",
            "method": "extraMonthsLoaded",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "todaySelected",
            "method": "todaySelected",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "swipeHorizontal",
            "method": "swipeHorizontal",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  --active-day-circle-size: 2.0625rem;\n  --mobile-days-height: 100%;\n  --date-picker-margin: 0;\n  display: block;\n  background-color: var(--light, #FFFFFF);\n  opacity: 1; }\n  :host .toolbar-tools {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-align: center;\n    align-items: center; }\n    :host .toolbar-tools yoo-tooltip {\n      padding: 0.25rem; }\n      :host .toolbar-tools yoo-tooltip yoo-button {\n        padding: 0; }\n    :host .toolbar-tools h2 {\n      font-weight: 500;\n      text-transform: capitalize; }\n    :host .toolbar-tools yoo-button {\n      padding: 0.25rem; }\n    :host .toolbar-tools .active-day {\n      -ms-flex: 1 2 auto;\n      flex: 1 2 auto;\n      text-align: center; }\n  :host .days {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: column;\n    flex-direction: column; }\n  :host .week-header {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    min-height: 1.875rem;\n    margin-bottom: 0.875rem;\n    background: var(--light, #FFFFFF);\n    font-size: var(--font-s, 13px);\n    font-weight: 400; }\n    :host .week-header .day {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-direction: column;\n      flex-direction: column;\n      -ms-flex-line-pack: center;\n      align-content: center;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      padding: 0.3125rem;\n      font-size: var(--font-m, 15px);\n      font-style: normal;\n      font-weight: 400;\n      line-height: normal;\n      text-align: center; }\n  :host .week {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    border-bottom: var(--border-width, 1px) solid var(--stable-30, #E6E6E6); }\n    :host .week .day {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-direction: column;\n      flex-direction: column;\n      -ms-flex-line-pack: center;\n      align-content: center;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      height: 3.4375rem;\n      margin-top: 0.3125rem;\n      text-align: center;\n      cursor: pointer; }\n      :host .week .day.grey-day {\n        opacity: 0.3; }\n      :host .week .day.today.active .day-number {\n        background: var(--gradient-success, #04CC99);\n        color: var(--light, #FFFFFF); }\n      :host .week .day.today .day-number {\n        color: var(--success, #04CC99); }\n      :host .week .day.today .markers .marker.no-count {\n        background: var(--success, #04CC99); }\n      :host .week .day.single-range .day-number {\n        background: var(--gradient-success, #04CC99);\n        color: var(--light, #FFFFFF); }\n      :host .week .day.active .day-number {\n        background: var(--black, #000000);\n        color: var(--light, #FFFFFF); }\n      :host .week .day .day-number {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: row;\n        flex-direction: row;\n        -ms-flex-line-pack: center;\n        align-content: center;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: var(--active-day-circle-size);\n        min-width: 1.625rem;\n        height: var(--active-day-circle-size);\n        border-radius: 50%;\n        font-size: var(--font-l, 17px);\n        font-style: normal;\n        font-weight: 400;\n        line-height: normal; }\n    :host .week .markers {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-direction: row;\n      flex-direction: row;\n      -ms-flex-line-pack: center;\n      align-content: center;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      min-height: 1.3125rem; }\n      :host .week .markers .marker {\n        width: 1rem;\n        height: 1rem;\n        margin-right: 0.0625rem;\n        border-radius: 50%;\n        background: var(--accent, #1FB6FF);\n        color: var(--light, #FFFFFF);\n        font-size: var(--padding-10, 0.625rem);\n        line-height: 1rem; }\n        :host .week .markers .marker.extra {\n          background: var(--warning, #ff6402); }\n        :host .week .markers .marker.no-count {\n          width: 0.3125rem;\n          height: 0.3125rem;\n          background: var(--stable, #adadad); }\n  :host .ion-slide {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: column;\n    flex-direction: column; }\n  :host .mobile-calendar-header {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-align: center;\n    align-items: center;\n    width: 100%;\n    margin-bottom: 1.25rem; }\n    :host .mobile-calendar-header .active-month-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: baseline;\n      align-items: baseline; }\n      :host .mobile-calendar-header .active-month-container .prev-month {\n        padding: 0rem 0.3125rem 0rem 0.9375rem;\n        color: var(--stable-alt, #d0d0d0); }\n      :host .mobile-calendar-header .active-month-container .next-month {\n        padding-left: 0.3125rem;\n        color: var(--stable-alt, #d0d0d0); }\n      :host .mobile-calendar-header .active-month-container .active-month {\n        color: var(--black, #000000);\n        font-size: 1.3125rem;\n        font-style: normal;\n        font-weight: 400;\n        line-height: normal; }\n    :host .mobile-calendar-header .calendar-tools {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-pack: end;\n      justify-content: flex-end; }\n      :host .mobile-calendar-header .calendar-tools .calendar-toggle {\n        padding-right: var(--padding-15, 0.9375rem);\n        color: var(--stable-alt, #d0d0d0);\n        font-size: var(--font-m, 15px);\n        font-style: normal;\n        font-weight: 400;\n        line-height: normal; }\n        :host .mobile-calendar-header .calendar-tools .calendar-toggle:last-child {\n          padding-right: 0.4375rem; }\n        :host .mobile-calendar-header .calendar-tools .calendar-toggle.today:hover {\n          color: var(--success, #04CC99); }\n        :host .mobile-calendar-header .calendar-tools .calendar-toggle.active {\n          color: var(--success, #04CC99); }\n  :host .mobile-days {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    width: 100%; }\n    :host .mobile-days .in-range .day-number {\n      width: 100%;\n      border-radius: 0;\n      background: var(--success, #04CC99);\n      color: var(--light, #FFFFFF) !important;\n      opacity: 0.6; }\n    :host .mobile-days .in-range.first-day {\n      position: relative;\n      background: none; }\n      :host .mobile-days .in-range.first-day .day-number {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: row;\n        flex-direction: row;\n        -ms-flex-line-pack: center;\n        align-content: center;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: var(--active-day-circle-size);\n        min-width: 1.625rem;\n        height: var(--active-day-circle-size);\n        border-radius: 50%;\n        font-size: var(--font-l, 17px);\n        font-style: normal;\n        font-weight: 400;\n        line-height: normal;\n        background: var(--gradient-success, #04CC99);\n        color: var(--light, #FFFFFF);\n        opacity: 1;\n        z-index: 1; }\n      :host .mobile-days .in-range.first-day:after {\n        position: absolute;\n        top: 0;\n        right: 0;\n        left: calc(50% - var(--active-day-circle-size) / 2);\n        height: 2.0625rem;\n        margin-left: 0.8125rem;\n        background: var(--success, #04CC99);\n        content: \"\";\n        opacity: 0.6; }\n    :host .mobile-days .in-range.last-day {\n      position: relative;\n      background: none; }\n      :host .mobile-days .in-range.last-day .day-number {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: row;\n        flex-direction: row;\n        -ms-flex-line-pack: center;\n        align-content: center;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: var(--active-day-circle-size);\n        min-width: 1.625rem;\n        height: var(--active-day-circle-size);\n        border-radius: 50%;\n        font-size: var(--font-l, 17px);\n        font-style: normal;\n        font-weight: 400;\n        line-height: normal;\n        background: var(--gradient-success, #04CC99);\n        color: var(--light, #FFFFFF);\n        opacity: 1;\n        z-index: 1; }\n      :host .mobile-days .in-range.last-day:before {\n        position: absolute;\n        top: 0;\n        right: calc(50% - var(--active-day-circle-size) / 2);\n        left: 0;\n        height: 2.0625rem;\n        margin-right: var(--padding-15, 0.9375rem);\n        background: var(--success, #04CC99);\n        content: \"\";\n        opacity: 0.6; }\n\n:host(.week) .week {\n  border-bottom: none; }\n\n:host(.month) .calendar-container .swiper-control {\n  padding-top: var(--padding-20, 1.25rem); }\n\n:host(.date-picker) {\n  min-height: 28.75rem;\n  margin: 0 var(--date-picker-margin); }\n  :host(.date-picker) .mobile-days {\n    height: var(--picker-mobile-days-height); }\n\n:host(.range-picker) .week .day.grey-day,\n:host(.min-max) .week .day.grey-day {\n  pointer-events: none; }\n\n:host(.date) .mobile-days .week:last-child {\n  border-bottom: none; }\n\n:host(.web) .days {\n  height: 100%; }\n  :host(.web) .days .week-header {\n    margin-right: 0.75rem;\n    margin-left: 0.75rem; }\n  :host(.web) .days yoo-ion-scroll .web-days {\n    margin-bottom: var(--padding-20, 1.25rem); }\n  :host(.web) .days yoo-ion-scroll .active-month {\n    margin-left: var(--padding-20, 1.25rem);\n    font-size: var(--font-l, 17px); }\n  :host(.web) .days yoo-ion-scroll .week .day {\n    height: 3.125rem; }\n    :host(.web) .days yoo-ion-scroll .week .day .day-number {\n      width: 1.75rem;\n      height: 1.75rem;\n      font-size: var(--font-s, 13px); }\n\n\@media only screen and (max-width: 350px) {\n  :host .mobile-calendar-header .calendar-tools .calendar-toggle {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    max-width: 4rem; } }"; }
}

class YooChatMessageComponent {
    constructor() {
        this.hideEmptyCheckbox = false;
    }
    get isConferenceMessage() {
        return this.message && this.message.type === 'conference';
    }
    onClickMessage() {
        if (!this.message.readonly && this.message.author && this.message.author._id === getSession().userId) {
            this.message.selected = !this.message.selected;
            this.clicked.emit(this.message.selected);
        }
        if (this.isConferenceMessage && this.message && this.message.content) {
            this.conferenceMessageClicked.emit(this.message.content);
        }
    }
    onShowImage() {
        if (this.message.readonly && this.message.img) {
            showImageModal(this.message.img, null, true);
        }
    }
    renderConferenceMessage() {
        return h("div", { class: "conference-message-container" },
            h("yoo-icon", { class: "yo-play" }, " "),
            this.message && this.message.content);
    }
    renderUser() {
        return (h("div", { class: "user-container" }, this.message.author && ((this.isLast && this.isFirst) || (this.isLast && !this.isFirst)) &&
            h("yoo-avatar", { class: "small", user: this.message.author })));
    }
    renderTimeStamp() {
        return (this.message.time && this.isFirst &&
            h("div", { class: "info-container center" },
                h("span", null, pipes.timeAgo.transform(this.message.time))));
    }
    renderUserName() {
        if (this.message.author && this.message.author.firstName && this.message.author.lastName) {
            return [
                h("div", { class: {
                        'username': true
                    } }, `${this.message.author.firstName} ${this.message.author.lastName}`)
            ];
        }
        return null;
    }
    renderMessageContent() {
        return (h("div", { class: {
                "message-content": true,
                "first": this.isFirst,
                "last": this.isLast,
                "img": !isNullOrUndefined(this.message.img),
                "next-img": this.isNextImage
            }, onClick: () => this.onShowImage() },
            this.message.img ?
                (h("div", { class: "image-container" },
                    h("yoo-img", { type: "back", class: "image", src: cloudinary(this.message.img) })))
                : null,
            h("span", { class: "text" }, this.isConferenceMessage && !isCordova() ? this.renderConferenceMessage() : this.message.content)));
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return (h("div", { class: 'message ' + ((this.message.isAlternate) ? 'user-message' : 'other-message'), onClick: () => this.onClickMessage() },
            this.renderTimeStamp(),
            this.message.readonly ? null : (this.message.author && this.message.author._id === getSession().userId ? h("yoo-form-checkbox", { class: "btn-form-choice", value: this.message.selected }) : !this.hideEmptyCheckbox ? h("div", { class: "empty-checkbox" }) : null),
            this.isGroup && this.message.author && this.message.author._id !== getSession().userId ?
                [
                    this.isFirst && this.renderUserName(),
                    h("div", { class: "group-message-container" },
                        this.renderUser(),
                        this.renderMessageContent())
                ]
                : this.renderMessageContent()));
    }
    static get is() { return "yoo-chat-message"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "hideEmptyCheckbox": {
            "type": Boolean,
            "attr": "hide-empty-checkbox"
        },
        "host": {
            "elementRef": true
        },
        "isFirst": {
            "type": Boolean,
            "attr": "is-first"
        },
        "isGroup": {
            "type": Boolean,
            "attr": "is-group"
        },
        "isLast": {
            "type": Boolean,
            "attr": "is-last"
        },
        "isNextImage": {
            "type": Boolean,
            "attr": "is-next-image"
        },
        "message": {
            "type": "Any",
            "attr": "message",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "clicked",
            "method": "clicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "conferenceMessageClicked",
            "method": "conferenceMessageClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host(.operations) {\n  --background-message-content: var(--success, #04CC99); }\n\n:host(.boost) {\n  --background-message-content: var(--danger-light, #F46885); }\n\n:host {\n  --icon-total-width: 54px;\n  --message-container-padding-left: 15%; }\n  :host .message {\n    display: -ms-flexbox;\n    display: flex;\n    position: relative;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-wrap: wrap;\n    flex-wrap: wrap;\n    -ms-flex-align: center;\n    align-items: center;\n    max-width: 100%;\n    margin: 0.0625rem 0.2rem; }\n\n\@-webkit-keyframes slide-left {\n  0% {\n    -webkit-transform: translateX(-0.625rem);\n    transform: translateX(-0.625rem); }\n  100% {\n    -webkit-transform: translateY(0);\n    transform: translateY(0); } }\n\n\@keyframes slide-left {\n  0% {\n    -webkit-transform: translateX(-0.625rem);\n    transform: translateX(-0.625rem); }\n  100% {\n    -webkit-transform: translateY(0);\n    transform: translateY(0); } }\n    :host .message .empty-checkbox {\n      width: var(--padding-15, 0.9375rem);\n      height: var(--padding-15, 0.9375rem);\n      margin: var(--padding-5, 0.3125rem);\n      -webkit-animation: slide-left 0.4s ease;\n      animation: slide-left 0.4s ease; }\n    :host .message yoo-form-checkbox {\n      --yo-circle-color: var(--stable, #adadad) !important;\n      -webkit-animation: slide-left 0.4s ease;\n      animation: slide-left 0.4s ease; }\n    :host .message .message-content {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-direction: column;\n      flex-direction: column;\n      -ms-flex-item-align: end;\n      align-self: flex-end;\n      width: -webkit-fit-content;\n      width: -moz-fit-content;\n      width: fit-content;\n      max-width: 68%;\n      padding: 0.5rem 1rem;\n      border-radius: 1.25rem;\n      white-space: pre-wrap;\n      cursor: pointer;\n      -webkit-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n      word-wrap: break-word; }\n      :host .message .message-content.img {\n        padding: 0 !important;\n        background-color: transparent !important; }\n      :host .message .message-content .image-container {\n        width: 232px;\n        max-width: 100%;\n        height: 208px;\n        pointer-events: none; }\n        :host .message .message-content .image-container .image {\n          width: 100%;\n          min-width: 150px;\n          height: 100%;\n          min-height: 100px;\n          border-radius: 10px;\n          background: var(--light, #FFFFFF); }\n      :host .message .message-content .text {\n        pointer-events: none; }\n    :host .message .info-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: center;\n      align-items: center;\n      width: 100%;\n      margin: 0.2rem;\n      color: var(--text-color, #807f83);\n      font-size: var(--font-s, 13px);\n      white-space: nowrap; }\n      :host .message .info-container yoo-avatar {\n        margin-right: 0.3rem; }\n      :host .message .info-container.center {\n        -ms-flex-pack: center;\n        justify-content: center; }\n    :host .message.user-message .message-content {\n      max-width: 68%;\n      margin-left: auto;\n      border-top-right-radius: 5px;\n      border-bottom-right-radius: 5px;\n      background: var(--background-message-content);\n      color: var(--light, #FFFFFF);\n      word-wrap: break-word; }\n      :host .message.user-message .message-content.last {\n        border-bottom-right-radius: 1.25rem; }\n      :host .message.user-message .message-content.first {\n        border-top-right-radius: 1.25rem; }\n    :host .message.user-message .info-container {\n      margin-left: auto; }\n    :host .message.other-message .message-content {\n      -ms-flex-item-align: start;\n      align-self: flex-start;\n      width: -webkit-fit-content;\n      width: -moz-fit-content;\n      width: fit-content;\n      margin-right: auto;\n      border-top-left-radius: 5px;\n      border-bottom-left-radius: 5px;\n      background: var(--dark-10, #e6eaf0); }\n      :host .message.other-message .message-content.last {\n        border-bottom-left-radius: 1.25rem; }\n      :host .message.other-message .message-content.first {\n        border-top-left-radius: 1.25rem; }\n    :host .message .username {\n      display: -ms-flexbox;\n      display: flex;\n      width: 100%;\n      padding-bottom: 3px;\n      padding-left: var(--icon-total-width);\n      color: var(--text-color, #807f83);\n      font-size: var(--font-s, 13px);\n      text-align: left; }\n    :host .message .group-message-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: end;\n      align-items: flex-end;\n      margin-bottom: var(--padding-15, 0.9375rem);\n      padding-right: var(--message-container-padding-left); }\n      :host .message .group-message-container .user-container {\n        min-width: 3.375rem; }\n      :host .message .group-message-container .message-content.next-img {\n        border-radius: 1.25rem; }\n\n:host(.choice) .message.user-message .message-content {\n  -ms-flex-item-align: end;\n  align-self: flex-end;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  border: var(--border-width, 1px) solid var(--danger-light, #F46885);\n  border-radius: 1.25rem;\n  background: var(--light, #FFFFFF);\n  color: var(--dark, #2b3648); }\n\n:host(.boost) .message .message-content {\n  border-radius: 1.25rem; }"; }
}

class YooColorSelectorComponent {
    constructor() {
        /**
         * Determines whether we should show a tick icon or not when the color is selected; if false, the colors will be animated
         */
        this.showTickIcon = true;
    }
    componentWillLoad() {
        this.currentColor = this.colors[0];
    }
    onColorSelected(color) {
        this.currentColor = color;
        this.colorChanged.emit(color);
    }
    getStyleColorWhenWhite(color) {
        return color === WHITE || color === WHITE_DEVICE.hexCode ? BLACK : WHITE;
    }
    hostData() {
        return {
            class: {
                'no-tick': !this.showTickIcon
            }
        };
    }
    render() {
        return (h("div", { class: "color-selector-container" }, this.colors.map((color) => [
            h("div", { class: 'color-container', onClick: () => this.onColorSelected(color) },
                h("div", { class: {
                        'color-icon': true,
                        'current': this.currentColor === color
                    }, style: { 'background': color, 'border-color': (this.getStyleColorWhenWhite(color)) } }, this.showTickIcon && this.currentColor === color && h("yoo-icon", { class: "yo-thick", style: { 'color': this.getStyleColorWhenWhite(color) } })))
        ])));
    }
    static get is() { return "yoo-color-selector"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "colors": {
            "type": "Any",
            "attr": "colors"
        },
        "currentColor": {
            "state": true
        },
        "host": {
            "elementRef": true
        },
        "showTickIcon": {
            "type": Boolean,
            "attr": "show-tick-icon"
        }
    }; }
    static get events() { return [{
            "name": "colorChanged",
            "method": "colorChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host .color-selector-container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  -ms-flex-pack: distribute;\n  justify-content: space-around;\n  width: 100%;\n  margin-bottom: var(--padding-10, 0.625rem); }\n  :host .color-selector-container .color-container {\n    padding: var(--padding-5, 0.3125rem); }\n    :host .color-selector-container .color-container .color-icon {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-direction: row;\n      flex-direction: row;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      width: 1.375rem;\n      height: 1.375rem;\n      border: 1px solid var(--light, #FFFFFF);\n      border-radius: 50%;\n      text-align: center; }\n\n:host(.no-tick) .color-selector-container {\n  -ms-flex-pack: justify;\n  justify-content: space-between; }\n  :host(.no-tick) .color-selector-container .color-container .color-icon:hover {\n    -webkit-transform: scale(1.3);\n    transform: scale(1.3);\n    -webkit-transition: all 1s ease-in;\n    transition: all 1s ease-in; }\n  :host(.no-tick) .color-selector-container .color-container .color-icon.current {\n    -webkit-transform: scale(1.3);\n    transform: scale(1.3); }"; }
}

class YooDeviceComponent {
    componentWilLoad() {
        if (!this.deviceEntry.selectedColor && this.deviceEntry.colors.length > 0) {
            this.deviceEntry.selectedColor = this.deviceEntry.colors[0];
        }
    }
    getColor() {
        return this.deviceEntry.selectedColor ? this.deviceEntry.selectedColor.colorName :
            this.deviceEntry.colors && this.deviceEntry.colors.length > 0 ? this.deviceEntry.colors[0].colorName : '';
    }
    renderIOS() {
        return (this.deviceEntry.device === 'iphone-x' ?
            this.renderIphoneX() : this.renderIOSMobile());
    }
    renderIOSMobile() {
        return [
            h("div", { class: "top-bar" }),
            h("div", { class: "sleep" }),
            h("div", { class: "volume" }),
            h("div", { class: "camera" }),
            h("div", { class: "sensor" }),
            h("div", { class: "speaker" }),
            h("div", { class: "screen" },
                ",",
                h("slot", null)),
            h("div", { class: "home" }),
            h("div", { class: "bottom-bar" })
        ];
    }
    renderIphoneX() {
        return [
            h("div", { class: "notch" },
                h("div", { class: "camera" }),
                h("div", { class: "speaker" })),
            h("div", { class: "top-bar" }),
            h("div", { class: "sleep" }),
            h("div", { class: "bottom-bar" }),
            h("div", { class: "volume" }),
            h("div", { class: "overflow" },
                ",",
                h("div", { class: "shadow shadow--tr" }),
                h("div", { class: "shadow shadow--tl" }),
                h("div", { class: "shadow shadow--br" }),
                h("div", { class: "shadow shadow--bl" })),
            h("div", { class: "inner-shadow" }),
            h("div", { class: "screen" },
                h("slot", null))
        ];
    }
    renderNote8TopBar() {
        return [
            h("div", { class: "inner" }),
            h("div", { class: "overflow" },
                h("div", { class: "shadow" })),
            h("div", { class: "speaker" }),
            h("div", { class: "sensors" }),
            h("div", { class: "more-sensors" })
        ];
    }
    renderSensorSpeaker() {
        return [
            h("div", { class: "sensor" }),
            h("div", { class: "speaker" })
        ];
    }
    renderAndroid() {
        return [
            this.deviceEntry.device === 'note8' ? this.renderNote8TopBar() : h("div", { class: "top-bar" }),
            this.deviceEntry.device !== 'htc-one' && h("div", { class: "sleep" }),
            this.deviceEntry.device !== 'htc-one' && this.deviceEntry.device !== 's5' && h("div", { class: "volume" }),
            h("div", { class: "camera" }),
            this.deviceEntry.device === 'htc-one' || this.deviceEntry.device === 's5' && this.renderSensorSpeaker(),
            h("div", { class: "screen" },
                h("slot", null))
        ];
    }
    render() {
        return [
            h("div", { class: {
                    'marvel-device': true,
                    [this.deviceEntry.device]: true,
                    [this.getColor()]: true
                } }, this.deviceEntry.isIOSMobile ? this.renderIOS() : this.renderAndroid())
        ];
    }
    static get is() { return "yoo-device"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "deviceEntry": {
            "type": "Any",
            "attr": "device-entry"
        },
        "host": {
            "elementRef": true
        }
    }; }
    static get style() { return ".marvel-device{display:inline-block;position:relative;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}.marvel-device .screen{width:100%;position:relative;height:100%;z-index:3;background:white;overflow:hidden;display:block;border-radius:1px;-webkit-box-shadow:0 0 0 3px #111;box-shadow:0 0 0 3px #111}.marvel-device .top-bar,.marvel-device .bottom-bar{height:3px;background:black;width:100%;display:block}.marvel-device .middle-bar{width:3px;height:4px;top:0px;left:90px;background:black;position:absolute}.marvel-device.iphone8{width:375px;height:667px;padding:105px 24px;background:#d9dbdc;border-radius:56px;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.2);box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.2)}.marvel-device.iphone8:before{width:calc(100% - 12px);height:calc(100% - 12px);position:absolute;top:6px;content:'';left:6px;border-radius:50px;background:#f8f8f8;z-index:1}.marvel-device.iphone8:after{width:calc(100% - 16px);height:calc(100% - 16px);position:absolute;top:8px;content:'';left:8px;border-radius:48px;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #fff;box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #fff;z-index:2}.marvel-device.iphone8 .home{border-radius:100%;width:68px;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:22px;z-index:3;background:#303233;background:linear-gradient(135deg, #303233 0%, #b5b7b9 50%, #f0f2f2 69%, #303233 100%)}.marvel-device.iphone8 .home:before{background:#f8f8f8;position:absolute;content:'';border-radius:100%;width:calc(100% - 8px);height:calc(100% - 8px);top:4px;left:4px}.marvel-device.iphone8 .top-bar{height:14px;background:#bfbfc0;position:absolute;top:68px;left:0}.marvel-device.iphone8 .bottom-bar{height:14px;background:#bfbfc0;position:absolute;bottom:68px;left:0}.marvel-device.iphone8 .sleep{position:absolute;top:190px;right:-4px;width:4px;height:66px;border-radius:0px 2px 2px 0px;background:#d9dbdc}.marvel-device.iphone8 .volume{position:absolute;left:-4px;top:188px;z-index:0;height:66px;width:4px;border-radius:2px 0px 0px 2px;background:#d9dbdc}.marvel-device.iphone8 .volume:before{position:absolute;left:2px;top:-78px;height:40px;width:2px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone8 .volume:after{position:absolute;left:0px;top:82px;height:66px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone8 .camera{background:#3c3d3d;width:12px;height:12px;position:absolute;top:24px;left:50%;margin-left:-6px;border-radius:100%;z-index:3}.marvel-device.iphone8 .sensor{background:#3c3d3d;width:16px;height:16px;position:absolute;top:49px;left:134px;z-index:3;border-radius:100%}.marvel-device.iphone8 .speaker{background:#292728;width:70px;height:6px;position:absolute;top:54px;left:50%;margin-left:-35px;border-radius:6px;z-index:3}.marvel-device.iphone8.gold{background:#f9e7d3}.marvel-device.iphone8.gold .top-bar,.marvel-device.iphone8.gold .bottom-bar{background:white}.marvel-device.iphone8.gold .sleep,.marvel-device.iphone8.gold .volume{background:#f9e7d3}.marvel-device.iphone8.gold .home{background:#cebba9;background:linear-gradient(135deg, #cebba9 0%, #f9e7d3 50%, #cebba9 100%)}.marvel-device.iphone8.black{background:#464646;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.7);box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.7)}.marvel-device.iphone8.black:before{background:#080808}.marvel-device.iphone8.black:after{-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #212121;box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #212121}.marvel-device.iphone8.black .top-bar,.marvel-device.iphone8.black .bottom-bar{background:#212121}.marvel-device.iphone8.black .volume,.marvel-device.iphone8.black .sleep{background:#464646}.marvel-device.iphone8.black .camera{background:#080808}.marvel-device.iphone8.black .home{background:#080808;background:linear-gradient(135deg, #080808 0%, #464646 50%, #080808 100%)}.marvel-device.iphone8.black .home:before{background:#080808}.marvel-device.iphone8.landscape{padding:24px 105px;height:375px;width:667px}.marvel-device.iphone8.landscape .sleep{top:100%;border-radius:0px 0px 2px 2px;right:190px;height:4px;width:66px}.marvel-device.iphone8.landscape .volume{width:66px;height:4px;top:-4px;left:calc(100% - 188px - 66px);border-radius:2px 2px 0px 0px}.marvel-device.iphone8.landscape .volume:before{width:40px;height:2px;top:2px;right:-78px;left:auto;border-radius:2px 2px 0px 0px}.marvel-device.iphone8.landscape .volume:after{left:-82px;width:66px;height:4px;top:0;border-radius:2px 2px 0px 0px}.marvel-device.iphone8.landscape .top-bar{width:14px;height:100%;left:calc(100% - 68px -  14px);top:0}.marvel-device.iphone8.landscape .bottom-bar{width:14px;height:100%;left:68px;top:0}.marvel-device.iphone8.landscape .home{top:50%;margin-top:-34px;margin-left:0;left:22px}.marvel-device.iphone8.landscape .sensor{top:134px;left:calc(100% - 49px - 16px)}.marvel-device.iphone8.landscape .speaker{height:70px;width:6px;left:calc(100% - 54px - 6px);top:50%;margin-left:0px;margin-top:-35px}.marvel-device.iphone8.landscape .camera{left:calc(100% - 32px);top:50%;margin-left:0px;margin-top:-5px}.marvel-device.iphone8plus{width:414px;height:736px;padding:112px 26px;background:#d9dbdc;border-radius:56px;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.2);box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.2)}.marvel-device.iphone8plus:before{width:calc(100% - 12px);height:calc(100% - 12px);position:absolute;top:6px;content:'';left:6px;border-radius:50px;background:#f8f8f8;z-index:1}.marvel-device.iphone8plus:after{width:calc(100% - 16px);height:calc(100% - 16px);position:absolute;top:8px;content:'';left:8px;border-radius:48px;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #fff;box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #fff;z-index:2}.marvel-device.iphone8plus .home{border-radius:100%;width:68px;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:24px;z-index:3;background:#303233;background:linear-gradient(135deg, #303233 0%, #b5b7b9 50%, #f0f2f2 69%, #303233 100%)}.marvel-device.iphone8plus .home:before{background:#f8f8f8;position:absolute;content:'';border-radius:100%;width:calc(100% - 8px);height:calc(100% - 8px);top:4px;left:4px}.marvel-device.iphone8plus .top-bar{height:14px;background:#bfbfc0;position:absolute;top:68px;left:0}.marvel-device.iphone8plus .bottom-bar{height:14px;background:#bfbfc0;position:absolute;bottom:68px;left:0}.marvel-device.iphone8plus .sleep{position:absolute;top:190px;right:-4px;width:4px;height:66px;border-radius:0px 2px 2px 0px;background:#d9dbdc}.marvel-device.iphone8plus .volume{position:absolute;left:-4px;top:188px;z-index:0;height:66px;width:4px;border-radius:2px 0px 0px 2px;background:#d9dbdc}.marvel-device.iphone8plus .volume:before{position:absolute;left:2px;top:-78px;height:40px;width:2px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone8plus .volume:after{position:absolute;left:0px;top:82px;height:66px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone8plus .camera{background:#3c3d3d;width:12px;height:12px;position:absolute;top:29px;left:50%;margin-left:-6px;border-radius:100%;z-index:3}.marvel-device.iphone8plus .sensor{background:#3c3d3d;width:16px;height:16px;position:absolute;top:54px;left:154px;z-index:3;border-radius:100%}.marvel-device.iphone8plus .speaker{background:#292728;width:70px;height:6px;position:absolute;top:59px;left:50%;margin-left:-35px;border-radius:6px;z-index:3}.marvel-device.iphone8plus.gold{background:#f9e7d3}.marvel-device.iphone8plus.gold .top-bar,.marvel-device.iphone8plus.gold .bottom-bar{background:white}.marvel-device.iphone8plus.gold .sleep,.marvel-device.iphone8plus.gold .volume{background:#f9e7d3}.marvel-device.iphone8plus.gold .home{background:#cebba9;background:linear-gradient(135deg, #cebba9 0%, #f9e7d3 50%, #cebba9 100%)}.marvel-device.iphone8plus.black{background:#464646;-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.7);box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.7)}.marvel-device.iphone8plus.black:before{background:#080808}.marvel-device.iphone8plus.black:after{-webkit-box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #212121;box-shadow:inset 0 0 3px 0 rgba(0,0,0,0.1),inset 0 0 6px 3px #212121}.marvel-device.iphone8plus.black .top-bar,.marvel-device.iphone8plus.black .bottom-bar{background:#212121}.marvel-device.iphone8plus.black .volume,.marvel-device.iphone8plus.black .sleep{background:#464646}.marvel-device.iphone8plus.black .camera{background:#080808}.marvel-device.iphone8plus.black .home{background:#080808;background:linear-gradient(135deg, #080808 0%, #464646 50%, #080808 100%)}.marvel-device.iphone8plus.black .home:before{background:#080808}.marvel-device.iphone8plus.landscape{padding:26px 112px;height:414px;width:736px}.marvel-device.iphone8plus.landscape .sleep{top:100%;border-radius:0px 0px 2px 2px;right:190px;height:4px;width:66px}.marvel-device.iphone8plus.landscape .volume{width:66px;height:4px;top:-4px;left:calc(100% - 188px - 66px);border-radius:2px 2px 0px 0px}.marvel-device.iphone8plus.landscape .volume:before{width:40px;height:2px;top:2px;right:-78px;left:auto;border-radius:2px 2px 0px 0px}.marvel-device.iphone8plus.landscape .volume:after{left:-82px;width:66px;height:4px;top:0;border-radius:2px 2px 0px 0px}.marvel-device.iphone8plus.landscape .top-bar{width:14px;height:100%;left:calc(100% - 68px -  14px);top:0}.marvel-device.iphone8plus.landscape .bottom-bar{width:14px;height:100%;left:68px;top:0}.marvel-device.iphone8plus.landscape .home{top:50%;margin-top:-34px;margin-left:0;left:24px}.marvel-device.iphone8plus.landscape .sensor{top:154px;left:calc(100% - 54px - 16px)}.marvel-device.iphone8plus.landscape .speaker{height:70px;width:6px;left:calc(100% - 59px - 6px);top:50%;margin-left:0px;margin-top:-35px}.marvel-device.iphone8plus.landscape .camera{left:calc(100% - 29px);top:50%;margin-left:0px;margin-top:-5px}.marvel-device.iphone5s,.marvel-device.iphone5c{padding:105px 22px;background:#2c2b2c;width:320px;height:568px;border-radius:50px}.marvel-device.iphone5s:before,.marvel-device.iphone5c:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;top:4px;content:'';left:4px;border-radius:46px;background:#1e1e1e;z-index:1}.marvel-device.iphone5s .sleep,.marvel-device.iphone5c .sleep{position:absolute;top:-4px;right:60px;width:60px;height:4px;border-radius:2px 2px 0px 0px;background:#282727}.marvel-device.iphone5s .volume,.marvel-device.iphone5c .volume{position:absolute;left:-4px;top:180px;z-index:0;height:27px;width:4px;border-radius:2px 0px 0px 2px;background:#282727}.marvel-device.iphone5s .volume:before,.marvel-device.iphone5c .volume:before{position:absolute;left:0px;top:-75px;height:35px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone5s .volume:after,.marvel-device.iphone5c .volume:after{position:absolute;left:0px;bottom:-64px;height:27px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone5s .camera,.marvel-device.iphone5c .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:32px;left:50%;margin-left:-5px;border-radius:5px;z-index:3}.marvel-device.iphone5s .sensor,.marvel-device.iphone5c .sensor{background:#3c3d3d;width:10px;height:10px;position:absolute;top:60px;left:160px;z-index:3;margin-left:-32px;border-radius:5px}.marvel-device.iphone5s .speaker,.marvel-device.iphone5c .speaker{background:#292728;width:64px;height:10px;position:absolute;top:60px;left:50%;margin-left:-32px;border-radius:5px;z-index:3}.marvel-device.iphone5s.landscape,.marvel-device.iphone5c.landscape{padding:22px 105px;height:320px;width:568px}.marvel-device.iphone5s.landscape .sleep,.marvel-device.iphone5c.landscape .sleep{right:-4px;top:calc(100% - 120px);height:60px;width:4px;border-radius:0px 2px 2px 0px}.marvel-device.iphone5s.landscape .volume,.marvel-device.iphone5c.landscape .volume{width:27px;height:4px;top:-4px;left:calc(100% - 180px);border-radius:2px 2px 0px 0px}.marvel-device.iphone5s.landscape .volume:before,.marvel-device.iphone5c.landscape .volume:before{width:35px;height:4px;top:0px;right:-75px;left:auto;border-radius:2px 2px 0px 0px}.marvel-device.iphone5s.landscape .volume:after,.marvel-device.iphone5c.landscape .volume:after{bottom:0px;left:-64px;z-index:999;height:4px;width:27px;border-radius:2px 2px 0px 0px}.marvel-device.iphone5s.landscape .sensor,.marvel-device.iphone5c.landscape .sensor{top:160px;left:calc(100% - 60px);margin-left:0px;margin-top:-32px}.marvel-device.iphone5s.landscape .speaker,.marvel-device.iphone5c.landscape .speaker{height:64px;width:10px;left:calc(100% - 60px);top:50%;margin-left:0px;margin-top:-32px}.marvel-device.iphone5s.landscape .camera,.marvel-device.iphone5c.landscape .camera{left:calc(100% - 32px);top:50%;margin-left:0px;margin-top:-5px}.marvel-device.iphone5s .home{border-radius:36px;width:68px;-webkit-box-shadow:inset 0 0 0 4px #2c2b2c;box-shadow:inset 0 0 0 4px #2c2b2c;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:19px;z-index:3}.marvel-device.iphone5s .top-bar{top:70px;position:absolute;left:0}.marvel-device.iphone5s .bottom-bar{bottom:70px;position:absolute;left:0}.marvel-device.iphone5s.landscape .home{left:19px;bottom:50%;margin-bottom:-34px;margin-left:0px}.marvel-device.iphone5s.landscape .top-bar{left:70px;top:0px;width:3px;height:100%}.marvel-device.iphone5s.landscape .bottom-bar{right:70px;left:auto;bottom:0px;width:3px;height:100%}.marvel-device.iphone5s.silver{background:#bcbcbc}.marvel-device.iphone5s.silver:before{background:#fcfcfc}.marvel-device.iphone5s.silver .volume,.marvel-device.iphone5s.silver .sleep{background:#d6d6d6}.marvel-device.iphone5s.silver .top-bar,.marvel-device.iphone5s.silver .bottom-bar{background:#eaebec}.marvel-device.iphone5s.silver .home{-webkit-box-shadow:inset 0 0 0 4px #bcbcbc;box-shadow:inset 0 0 0 4px #bcbcbc}.marvel-device.iphone5s.gold{background:#f9e7d3}.marvel-device.iphone5s.gold:before{background:#fcfcfc}.marvel-device.iphone5s.gold .volume,.marvel-device.iphone5s.gold .sleep{background:#f9e7d3}.marvel-device.iphone5s.gold .top-bar,.marvel-device.iphone5s.gold .bottom-bar{background:white}.marvel-device.iphone5s.gold .home{-webkit-box-shadow:inset 0 0 0 4px #f9e7d3;box-shadow:inset 0 0 0 4px #f9e7d3}.marvel-device.iphone5c{background:white;-webkit-box-shadow:0 1px 2px 0 rgba(0,0,0,0.2);box-shadow:0 1px 2px 0 rgba(0,0,0,0.2)}.marvel-device.iphone5c .top-bar,.marvel-device.iphone5c .bottom-bar{display:none}.marvel-device.iphone5c .home{background:#242324;border-radius:36px;width:68px;height:68px;z-index:3;position:absolute;left:50%;margin-left:-34px;bottom:19px}.marvel-device.iphone5c .home:after{width:20px;height:20px;border:1px solid rgba(255,255,255,0.1);border-radius:4px;position:absolute;display:block;content:'';top:50%;left:50%;margin-top:-11px;margin-left:-11px}.marvel-device.iphone5c.landscape .home{left:19px;bottom:50%;margin-bottom:-34px;margin-left:0px}.marvel-device.iphone5c .volume,.marvel-device.iphone5c .sleep{background:#dddddd}.marvel-device.iphone5c.red{background:#f96b6c}.marvel-device.iphone5c.red .volume,.marvel-device.iphone5c.red .sleep{background:#ed5758}.marvel-device.iphone5c.yellow{background:#f2dc60}.marvel-device.iphone5c.yellow .volume,.marvel-device.iphone5c.yellow .sleep{background:#e5ce4c}.marvel-device.iphone5c.green{background:#97e563}.marvel-device.iphone5c.green .volume,.marvel-device.iphone5c.green .sleep{background:#85d94d}.marvel-device.iphone5c.blue{background:#33a2db}.marvel-device.iphone5c.blue .volume,.marvel-device.iphone5c.blue .sleep{background:#2694cd}.marvel-device.iphone4s{padding:129px 27px;width:320px;height:480px;background:#686868;border-radius:54px}.marvel-device.iphone4s:before{content:'';width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;top:4px;left:4px;z-index:1;border-radius:50px;background:#1e1e1e}.marvel-device.iphone4s .top-bar{top:60px;position:absolute;left:0}.marvel-device.iphone4s .bottom-bar{bottom:90px;position:absolute;left:0}.marvel-device.iphone4s .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:72px;left:134px;z-index:3;margin-left:-5px;border-radius:100%}.marvel-device.iphone4s .speaker{background:#292728;width:64px;height:10px;position:absolute;top:72px;left:50%;z-index:3;margin-left:-32px;border-radius:5px}.marvel-device.iphone4s .sensor{background:#292728;width:40px;height:10px;position:absolute;top:36px;left:50%;z-index:3;margin-left:-20px;border-radius:5px}.marvel-device.iphone4s .home{background:#242324;border-radius:100%;width:72px;height:72px;z-index:3;position:absolute;left:50%;margin-left:-36px;bottom:30px}.marvel-device.iphone4s .home:after{width:20px;height:20px;border:1px solid rgba(255,255,255,0.1);border-radius:4px;position:absolute;display:block;content:'';top:50%;left:50%;margin-top:-11px;margin-left:-11px}.marvel-device.iphone4s .sleep{position:absolute;top:-4px;right:60px;width:60px;height:4px;border-radius:2px 2px 0px 0px;background:#4D4D4D}.marvel-device.iphone4s .volume{position:absolute;left:-4px;top:160px;height:27px;width:4px;border-radius:2px 0px 0px 2px;background:#4D4D4D}.marvel-device.iphone4s .volume:before{position:absolute;left:0px;top:-70px;height:35px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone4s .volume:after{position:absolute;left:0px;bottom:-64px;height:27px;width:4px;border-radius:2px 0px 0px 2px;background:inherit;content:'';display:block}.marvel-device.iphone4s.landscape{padding:27px 129px;height:320px;width:480px}.marvel-device.iphone4s.landscape .bottom-bar{left:90px;bottom:0px;height:100%;width:3px}.marvel-device.iphone4s.landscape .top-bar{left:calc(100% - 60px);top:0px;height:100%;width:3px}.marvel-device.iphone4s.landscape .camera{top:134px;left:calc(100% - 72px);margin-left:0}.marvel-device.iphone4s.landscape .speaker{top:50%;margin-left:0;margin-top:-32px;left:calc(100% - 72px);width:10px;height:64px}.marvel-device.iphone4s.landscape .sensor{height:40px;width:10px;left:calc(100% - 36px);top:50%;margin-left:0;margin-top:-20px}.marvel-device.iphone4s.landscape .home{left:30px;bottom:50%;margin-left:0;margin-bottom:-36px}.marvel-device.iphone4s.landscape .sleep{height:60px;width:4px;right:-4px;top:calc(100% - 120px);border-radius:0px 2px 2px 0px}.marvel-device.iphone4s.landscape .volume{top:-4px;left:calc(100% - 187px);height:4px;width:27px;border-radius:2px 2px 0px 0px}.marvel-device.iphone4s.landscape .volume:before{right:-70px;left:auto;top:0px;width:35px;height:4px;border-radius:2px 2px 0px 0px}.marvel-device.iphone4s.landscape .volume:after{width:27px;height:4px;bottom:0px;left:-64px;border-radius:2px 2px 0px 0px}.marvel-device.iphone4s.silver{background:#bcbcbc}.marvel-device.iphone4s.silver:before{background:#fcfcfc}.marvel-device.iphone4s.silver .home{background:#fcfcfc;-webkit-box-shadow:inset 0 0 0 1px #bcbcbc;box-shadow:inset 0 0 0 1px #bcbcbc}.marvel-device.iphone4s.silver .home:after{border:1px solid rgba(0,0,0,0.2)}.marvel-device.iphone4s.silver .volume,.marvel-device.iphone4s.silver .sleep{background:#d6d6d6}.marvel-device.nexus5{padding:50px 15px 50px 15px;width:320px;height:568px;background:#1e1e1e;border-radius:20px}.marvel-device.nexus5:before{border-radius:600px / 50px;background:inherit;content:'';top:0;position:absolute;height:103.1%;width:calc(100% - 26px);top:50%;left:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.marvel-device.nexus5 .top-bar{width:calc(100% - 8px);height:calc(100% - 6px);position:absolute;top:3px;left:4px;border-radius:20px;background:#181818}.marvel-device.nexus5 .top-bar:before{border-radius:600px / 50px;background:inherit;content:'';top:0;position:absolute;height:103.0%;width:calc(100% - 26px);top:50%;left:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.marvel-device.nexus5 .bottom-bar{display:none}.marvel-device.nexus5 .sleep{width:3px;position:absolute;left:-3px;top:110px;height:100px;background:inherit;border-radius:2px 0px 0px 2px}.marvel-device.nexus5 .volume{width:3px;position:absolute;right:-3px;top:70px;height:45px;background:inherit;border-radius:0px 2px 2px 0px}.marvel-device.nexus5 .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:18px;left:50%;z-index:3;margin-left:-5px;border-radius:100%}.marvel-device.nexus5 .camera:before{background:#3c3d3d;width:6px;height:6px;content:'';display:block;position:absolute;top:2px;left:-100px;z-index:3;border-radius:100%}.marvel-device.nexus5.landscape{padding:15px 50px 15px 50px;height:320px;width:568px}.marvel-device.nexus5.landscape:before{width:103.1%;height:calc(100% - 26px);border-radius:50px / 600px}.marvel-device.nexus5.landscape .top-bar{left:3px;top:4px;height:calc(100% - 8px);width:calc(100% - 6px)}.marvel-device.nexus5.landscape .top-bar:before{width:103%;height:calc(100% - 26px);border-radius:50px / 600px}.marvel-device.nexus5.landscape .sleep{height:3px;width:100px;left:calc(100% - 210px);top:-3px;border-radius:2px 2px 0px 0px}.marvel-device.nexus5.landscape .volume{height:3px;width:45px;right:70px;top:100%;border-radius:0px 0px 2px 2px}.marvel-device.nexus5.landscape .camera{top:50%;left:calc(100% - 18px);margin-left:0;margin-top:-5px}.marvel-device.nexus5.landscape .camera:before{top:-100px;left:2px}.marvel-device.s5{padding:60px 18px;border-radius:42px;width:320px;height:568px;background:#bcbcbc}.marvel-device.s5:before,.marvel-device.s5:after{width:calc(100% - 52px);content:'';display:block;height:26px;background:inherit;position:absolute;border-radius:500px / 40px;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.marvel-device.s5:before{top:-7px}.marvel-device.s5:after{bottom:-7px}.marvel-device.s5 .bottom-bar{display:none}.marvel-device.s5 .top-bar{border-radius:37px;width:calc(100% - 10px);height:calc(100% - 10px);top:5px;left:5px;background:radial-gradient(rgba(0,0,0,0.02) 20%, transparent 60%) 0 0,radial-gradient(rgba(0,0,0,0.02) 20%, transparent 60%) 3px 3px;background-color:white;background-size:4px 4px;background-position:center;z-index:2;position:absolute}.marvel-device.s5 .top-bar:before,.marvel-device.s5 .top-bar:after{width:calc(100% - 48px);content:'';display:block;height:26px;background:inherit;position:absolute;border-radius:500px / 40px;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.marvel-device.s5 .top-bar:before{top:-7px}.marvel-device.s5 .top-bar:after{bottom:-7px}.marvel-device.s5 .sleep{width:3px;position:absolute;left:-3px;top:100px;height:100px;background:#cecece;border-radius:2px 0px 0px 2px}.marvel-device.s5 .speaker{width:68px;height:8px;position:absolute;top:20px;display:block;z-index:3;left:50%;margin-left:-34px;background-color:#bcbcbc;background-position:top left;border-radius:4px}.marvel-device.s5 .sensor{display:block;position:absolute;top:20px;right:110px;background:#3c3d3d;border-radius:100%;width:8px;height:8px;z-index:3}.marvel-device.s5 .sensor:after{display:block;content:'';position:absolute;top:0px;right:12px;background:#3c3d3d;border-radius:100%;width:8px;height:8px;z-index:3}.marvel-device.s5 .camera{display:block;position:absolute;top:24px;right:42px;background:black;border-radius:100%;width:10px;height:10px;z-index:3}.marvel-device.s5 .camera:before{width:4px;height:4px;background:#3c3d3d;border-radius:100%;position:absolute;content:'';top:50%;left:50%;margin-top:-2px;margin-left:-2px}.marvel-device.s5 .home{position:absolute;z-index:3;bottom:17px;left:50%;width:70px;height:20px;background:white;border-radius:18px;display:block;margin-left:-35px;border:2px solid black}.marvel-device.s5.landscape{padding:18px 60px;height:320px;width:568px}.marvel-device.s5.landscape:before,.marvel-device.s5.landscape:after{height:calc(100% - 52px);width:26px;border-radius:40px / 500px;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.marvel-device.s5.landscape:before{top:50%;left:-7px}.marvel-device.s5.landscape:after{top:50%;left:auto;right:-7px}.marvel-device.s5.landscape .top-bar:before,.marvel-device.s5.landscape .top-bar:after{width:26px;height:calc(100% - 48px);border-radius:40px / 500px;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.marvel-device.s5.landscape .top-bar:before{right:-7px;top:50%;left:auto}.marvel-device.s5.landscape .top-bar:after{left:-7px;top:50%;right:auto}.marvel-device.s5.landscape .sleep{height:3px;width:100px;left:calc(100% - 200px);top:-3px;border-radius:2px 2px 0px 0px}.marvel-device.s5.landscape .speaker{height:68px;width:8px;left:calc(100% - 20px);top:50%;margin-left:0;margin-top:-34px}.marvel-device.s5.landscape .sensor{right:20px;top:calc(100% - 110px)}.marvel-device.s5.landscape .sensor:after{left:-12px;right:0px}.marvel-device.s5.landscape .camera{top:calc(100% - 42px);right:24px}.marvel-device.s5.landscape .home{width:20px;height:70px;bottom:50%;margin-bottom:-35px;margin-left:0;left:17px}.marvel-device.s5.black{background:#1e1e1e}.marvel-device.s5.black .speaker{background:black}.marvel-device.s5.black .sleep{background:#1e1e1e}.marvel-device.s5.black .top-bar{background:radial-gradient(rgba(0,0,0,0.05) 20%, transparent 60%) 0 0,radial-gradient(rgba(0,0,0,0.05) 20%, transparent 60%) 3px 3px;background-color:#2c2b2c;background-size:4px 4px}.marvel-device.s5.black .home{background:#2c2b2c}.marvel-device.lumia920{padding:80px 35px 125px 35px;background:#ffdd00;width:320px;height:533px;border-radius:40px / 3px}.marvel-device.lumia920 .bottom-bar{display:none}.marvel-device.lumia920 .top-bar{width:calc(100% - 24px);height:calc(100% - 32px);position:absolute;top:16px;left:12px;border-radius:24px;background:black;z-index:1}.marvel-device.lumia920 .top-bar:before{background:#1e1e1e;display:block;content:'';width:calc(100% - 4px);height:calc(100% - 4px);top:2px;left:2px;position:absolute;border-radius:22px}.marvel-device.lumia920 .volume{width:3px;position:absolute;top:130px;height:100px;background:#1e1e1e;right:-3px;border-radius:0px 2px 2px 0px}.marvel-device.lumia920 .volume:before{width:3px;position:absolute;top:190px;content:'';display:block;height:50px;background:inherit;right:0px;border-radius:0px 2px 2px 0px}.marvel-device.lumia920 .volume:after{width:3px;position:absolute;top:460px;content:'';display:block;height:50px;background:inherit;right:0px;border-radius:0px 2px 2px 0px}.marvel-device.lumia920 .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:34px;right:130px;z-index:5;border-radius:5px}.marvel-device.lumia920 .speaker{background:#292728;width:64px;height:10px;position:absolute;top:38px;left:50%;margin-left:-32px;border-radius:5px;z-index:3}.marvel-device.lumia920.landscape{padding:35px 80px 35px 125px;height:320px;width:568px;border-radius:2px / 100px}.marvel-device.lumia920.landscape .top-bar{height:calc(100% - 24px);width:calc(100% - 32px);left:16px;top:12px}.marvel-device.lumia920.landscape .volume{height:3px;right:130px;width:100px;top:100%;border-radius:0px 0px 2px 2px}.marvel-device.lumia920.landscape .volume:before{height:3px;right:190px;top:0px;width:50px;border-radius:0px 0px 2px 2px}.marvel-device.lumia920.landscape .volume:after{height:3px;right:430px;top:0px;width:50px;border-radius:0px 0px 2px 2px}.marvel-device.lumia920.landscape .camera{right:30px;top:calc(100% - 140px)}.marvel-device.lumia920.landscape .speaker{width:10px;height:64px;top:50%;margin-left:0;margin-top:-32px;left:calc(100% - 48px)}.marvel-device.lumia920.black{background:black}.marvel-device.lumia920.white{background:white;-webkit-box-shadow:0 1px 2px 0 rgba(0,0,0,0.2);box-shadow:0 1px 2px 0 rgba(0,0,0,0.2)}.marvel-device.lumia920.blue{background:#00acdd}.marvel-device.lumia920.red{background:#CC3E32}.marvel-device.htc-one{padding:72px 25px 100px 25px;width:320px;height:568px;background:#bebebe;border-radius:34px}.marvel-device.htc-one:before{content:'';display:block;width:calc(100% - 4px);height:calc(100% - 4px);position:absolute;top:2px;left:2px;background:#adadad;border-radius:32px}.marvel-device.htc-one:after{content:'';display:block;width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;top:4px;left:4px;background:#eeeeee;border-radius:30px}.marvel-device.htc-one .top-bar{width:calc(100% - 4px);height:635px;position:absolute;background:#424242;top:50px;z-index:1;left:2px}.marvel-device.htc-one .top-bar:before{content:'';position:absolute;width:calc(100% - 4px);height:100%;position:absolute;background:black;top:0px;z-index:1;left:2px}.marvel-device.htc-one .bottom-bar{display:none}.marvel-device.htc-one .speaker{height:16px;width:216px;display:block;position:absolute;top:22px;z-index:2;left:50%;margin-left:-108px;background:radial-gradient(#343434 25%, transparent 50%) 0 0,radial-gradient(#343434 25%, transparent 50%) 4px 4px;background-size:4px 4px;background-position:top left}.marvel-device.htc-one .speaker:after{content:'';height:16px;width:216px;display:block;position:absolute;top:676px;z-index:2;left:50%;margin-left:-108px;background:inherit}.marvel-device.htc-one .camera{display:block;position:absolute;top:18px;right:38px;background:#3c3d3d;border-radius:100%;width:24px;height:24px;z-index:3}.marvel-device.htc-one .camera:before{width:8px;height:8px;background:black;border-radius:100%;position:absolute;content:'';top:50%;left:50%;margin-top:-4px;margin-left:-4px}.marvel-device.htc-one .sensor{display:block;position:absolute;top:29px;left:60px;background:#3c3d3d;border-radius:100%;width:8px;height:8px;z-index:3}.marvel-device.htc-one .sensor:after{display:block;content:'';position:absolute;top:0px;right:12px;background:#3c3d3d;border-radius:100%;width:8px;height:8px;z-index:3}.marvel-device.htc-one.landscape{padding:25px 72px 25px 100px;height:320px;width:568px}.marvel-device.htc-one.landscape .top-bar{height:calc(100% - 4px);width:635px;left:calc(100% - 685px);top:2px}.marvel-device.htc-one.landscape .speaker{width:16px;height:216px;left:calc(100% - 38px);top:50%;margin-left:0px;margin-top:-108px}.marvel-device.htc-one.landscape .speaker:after{width:16px;height:216px;left:calc(100% - 692px);top:50%;margin-left:0;margin-top:-108px}.marvel-device.htc-one.landscape .camera{right:18px;top:calc(100% - 38px)}.marvel-device.htc-one.landscape .sensor{left:calc(100% - 29px);top:60px}.marvel-device.htc-one.landscape .sensor :after{right:0;top:-12px}.marvel-device.ipad{width:576px;height:768px;padding:90px 25px;background:#242324;border-radius:44px}.marvel-device.ipad:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;content:'';display:block;top:4px;left:4px;border-radius:40px;background:#1e1e1e}.marvel-device.ipad .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:44px;left:50%;margin-left:-5px;border-radius:100%}.marvel-device.ipad .top-bar,.marvel-device.ipad .bottom-bar{display:none}.marvel-device.ipad .home{background:#242324;border-radius:36px;width:50px;height:50px;position:absolute;left:50%;margin-left:-25px;bottom:22px}.marvel-device.ipad .home:after{width:15px;height:15px;margin-top:-8px;margin-left:-8px;border:1px solid rgba(255,255,255,0.1);border-radius:4px;position:absolute;display:block;content:'';top:50%;left:50%}.marvel-device.ipad.landscape{height:576px;width:768px;padding:25px 90px}.marvel-device.ipad.landscape .camera{left:calc(100% - 44px);top:50%;margin-left:0;margin-top:-5px}.marvel-device.ipad.landscape .home{top:50%;left:22px;margin-left:0;margin-top:-25px}.marvel-device.ipad.silver{background:#bcbcbc}.marvel-device.ipad.silver:before{background:#fcfcfc}.marvel-device.ipad.silver .home{background:#fcfcfc;-webkit-box-shadow:inset 0 0 0 1px #bcbcbc;box-shadow:inset 0 0 0 1px #bcbcbc}.marvel-device.ipad.silver .home:after{border:1px solid rgba(0,0,0,0.2)}.marvel-device.macbook{width:960px;height:600px;padding:44px 44px 76px;margin:0 auto;background:#bebebe;border-radius:34px}.marvel-device.macbook:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;content:'';display:block;top:4px;left:4px;border-radius:30px;background:#1e1e1e}.marvel-device.macbook .top-bar{width:calc(100% + 2 * 70px);height:40px;position:absolute;content:'';display:block;top:680px;left:-70px;border-bottom-left-radius:90px 18px;border-bottom-right-radius:90px 18px;background:#bebebe;-webkit-box-shadow:inset 0px -4px 13px 3px rgba(34,34,34,0.6);box-shadow:inset 0px -4px 13px 3px rgba(34,34,34,0.6)}.marvel-device.macbook .top-bar:before{width:100%;height:24px;content:'';display:block;top:0;left:0;background:#f0f0f0;border-bottom:2px solid #aaa;border-radius:5px;position:relative}.marvel-device.macbook .top-bar:after{width:16%;height:14px;content:'';display:block;top:0;background:#ddd;position:absolute;margin-left:auto;margin-right:auto;left:0;right:0;border-radius:0 0 20px 20px;-webkit-box-shadow:inset 0px -3px 10px #999;box-shadow:inset 0px -3px 10px #999}.marvel-device.macbook .bottom-bar{background:transparent;width:calc(100% + 2 * 70px);height:26px;position:absolute;content:'';display:block;top:680px;left:-70px}.marvel-device.macbook .bottom-bar:before,.marvel-device.macbook .bottom-bar:after{height:calc(100% - 2px);width:80px;content:'';display:block;top:0;position:absolute}.marvel-device.macbook .bottom-bar:before{left:0;background:#f0f0f0;background:-webkit-gradient(linear, left top, right top, from(#747474), color-stop(5%, #c3c3c3), color-stop(14%, #ebebeb), color-stop(41%, #979797), color-stop(80%, #f0f0f0), color-stop(100%, #f0f0f0), to(#f0f0f0));background:linear-gradient(to right, #747474 0%, #c3c3c3 5%, #ebebeb 14%, #979797 41%, #f0f0f0 80%, #f0f0f0 100%, #f0f0f0 100%)}.marvel-device.macbook .bottom-bar:after{right:0;background:#f0f0f0;background:-webkit-gradient(linear, left top, right top, from(#f0f0f0), color-stop(0%, #f0f0f0), color-stop(20%, #f0f0f0), color-stop(59%, #979797), color-stop(86%, #ebebeb), color-stop(95%, #c3c3c3), to(#747474));background:linear-gradient(to right, #f0f0f0 0%, #f0f0f0 0%, #f0f0f0 20%, #979797 59%, #ebebeb 86%, #c3c3c3 95%, #747474 100%)}.marvel-device.macbook .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:20px;left:50%;margin-left:-5px;border-radius:100%}.marvel-device.macbook .home{display:none}.marvel-device.iphone-x{width:375px;height:812px;padding:26px;background:#fdfdfd;-webkit-box-shadow:inset 0 0 11px 0 black;box-shadow:inset 0 0 11px 0 black;border-radius:66px}.marvel-device.iphone-x .overflow{width:100%;height:100%;position:absolute;top:0;left:0;border-radius:66px;overflow:hidden}.marvel-device.iphone-x .shadow{border-radius:100%;width:90px;height:90px;position:absolute;background:radial-gradient(ellipse at center, rgba(0,0,0,0.6) 0%, rgba(255,255,255,0) 60%)}.marvel-device.iphone-x .shadow--tl{top:-20px;left:-20px}.marvel-device.iphone-x .shadow--tr{top:-20px;right:-20px}.marvel-device.iphone-x .shadow--bl{bottom:-20px;left:-20px}.marvel-device.iphone-x .shadow--br{bottom:-20px;right:-20px}.marvel-device.iphone-x:before{width:calc(100% - 10px);height:calc(100% - 10px);position:absolute;top:5px;content:'';left:5px;border-radius:61px;background:black;z-index:1}.marvel-device.iphone-x .inner-shadow{width:calc(100% - 20px);height:calc(100% - 20px);position:absolute;top:10px;overflow:hidden;left:10px;border-radius:56px;-webkit-box-shadow:inset 0 0 15px 0 rgba(255,255,255,0.66);box-shadow:inset 0 0 15px 0 rgba(255,255,255,0.66);z-index:1}.marvel-device.iphone-x .inner-shadow:before{-webkit-box-shadow:inset 0 0 20px 0 #FFFFFF;box-shadow:inset 0 0 20px 0 #FFFFFF;width:100%;height:116%;position:absolute;top:-8%;content:'';left:0;border-radius:200px / 112px;z-index:2}.marvel-device.iphone-x .screen{border-radius:40px;-webkit-box-shadow:none;box-shadow:none}.marvel-device.iphone-x .top-bar,.marvel-device.iphone-x .bottom-bar{width:100%;position:absolute;height:8px;background:rgba(0,0,0,0.1);left:0}.marvel-device.iphone-x .top-bar{top:80px}.marvel-device.iphone-x .bottom-bar{bottom:80px}.marvel-device.iphone-x .volume,.marvel-device.iphone-x .volume:before,.marvel-device.iphone-x .volume:after,.marvel-device.iphone-x .sleep{width:3px;background:#b5b5b5;position:absolute}.marvel-device.iphone-x .volume{left:-3px;top:116px;height:32px}.marvel-device.iphone-x .volume:before{height:62px;top:62px;content:'';left:0}.marvel-device.iphone-x .volume:after{height:62px;top:140px;content:'';left:0}.marvel-device.iphone-x .sleep{height:96px;top:200px;right:-3px}.marvel-device.iphone-x .camera{width:6px;height:6px;top:9px;border-radius:100%;position:absolute;left:154px;background:#0d4d71}.marvel-device.iphone-x .speaker{height:6px;width:60px;left:50%;position:absolute;top:9px;margin-left:-30px;background:#171818;border-radius:6px}.marvel-device.iphone-x .notch{position:absolute;width:210px;height:30px;top:26px;left:108px;z-index:4;background:black;border-bottom-left-radius:24px;border-bottom-right-radius:24px}.marvel-device.iphone-x .notch:before,.marvel-device.iphone-x .notch:after{content:'';height:8px;position:absolute;top:0;width:8px}.marvel-device.iphone-x .notch:after{background:radial-gradient(circle at bottom left, transparent 0, transparent 70%, black 70%, black 100%);left:-8px}.marvel-device.iphone-x .notch:before{background:radial-gradient(circle at bottom right, transparent 0, transparent 70%, black 70%, black 100%);right:-8px}.marvel-device.iphone-x.landscape{height:375px;width:812px}.marvel-device.iphone-x.landscape .top-bar,.marvel-device.iphone-x.landscape .bottom-bar{width:8px;height:100%;top:0}.marvel-device.iphone-x.landscape .top-bar{left:80px}.marvel-device.iphone-x.landscape .bottom-bar{right:80px;bottom:auto;left:auto}.marvel-device.iphone-x.landscape .volume,.marvel-device.iphone-x.landscape .volume:before,.marvel-device.iphone-x.landscape .volume:after,.marvel-device.iphone-x.landscape .sleep{height:3px}.marvel-device.iphone-x.landscape .inner-shadow:before{height:100%;width:116%;left:-8%;top:0;border-radius:112px / 200px}.marvel-device.iphone-x.landscape .volume{bottom:-3px;top:auto;left:116px;width:32px}.marvel-device.iphone-x.landscape .volume:before{width:62px;left:62px;top:0}.marvel-device.iphone-x.landscape .volume:after{width:62px;left:140px;top:0}.marvel-device.iphone-x.landscape .sleep{width:96px;left:200px;top:-3px;right:auto}.marvel-device.iphone-x.landscape .camera{left:9px;bottom:154px;top:auto}.marvel-device.iphone-x.landscape .speaker{width:6px;height:60px;left:9px;top:50%;margin-top:-30px;margin-left:0}.marvel-device.iphone-x.landscape .notch{height:210px;width:30px;left:26px;bottom:108px;top:auto;border-top-right-radius:24px;border-bottom-right-radius:24px;border-bottom-left-radius:0}.marvel-device.iphone-x.landscape .notch:before,.marvel-device.iphone-x.landscape .notch:after{left:0}.marvel-device.iphone-x.landscape .notch:after{background:radial-gradient(circle at bottom right, transparent 0, transparent 70%, black 70%, black 100%);bottom:-8px;top:auto}.marvel-device.iphone-x.landscape .notch:before{background:radial-gradient(circle at top right, transparent 0, transparent 70%, black 70%, black 100%);top:-8px}.marvel-device.note8{width:400px;height:822px;background:black;border-radius:34px;padding:45px 10px}.marvel-device.note8 .overflow{width:100%;height:100%;position:absolute;top:0;left:0;border-radius:34px;overflow:hidden}.marvel-device.note8 .speaker{height:8px;width:56px;left:50%;position:absolute;top:25px;margin-left:-28px;background:#171818;z-index:1;border-radius:8px}.marvel-device.note8 .camera{height:18px;width:18px;left:86px;position:absolute;top:18px;background:#212b36;z-index:1;border-radius:100%}.marvel-device.note8 .camera:before{content:'';height:8px;width:8px;left:-22px;position:absolute;top:5px;background:#212b36;z-index:1;border-radius:100%}.marvel-device.note8 .sensors{height:10px;width:10px;left:120px;position:absolute;top:22px;background:#1d233b;z-index:1;border-radius:100%}.marvel-device.note8 .sensors:before{content:'';height:10px;width:10px;left:18px;position:absolute;top:0;background:#1d233b;z-index:1;border-radius:100%}.marvel-device.note8 .more-sensors{height:16px;width:16px;left:285px;position:absolute;top:18px;background:#33244a;-webkit-box-shadow:0 0 0 2px rgba(255,255,255,0.1);box-shadow:0 0 0 2px rgba(255,255,255,0.1);z-index:1;border-radius:100%}.marvel-device.note8 .more-sensors:before{content:'';height:11px;width:11px;left:40px;position:absolute;top:4px;background:#214a61;z-index:1;border-radius:100%}.marvel-device.note8 .sleep{width:2px;height:56px;background:black;position:absolute;top:288px;right:-2px}.marvel-device.note8 .volume{width:2px;height:120px;background:black;position:absolute;top:168px;left:-2px}.marvel-device.note8 .volume:before{content:'';top:168px;width:2px;position:absolute;left:0;background:black;height:56px}.marvel-device.note8 .inner{width:100%;height:calc(100% - 8px);position:absolute;top:2px;content:'';left:0px;border-radius:34px;border-top:2px solid #9fa0a2;border-bottom:2px solid #9fa0a2;background:black;z-index:1;-webkit-box-shadow:inset 0 0 6px 0 rgba(255,255,255,0.5);box-shadow:inset 0 0 6px 0 rgba(255,255,255,0.5)}.marvel-device.note8 .shadow{-webkit-box-shadow:inset 0 0 60px 0 white,inset 0 0 30px 0 rgba(255,255,255,0.5),0 0 20px 0 white,0 0 20px 0 rgba(255,255,255,0.5);box-shadow:inset 0 0 60px 0 white,inset 0 0 30px 0 rgba(255,255,255,0.5),0 0 20px 0 white,0 0 20px 0 rgba(255,255,255,0.5);height:101%;position:absolute;top:-0.5%;content:'';width:calc(100% - 20px);left:10px;border-radius:38px;z-index:5;pointer-events:none}.marvel-device.note8 .screen{border-radius:14px;-webkit-box-shadow:none;box-shadow:none}.marvel-device.note8.landscape{height:400px;width:822px;padding:10px 45px}.marvel-device.note8.landscape .speaker{height:56px;width:8px;top:50%;margin-top:-28px;margin-left:0;right:25px;left:auto}.marvel-device.note8.landscape .camera{top:86px;right:18px;left:auto}.marvel-device.note8.landscape .camera:before{top:-22px;left:5px}.marvel-device.note8.landscape .sensors{top:120px;right:22px;left:auto}.marvel-device.note8.landscape .sensors:before{top:18px;left:0}.marvel-device.note8.landscape .more-sensors{top:285px;right:18px;left:auto}.marvel-device.note8.landscape .more-sensors:before{top:40px;left:4px}.marvel-device.note8.landscape .sleep{bottom:-2px;top:auto;right:288px;width:56px;height:2px}.marvel-device.note8.landscape .volume{width:120px;height:2px;top:-2px;right:168px;left:auto}.marvel-device.note8.landscape .volume:before{right:168px;left:auto;top:0;width:56px;height:2px}.marvel-device.note8.landscape .inner{height:100%;width:calc(100% - 8px);left:2px;top:0;border-top:0;border-bottom:0;border-left:2px solid #9fa0a2;border-right:2px solid #9fa0a2}.marvel-device.note8.landscape .shadow{width:101%;height:calc(100% - 20px);left:-0.5%;top:10px}\n\n:host { }"; }
}

class YooEntitySearchDialogComponent {
    constructor() {
        this.isTabbarHidden = false;
    }
    onHideTabbar(ev) {
        this.isTabbarHidden = hideShowTabbar(ev, this.footer, this.isTabbarHidden);
    }
    componentWillLoad() {
        if (this.values) {
            this.sorts = this.values.sorts;
            this.filters = this.values.filters;
            if ((this.sorts && this.sorts.length > 0) || (this.filters && this.filters.length > 0)) {
                this.isDirty = true;
            }
        }
    }
    onCancel() {
        closeModal(null);
    }
    onApply() {
        closeModal({ sorts: this.sorts, filters: this.filters });
    }
    onClearAll() {
        if (this.isDirty) {
            let message = translate('DELETEALLFILTERS');
            showAlert(translate('DELETE'), [translate('CANCEL'), translate('OK')], null, message).then(ret => {
                if (ret === true) {
                    this.values = { filters: [], sorts: [] };
                    this.sorts = [];
                    this.filters = [];
                    this.isDirty = false;
                }
            });
        }
    }
    onSort(ev) {
        this.sorts = ev.detail;
        if (this.sorts && this.sorts.length > 0) {
            this.isDirty = true;
        }
    }
    onFilter(ev) {
        this.filters = ev.detail;
        if (this.filters && this.filters.length > 0) {
            this.isDirty = true;
        }
    }
    onFieldFetchData(ev) {
        ev.stopPropagation();
        this.fieldFetchData.emit(ev.detail);
    }
    render() {
        return [
            h("yoo-ion-header", { class: "shadow", "no-border": true },
                h("yoo-ion-toolbar", { color: "light" },
                    h("yoo-ion-buttons", { slot: "start" },
                        h("yoo-ion-button", { class: "close button-clear", onClick: () => this.onCancel() },
                            h("yoo-icon", { slot: "icon-only", class: "yo-close" }))),
                    h("yoo-ion-title", null, translate('ADVANCEDFILTERS')),
                    h("yoo-ion-buttons", { slot: "end" },
                        h("yoo-ion-button", { color: "success", class: "button-clear", disabled: !this.isDirty, onClick: () => this.onClearAll() }, translate('CLEARALL'))))),
            h("yoo-ion-content", { scrollEnabled: true, scrollEvents: true },
                h("div", null,
                    h("yoo-entity-search-sorts", { fields: this.model.fields, values: this.values ? this.values.sorts : null, onSort: (ev) => this.onSort(ev) }),
                    h("yoo-entity-search-filters", { fields: this.model.fields, values: this.values ? this.values.filters : null, onFilter: (ev) => this.onFilter(ev), onFieldFetchData: ev => this.onFieldFetchData(ev) }),
                    h("div", { class: "spacer" }))),
            h("yoo-form-footer", { buttons: [{ text: translate('APPLY'), cssClass: 'gradient-success', handler: () => this.onApply() }], ref: el => this.footer = el })
        ];
    }
    static get is() { return "yoo-entity-search-dialog"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "host": {
            "elementRef": true
        },
        "isDirty": {
            "state": true
        },
        "model": {
            "type": "Any",
            "attr": "model"
        },
        "values": {
            "type": "Any",
            "attr": "values",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "fieldFetchData",
            "method": "fieldFetchData",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "hideTabbar",
            "method": "onHideTabbar"
        }]; }
    static get style() { return ":host .spacer {\n  height: 5.75rem; }\n\n:host .footer {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  -ms-flex-pack: distribute;\n  justify-content: space-around;\n  padding-top: 1.25rem;\n  padding-bottom: 1.4rem;\n  background-color: var(--light, #FFFFFF);\n  width: 100%;\n  bottom: 0; }"; }
}

class YooEntitySearchFiltersComponent {
    constructor() {
        this.header = 'FILTERBY';
        this.values = [];
        this.filters = [];
    }
    componentWillLoad() {
        this.filters = this.values || [];
    }
    onUpdateValues() {
        this.filters = this.values || [];
        this.host.forceUpdate();
    }
    getFieldFilterName(field) {
        return (field.filterName || field.name);
    }
    onAutocompleteChange(ev, field) {
        ev.stopPropagation();
        this.filters = this.filters.filter(f => f.fieldname !== this.getFieldFilterName(field));
        let values = compact([].concat(ev.detail[field.name]));
        if (values.length > 0) {
            this.filters.push({
                fieldname: this.getFieldFilterName(field),
                values: values,
                type: FormFieldType.autocomplete,
                handleUndefined: field.handleUndefined,
                subQuery: field.subQuery,
                isSubQuery: field.isSubQuery,
                collectionName: field.collectionName
            });
        }
        this.filter.emit(this.filters);
    }
    onSimpleFilter(ev, item, field, type) {
        ev.stopPropagation();
        let filters = this.filters || [];
        let found = false;
        let remove = false;
        let value;
        if (isObject(item) && item._id) {
            value = item._id;
        }
        else {
            value = item;
        }
        for (let filter of filters) {
            if (filter.fieldname === this.getFieldFilterName(field)) {
                found = true;
                let index = filter.values.indexOf(value);
                if (index > -1) {
                    filter.values.splice(index, 1);
                    remove = filter.values.length === 0;
                    break;
                }
                else {
                    filter.values.push(value);
                    break;
                }
            }
        }
        if (!found && !remove) {
            filters.push({ fieldname: this.getFieldFilterName(field), values: [value], type: type, handleUndefined: field.handleUndefined });
        }
        if (found && remove) {
            this.filters = this.filters.filter(f => f.fieldname !== this.getFieldFilterName(field));
        }
        this.filters = [...this.filters];
        this.filter.emit(this.filters);
    }
    onDateChange(ev, field) {
        ev.stopPropagation();
        this.filters = this.filters.filter(f => f.fieldname !== this.getFieldFilterName(field));
        let values = ev.detail;
        if (values && values.length > 0) {
            this.filters.push({ fieldname: this.getFieldFilterName(field), values: values, type: 'date' });
        }
        this.filter.emit(this.filters);
    }
    onNumberChange(ev, field) {
        ev.stopPropagation();
        this.filters = this.filters.filter(f => f.fieldname !== this.getFieldFilterName(field));
        let value = ev.detail;
        if (isObject(value)) {
            this.filters.push({ fieldname: this.getFieldFilterName(field), values: value, type: 'number' });
        }
        this.filter.emit(this.filters);
    }
    onFieldFetchData(ev, newField) {
        ev.stopPropagation();
        if (newField.form) {
            ev.detail.form = newField.form;
        }
        this.fieldFetchData.emit(ev.detail);
    }
    hasFilters() {
        return this.fields && this.fields.some(f => f.filterable && (f.type === FormFieldType.autocomplete || f.type === FormFieldType.date || f.type === FormFieldType.datetime || f.type === FormFieldType.checkbox || f.type === FormFieldType.toggle || f.type === FormFieldType.location || f.type === FormFieldType.catalog));
    }
    getDisplayValue(field, v) {
        if (v === true) {
            return translate('TRUE');
        }
        else if (v === false) {
            return translate('FALSE');
        }
        else if (field.handleUndefined && isNullOrUndefined(v)) {
            return translate('PENDING');
        }
        else if (isObject(v) && v._id && v.title) {
            return translate(v.title);
        }
        else {
            return translate(field.translate && v && v.toUpperCase ? v.toUpperCase() : (v ? v.toString() : ''));
        }
    }
    isChecked(item, field) {
        let value;
        if (isObject(item) && item._id) {
            value = item._id;
        }
        else {
            value = item;
        }
        for (let filter of this.filters) {
            if (filter.fieldname === this.getFieldFilterName(field)) {
                return (filter.values.indexOf(value) > -1);
            }
        }
        return false;
    }
    isFieldWithValues(field) {
        let types = [
            FormFieldType.autocomplete,
            FormFieldType.select,
            FormFieldType.selectbuttons,
            FormFieldType.selectbuttonsmulti,
            FormFieldType.selectchat
        ];
        return types.indexOf(field.type) >= 0 && field.values && field.values.length > 0;
    }
    isFieldWithNumber(field) {
        let types = [
            FormFieldType.starrating,
            FormFieldType.number,
            FormFieldType.numberpicker
        ];
        return types.indexOf(field.type) >= 0;
    }
    renderUl(field) {
        let name = field.name;
        if (field.filterable && this.isFieldWithValues(field)) {
            return h("div", { class: "filter-container" },
                h("div", { class: "menu-title" }, name ? h("div", { class: "title" }, translate(field.title || field.name.toUpperCase())) : null),
                h("ul", { class: "menu" }, field.values.map(v => {
                    return [h("li", { class: "menu-item", onClick: (ev) => this.onSimpleFilter(ev, v, field, 'autocomplete') },
                            h("div", { class: "menu-item-title" },
                                " ",
                                this.getDisplayValue(field, v),
                                " "),
                            h("yoo-form-checkbox", { value: this.isChecked(v, field) })),
                        h("div", { class: "border" })
                    ];
                })));
        }
        else if (field.filterable && (field.type === FormFieldType.checkbox || field.type === FormFieldType.toggle)) {
            return h("div", { class: "filter-container" },
                h("div", { class: "menu-title" }, name ? h("div", { class: "title" }, translate(field.title || field.name.toUpperCase())) : null),
                h("ul", { class: "menu" }, [true, false].map(v => {
                    return [h("li", { class: "menu-item", onClick: (ev) => this.onSimpleFilter(ev, v, field, 'checkbox') },
                            h("div", { class: "menu-item-title" },
                                " ",
                                this.getDisplayValue(field, v),
                                " "),
                            h("yoo-form-checkbox", { value: this.isChecked(v, field) })),
                        h("div", { class: "border" })
                    ];
                })));
        }
        else if (field.filterable && (field.type === FormFieldType.autocomplete && field.collectionName) || (field.type === FormFieldType.location) || (field.type === FormFieldType.catalog)) {
            let newField = Object.assign({}, field, { name: this.getFieldFilterName(field), multiple: true, required: false, clearable: true });
            delete newField.advanced;
            delete newField.secondary;
            delete newField.visible;
            if (newField.title) {
                delete newField.description;
            }
            let slides = [{ title: 'GENERAL', items: [newField] }];
            let filter = this.filters.find(f => f.fieldname === this.getFieldFilterName(field));
            let data = {};
            if (filter) {
                data[this.getFieldFilterName(field)] = filter.values;
            }
            let retVal = [h("yoo-form-dynamic", { class: "inline margin-top", ref: el => newField.form = el, animated: false, showRecap: false, slides: slides, data: data, hideOptional: true, onDataChanged: ev => this.onAutocompleteChange(ev, newField), onFieldFetchData: ev => this.onFieldFetchData(ev, newField) })];
            return retVal;
        }
        else if (field.filterable && (field.type === FormFieldType.date || field.type === FormFieldType.datetime)) {
            let newField = Object.assign({}, field, { name: this.getFieldFilterName(field), required: false, clearable: true });
            let filter = this.filters.find(f => f.fieldname === this.getFieldFilterName(field));
            let value = null;
            if (filter) {
                value = filter.values;
            }
            return h("yoo-form-input-container", { field: newField, hideOptional: true },
                h("yoo-form-date-time", { onInputChanged: ev => this.onDateChange(ev, newField), isRange: true, clearable: true, value: value }));
        }
        else if (field.filterable && this.isFieldWithNumber(field)) {
            let newField = Object.assign({}, field, { name: this.getFieldFilterName(field), required: false, clearable: true });
            let slides = [{
                    title: 'GENERAL', items: [
                        { name: 'min', type: FormFieldType.number, flex: 50 },
                        { name: 'max', type: FormFieldType.number, flex: 50 } //field.type
                    ]
                }];
            let filter = this.filters.find(f => f.fieldname === this.getFieldFilterName(field));
            let data = {};
            if (filter) {
                data = filter.values;
            }
            let retVal = h("yoo-form-input-container", { field: newField, hideOptional: true },
                h("yoo-form-dynamic", { class: "inline flex", animated: false, showRecap: false, slides: slides, data: data, hideOptional: true, onDataChanged: ev => this.onNumberChange(ev, field) }));
            return retVal;
        }
        return null;
    }
    render() {
        return (h("div", { class: "outer-container" },
            this.header && this.hasFilters() ?
                h("div", { class: "heading" }, translate(this.header))
                : null,
            this.fields ?
                this.fields.map(field => {
                    return this.renderUl(field);
                })
                : null));
    }
    static get is() { return "yoo-entity-search-filters"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "fields": {
            "type": "Any",
            "attr": "fields"
        },
        "filters": {
            "state": true
        },
        "header": {
            "type": String,
            "attr": "header"
        },
        "host": {
            "elementRef": true
        },
        "values": {
            "type": "Any",
            "attr": "values",
            "watchCallbacks": ["onUpdateValues"]
        }
    }; }
    static get events() { return [{
            "name": "filter",
            "method": "filter",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "fieldFetchData",
            "method": "fieldFetchData",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host .outer-container {\n  padding: 1rem 1rem 0 1rem; }\n  :host .outer-container .heading {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    height: 1.3125rem;\n    font-size: var(--font-l, 17px);\n    margin-top: 0.625rem;\n    font-weight: 600; }\n  :host .outer-container .menu-title {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    margin-top: 1.2rem;\n    font-size: var(--font-m, 15px); }\n  :host .outer-container .menu {\n    list-style: none outside none;\n    background: none repeat scroll 0 0 transparent;\n    border: 0 none;\n    font-size: 100%;\n    margin: 0;\n    outline: 0 none;\n    padding: 0;\n    vertical-align: baseline;\n    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\n    margin: 0;\n    padding: 0;\n    padding-bottom: 0.3125rem;\n    list-style: none; }\n    :host .outer-container .menu .menu-item {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-pack: justify;\n      justify-content: space-between;\n      height: 100%;\n      min-height: 2.75rem;\n      padding: 0 0.9375rem 0 0;\n      font-weight: 400;\n      -ms-flex-align: center;\n      align-items: center; }\n      :host .outer-container .menu .menu-item div {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: row;\n        flex-direction: row;\n        -ms-flex-item-align: center;\n        align-self: center; }\n        :host .outer-container .menu .menu-item div .menu-item-title {\n          width: 100%;\n          margin-left: 0.625rem; }\n    :host .outer-container .menu .border {\n      width: 100%;\n      height: 0;\n      border-top: 1px solid var(--stable-30, #E6E6E6); }\n  :host .outer-container .heading {\n    margin-bottom: -0.5rem; }\n  :host .outer-container .menu {\n    margin: 0 0.5rem; }\n    :host .outer-container .menu .menu-item {\n      padding: 0;\n      cursor: pointer; }\n      :host .outer-container .menu .menu-item .menu-item-title {\n        width: 100%; }\n      :host .outer-container .menu .menu-item yoo-form-checkbox {\n        padding-right: var(--padding-5, 0.3125rem); }\n  :host .outer-container yoo-form-input-container {\n    margin-top: 1.2rem; }\n  :host .outer-container yoo-form-dynamic.margin-top {\n    margin-top: 1.2rem; }"; }
}

class YooEntitySearchSortsComponent {
    constructor() {
        this.header = 'SORTBY';
        this.values = [];
        this.sorts = [];
    }
    componentWillLoad() {
        this.sorts = this.values || [];
    }
    onUpdateValues() {
        this.sorts = this.values || [];
        this.host.forceUpdate();
    }
    getDir(name) {
        if (this.values) {
            for (let value of this.values) {
                if (name === value.colId) {
                    return value.sort;
                }
            }
        }
        return null;
    }
    getIcon(dir) {
        switch (dir) {
            case 'asc':
                return 'yo-up success';
            case 'desc':
                return 'yo-down success';
        }
        return 'yo-no-data';
    }
    changeDir(dir) {
        switch (dir) {
            case 'asc':
                return 'desc';
            case 'desc':
                return null;
            default:
                return 'asc';
        }
    }
    onSort(field) {
        let sort = this.sorts.find(s => s.colId === field.name);
        if (!sort) {
            sort = { colId: field.name, sort: field.invertedSort ? 'desc' : 'asc' };
            this.sorts.push(sort);
        }
        else {
            sort.sort = this.changeDir(sort.sort);
            if (!sort.sort) {
                this.sorts = this.sorts.filter(s => s.colId !== field.name);
            }
        }
        this.sorts = [...this.sorts];
        this.sort.emit(this.sorts);
    }
    hasSorts() {
        return this.fields && this.fields.some(s => s.sortable);
    }
    renderLi(field) {
        let index = this.sorts.findIndex(s => s.colId === field.name);
        let icon = index > -1 ? this.getIcon(this.sorts[index].sort) : null;
        if (!field.sortable) {
            return null;
        }
        return [h("li", { class: "menu-item", onClick: () => this.onSort(field) },
                h("div", { class: "text" }, translate(field.title || field.name.toUpperCase())),
                index > -1 ? h("yoo-badge", { class: "gradient-success", text: (index + 1).toString() }) : null,
                h("yoo-icon", { class: icon })),
            h("div", { class: "border" })
        ];
    }
    render() {
        return (h("div", { class: "outer-container" },
            this.header && this.hasSorts() ?
                h("div", { class: "heading" }, translate(this.header))
                : null,
            this.fields ?
                h("ul", { class: "menu" }, this.fields.map(field => {
                    return this.renderLi(field);
                }))
                : null));
    }
    static get is() { return "yoo-entity-search-sorts"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "fields": {
            "type": "Any",
            "attr": "fields"
        },
        "header": {
            "type": String,
            "attr": "header"
        },
        "host": {
            "elementRef": true
        },
        "sorts": {
            "state": true
        },
        "values": {
            "type": "Any",
            "attr": "values",
            "watchCallbacks": ["onUpdateValues"]
        }
    }; }
    static get events() { return [{
            "name": "sort",
            "method": "sort",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host .outer-container {\n  padding: 1rem 1rem 0 1rem; }\n  :host .outer-container .heading {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    height: 1.3125rem;\n    font-size: var(--font-l, 17px);\n    margin-top: 0.625rem;\n    font-weight: 600; }\n  :host .outer-container .menu {\n    list-style: none outside none;\n    background: none repeat scroll 0 0 transparent;\n    border: 0 none;\n    font-size: 100%;\n    margin: 0;\n    outline: 0 none;\n    padding: 0;\n    vertical-align: baseline;\n    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\n    margin: 0;\n    padding: 0;\n    padding-bottom: 0.3125rem;\n    list-style: none; }\n    :host .outer-container .menu .menu-item {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-pack: justify;\n      justify-content: space-between;\n      height: 100%;\n      min-height: 2.75rem;\n      padding: 0 0.9375rem 0 0;\n      font-weight: 400;\n      -ms-flex-align: center;\n      align-items: center; }\n      :host .outer-container .menu .menu-item div {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: row;\n        flex-direction: row;\n        -ms-flex-item-align: center;\n        align-self: center; }\n        :host .outer-container .menu .menu-item div .menu-item-title {\n          width: 100%;\n          margin-left: 0.625rem; }\n    :host .outer-container .menu .border {\n      width: 100%;\n      height: 0;\n      border-top: 1px solid var(--stable-30, #E6E6E6); }\n  :host .outer-container .menu .menu-item {\n    cursor: pointer; }\n    :host .outer-container .menu .menu-item .text {\n      -ms-flex: 1;\n      flex: 1; }\n    :host .outer-container .menu .menu-item yoo-badge {\n      margin: 0 0.5rem; }\n    :host .outer-container .menu .menu-item .yo-no-data {\n      color: var(--stable-alt, #d0d0d0); }"; }
}

class YooEntitySearchTagsComponent {
    constructor() {
        this.values = [];
        this.selects = [];
        this.slidesOptions = {
            spaceBetween: 10,
            freeMode: true
        };
    }
    componentWillLoad() {
        this.selects = this.values;
    }
    isSelected(item) {
        for (let select of this.selects) {
            if (item.tag === select.tag) {
                return true;
            }
        }
        return false;
    }
    updateSelects(item) {
        let selects = this.selects;
        let index = selects.findIndex(s => s._id === item._id);
        if (index > -1) {
            selects.splice(index, 1);
            return selects;
        }
        else {
            selects.push(item);
            return selects;
        }
    }
    onSelect(ev, item) {
        ev.stopPropagation();
        this.selects = [...this.updateSelects(item)];
        this.select.emit(this.selects);
    }
    onFilterAdvanced() {
        this.filterAdvanced.emit(true);
    }
    renderLi(item) {
        return (h("div", { class: 'menu-item ' + (this.isSelected(item) ? 'selected' : ''), onClick: (ev) => this.onSelect(ev, item) }, item.tag));
    }
    hostData() {
        return {
            class: Object.assign({ 'swiper-no-swiping': true }, getAppContext())
        };
    }
    render() {
        let filterCount = 0;
        if (this.sortsAndFilters && this.sortsAndFilters.filters) {
            filterCount += this.sortsAndFilters.filters.length;
        }
        if (this.sortsAndFilters && this.sortsAndFilters.sorts) {
            filterCount += this.sortsAndFilters.sorts.length;
        }
        return (h("div", { class: 'outer-container ' + (this.tags ? '' : 'margin') + (this.hideAdvancedFilters ? '' : (filterCount > 0 ? ' advanced-filters-count' : ' advanced-filters')) }, this.tags ?
            [!this.hideAdvancedFilters ?
                    h("yoo-button", { onClick: () => this.onFilterAdvanced(), icon: "yo-filter", text: filterCount > 0 ? filterCount.toString() : null, class: 'fab no-shadow' + (filterCount > 0 ? ' reverse-order' : ' icon-only') }) : h("div", { class: "button-spacer" }),
                h("yoo-ion-scroll", { class: "horizontal" },
                    h("div", { class: "button-spacer" }),
                    this.tags.filter(value => value && value.tag && isString(value.tag)).map(value => {
                        return (this.renderLi(value));
                    }),
                    h("div", { class: "button-spacer" }))]
            : h("div", { class: "placeholder" })));
    }
    static get is() { return "yoo-entity-search-tags"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "hideAdvancedFilters": {
            "type": Boolean,
            "attr": "hide-advanced-filters"
        },
        "host": {
            "elementRef": true
        },
        "selects": {
            "state": true
        },
        "slidesOptions": {
            "state": true
        },
        "sortsAndFilters": {
            "type": "Any",
            "attr": "sorts-and-filters"
        },
        "tags": {
            "type": "Any",
            "attr": "tags"
        },
        "values": {
            "type": "Any",
            "attr": "values"
        }
    }; }
    static get events() { return [{
            "name": "select",
            "method": "select",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "filterAdvanced",
            "method": "filterAdvanced",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  --entity-search-shadow: none; }\n\n\@-webkit-keyframes slideInRight {\n  0% {\n    margin-left: 100px;\n    opacity: 0; }\n  100% {\n    margin-left: 10px;\n    opacity: 1; } }\n\n\@keyframes slideInRight {\n  0% {\n    margin-left: 100px;\n    opacity: 0; }\n  100% {\n    margin-left: 10px;\n    opacity: 1; } }\n\n\@-webkit-keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n\@keyframes fadeIn {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n  :host .outer-container {\n    display: -ms-flexbox;\n    display: flex;\n    position: relative;\n    width: 100% !important;\n    height: 1.825rem;\n    padding-bottom: 0.2rem; }\n    :host .outer-container .menu-item:nth-of-type(1) {\n      -webkit-animation-delay: 0.08333s;\n      animation-delay: 0.08333s; }\n    :host .outer-container .menu-item:nth-of-type(2) {\n      -webkit-animation-delay: 0.16667s;\n      animation-delay: 0.16667s; }\n    :host .outer-container .menu-item:nth-of-type(3) {\n      -webkit-animation-delay: 0.25s;\n      animation-delay: 0.25s; }\n    :host .outer-container .menu-item:nth-of-type(4) {\n      -webkit-animation-delay: 0.33333s;\n      animation-delay: 0.33333s; }\n    :host .outer-container .menu-item:nth-of-type(5) {\n      -webkit-animation-delay: 0.41667s;\n      animation-delay: 0.41667s; }\n    :host .outer-container .menu-item:nth-of-type(6) {\n      -webkit-animation-delay: 0.5s;\n      animation-delay: 0.5s; }\n    :host .outer-container .menu-item:nth-of-type(7) {\n      -webkit-animation-delay: 0.58333s;\n      animation-delay: 0.58333s; }\n    :host .outer-container .menu-item:nth-of-type(8) {\n      -webkit-animation-delay: 0.66667s;\n      animation-delay: 0.66667s; }\n    :host .outer-container .menu-item:nth-of-type(9) {\n      -webkit-animation-delay: 0.75s;\n      animation-delay: 0.75s; }\n    :host .outer-container .menu-item:nth-of-type(10) {\n      -webkit-animation-delay: 0.83333s;\n      animation-delay: 0.83333s; }\n    :host .outer-container yoo-ion-scroll {\n      min-height: 2rem; }\n    :host .outer-container yoo-button {\n      --border-radius-container: var(--button-border-radius-18, 1.125rem);\n      --height-icon-only-container: 1.875rem;\n      --height-container: 1.875rem;\n      --border-container: 1px solid var(--always-stable-light, #f1f1f1);\n      --color-value: var(--black, #000000);\n      --font-size-icon: 1.25rem;\n      --font-size-text: var(--font-m, 15px);\n      --shadow: var(--entity-search-shadow) !important;\n      --padding-text-span: 0 var(--padding-10, 0.625rem) 1px 3px;\n      padding: 0 var(--padding-10, 0.625rem) 0 var(--padding-15, 0.9375rem);\n      z-index: 1;\n      -webkit-animation-name: fadeIn;\n      animation-name: fadeIn;\n      -webkit-animation-fill-mode: both;\n      animation-fill-mode: both;\n      -webkit-animation-duration: .3s;\n      animation-duration: .3s; }\n    :host .outer-container.advanced-filters yoo-ion-scroll {\n      --left-pos: 55px; }\n    :host .outer-container.advanced-filters-count yoo-ion-scroll {\n      --left-pos: 80px; }\n    :host .outer-container .menu-item {\n      -webkit-animation-name: slideInRight;\n      animation-name: slideInRight;\n      -webkit-animation-fill-mode: both;\n      animation-fill-mode: both;\n      -webkit-animation-duration: .5s;\n      animation-duration: .5s;\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: center;\n      align-items: center;\n      height: 1.875rem;\n      margin-left: var(--padding-10, 0.625rem);\n      padding: 0 var(--padding-10, 0.625rem) 0 var(--padding-10, 0.625rem);\n      border: solid 1px var(--stable-light-to-white, #f1f1f1);\n      border-radius: 0.9375rem;\n      background: var(--light, #FFFFFF);\n      color: var(--black, #000000);\n      font-size: 0.9375rem;\n      white-space: nowrap;\n      -webkit-box-shadow: var(--entity-search-shadow);\n      box-shadow: var(--entity-search-shadow);\n      cursor: pointer; }\n      :host .outer-container .menu-item.selected {\n        border: solid 1px var(--light, #FFFFFF);\n        background: var(--gradient-success, #04CC99);\n        color: var(--light, #FFFFFF); }\n    :host .outer-container .spacer {\n      width: 0.625rem;\n      height: 0;\n      visibility: hidden; }\n    :host .outer-container.margin {\n      margin: 0 1rem; }\n    :host .outer-container .placeholder {\n      width: 100%;\n      min-height: 30px;\n      background: var(--stable-light, #f1f1f1); }\n\n:host(.boost) .outer-container .menu-item.selected {\n  background: var(--danger-light, #F46885); }"; }
}

class YooFormBarcodeDialogComponent {
    constructor() {
        this.mainMode = 'default';
        this.ocrRegexes = [{
                _id: 'regex0',
                title: 'dd-mm-yyyy',
                parsingPattern: 'dd-MM-yyyy',
                regex: '(([0-2][0-9])|(3[0-1]))-((0[1-9])|(1[0-2]))-[0-9]{4}'
            },
            {
                _id: 'regex1',
                title: 'dd.mm.yy',
                parsingPattern: 'dd.MM.yy',
                regex: '(([0-2][0-9])|(3[0-1]))([.])((0[1-9])|(1[0-2]))([.])[0-9]{2}'
            }, {
                _id: 'regex2',
                title: 'dd.mm.yyyy',
                parsingPattern: 'dd.MM.yyyy',
                regex: '(([0-2][0-9])|(3[0-1]))([.])((0[1-9])|(1[0-2]))([.])[0-9]{4}'
            }, {
                _id: 'regex3',
                title: 'dd/mm/yy',
                parsingPattern: 'dd/MM/yy',
                regex: '(([0-2][0-9])|(3[0-1]))([/])((0[1-9])|(1[0-2]))([/])[0-9]{2}'
            }, {
                _id: 'regex4',
                title: 'dd/mm',
                parsingPattern: 'dd/MM',
                regex: '(([0-2][0-9])|(3[0-1]))([/])((0[1-9])|(1[0-2]))'
            }, {
                _id: 'regex5',
                title: 'dd.mm',
                parsingPattern: 'dd.MM',
                regex: '(([0-2][0-9])|(3[0-1]))([.])((0[1-9])|(1[0-2]))'
            }, {
                _id: 'regex6',
                title: 'mmm yy',
                parsingPattern: 'MMM yy',
                regex: '([A-Z]{3} [0-2][0-9])'
            }, {
                _id: 'regex7',
                title: 'yyyy',
                parsingPattern: 'yyyy',
                regex: '[0-9]{4}'
            }];
        this.supportMode = [];
    }
    close() {
        this.onCancel();
    }
    restartOcrScanner() {
        if (this.scandit) {
            this.scandit.restartOcrScanner();
        }
    }
    componentWillLoad() {
        this.onInitMainMode();
    }
    componentDidLoad() {
        this.textManualInput = this.value;
        if (isCordova() && isIOS$1() && this.enableKeyboardResizing) {
            enableKeyboardResize(Keyboard);
        }
    }
    onCancel() {
        if (this.scandit) {
            this.scandit.cleanUpScandit();
        }
        closeModal(null);
    }
    onInitMainMode() {
        this.supportMode = [];
        if (this.mainMode === 'default' || this.mainMode === 'batch') {
            this.supportMode.push(this.onCreateModeObj('default', 'yo-camera', 'CAMERA'));
        }
        if (this.mainMode === 'ocr') {
            this.supportMode.push(this.onCreateModeObj('ocr', 'yo-camera', 'OCR'));
            this.selectedOcrRegex = this.ocrRegexes[0];
        }
        this.supportMode.push(this.onCreateModeObj('keyboard', 'yo-keyboard', 'KEYBOARD'));
        this.inputMode = this.supportMode[0].mode;
    }
    onCreateModeObj(mode, icon, text) {
        return { mode, icon, text };
    }
    isMode(compareMode) {
        return this.inputMode === compareMode;
    }
    onSelectMode(mode, initialSelect = false) {
        if (this.inputMode !== mode || initialSelect) {
            this.inputMode = mode;
        }
    }
    onInputChanged(ev) {
        this.textManualInput = ev.detail;
    }
    onScannedSuccess(ev) {
        if (ev && ev.stopPropagation) {
            ev.stopPropagation();
        }
        let data = ev.detail ? ev.detail : ev;
        if (this.mainMode !== 'batch') {
            if (this.mainMode === 'ocr' && this.hasRegexPattern(this.selectedOcrRegex)) {
                try {
                    let pattern = this.selectedOcrRegex.parsingPattern;
                    data = dateParse(ev.detail, pattern, new Date()).toISOString();
                }
                catch (_a) {
                    data = new Date().toISOString();
                }
            }
        }
        this.scannedSuccess.emit(data);
        if (this.scandit) {
            this.scandit.cleanUpScandit();
        }
    }
    onRegexInputFocued() {
        if (this.scandit) {
            this.scandit.cleanUpScandit();
        }
    }
    hasRegexPattern(regex) {
        return regex && regex.parsingPattern;
    }
    onChangeOcrRegex(regex) {
        this.selectedOcrRegex = regex;
    }
    onSave() {
        this.scannedSuccess.emit(this.textManualInput);
        if (this.mainMode !== 'batch') {
            closeModal(this.textManualInput);
        }
    }
    renderHeaderTitle() {
        return [
            h("div", { class: "title-container" },
                h("yoo-ion-button", { class: "close", onClick: () => this.onCancel() },
                    h("yoo-icon", { slot: "icon-only", class: "yo-close" })),
                h("yoo-ion-title", null, translate('SCAN')))
        ];
    }
    renderHeaderTab() {
        return [
            h("div", { class: "tab-container" }, this.supportMode.map(tab => {
                return [
                    h("div", { class: {
                            'tab-item': true,
                            'active': this.isMode(tab.mode)
                        }, onClick: () => { this.onSelectMode(tab.mode); } },
                        h("yoo-icon", { class: tab.icon }),
                        h("div", { class: "icon-text" }, translate(tab.text)))
                ];
            }))
        ];
    }
    renderTags() {
        if (this.mainMode === 'ocr') {
            return h("div", { class: "tags" },
                h("yoo-ion-scroll", { class: "horizontal" }, this.ocrRegexes ? this.ocrRegexes.map(ocrRegex => {
                    return [h("yoo-badge", { onClick: ev => this.onChangeOcrRegex(ocrRegex), class: { 'small round': true, 'success': this.selectedOcrRegex === ocrRegex, 'stable': this.selectedOcrRegex !== ocrRegex }, text: ocrRegex.title }),
                        h("div", { class: "button-spacer" })
                    ];
                }) : null));
        }
    }
    renderRegexSelector() {
        return [
            h("div", { class: "regex-container" },
                h("yoo-form-autocomplete", { placeholder: translate('SELECTDATEFORMAT'), values: this.ocrRegexes, value: this.selectedOcrRegex, iconPrefix: "yo-barcode", entityType: 'regex', displayType: 'card-list', onInputChanged: (ev) => this.onChangeOcrRegex(ev.detail), onInputFocused: () => this.onRegexInputFocued(), class: "ocr-data-input" }))
        ];
    }
    renderHeader() {
        return [
            h("div", { class: {
                    'header-container': true,
                    'ocr-mode': this.mainMode === 'ocr'
                } },
                this.renderHeaderTitle(),
                this.renderHeaderTab(),
                this.mainMode === 'ocr' && this.inputMode !== 'keyboard' && this.renderRegexSelector())
        ];
    }
    renderKeyboardContent() {
        return [
            h("yoo-ion-content", { scrollEnabled: false, class: {
                    'input-container bg-light': true
                } },
                h("div", { class: "input-inner-container" },
                    h("div", { class: "content-code" }, !this.textManualInput ? h("yoo-img", { src: "./assets/empty-states/barcodelong.svg" }) : h("yoo-barcode", { value: this.textManualInput })),
                    h("div", { class: "content-numbers" },
                        h("yoo-form-input", { onInputChanged: (ev) => this.onInputChanged(ev), value: this.textManualInput }))),
                h("div", { class: "bottom-toolbar" },
                    h("div", { class: "action", onClick: () => { this.onSave(); } }, translate('DONE'))))
        ];
    }
    renderScannerContent() {
        return [
            h("div", { class: {
                    'scanner-container': true
                } }, (this.isMode('default') || this.isMode('ocr')) &&
                h("yoo-scandit", { ref: el => this.scandit = el, currentOcrRegex: this.selectedOcrRegex, scanMode: this.mainMode, onScannedSuccess: (ev) => this.onScannedSuccess(ev) }))
        ];
    }
    renderBody() {
        return [
            this.renderScannerContent(),
            this.isMode('keyboard') && this.renderKeyboardContent()
        ];
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext(true))
        };
    }
    render() {
        return [
            this.renderHeader(),
            this.renderBody()
        ];
    }
    static get is() { return "yoo-form-barcode-dialog"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "close": {
            "method": true
        },
        "enableKeyboardResizing": {
            "type": Boolean,
            "attr": "enable-keyboard-resizing"
        },
        "fnBarcodeResult": {
            "type": "Any",
            "attr": "fn-barcode-result",
            "mutable": true
        },
        "fnOcrResult": {
            "type": "Any",
            "attr": "fn-ocr-result",
            "mutable": true
        },
        "host": {
            "elementRef": true
        },
        "inputMode": {
            "state": true
        },
        "mainMode": {
            "type": String,
            "attr": "main-mode",
            "mutable": true
        },
        "ocrRegexes": {
            "type": "Any",
            "attr": "ocr-regexes"
        },
        "restartOcrScanner": {
            "method": true
        },
        "selectedOcrRegex": {
            "state": true
        },
        "textManualInput": {
            "state": true
        },
        "value": {
            "type": String,
            "attr": "value",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "scannedSuccess",
            "method": "scannedSuccess",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  background: var(--light, #FFFFFF); }\n  :host .header-container {\n    height: 130px;\n    background: var(--light, #FFFFFF);\n    z-index: 999; }\n    :host .header-container.ocr-mode {\n      height: 155px; }\n      :host .header-container.ocr-mode .regex-container {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-pack: center;\n        justify-content: center;\n        padding: var(--padding-15, 0.9375rem);\n        background: white; }\n        :host .header-container.ocr-mode .regex-container yoo-form-autocomplete {\n          width: 100%; }\n    :host .header-container .regex-container {\n      display: none;\n      overflow: hidden; }\n    :host .header-container .title-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: center;\n      align-items: center;\n      height: 40px; }\n      :host .header-container .title-container yoo-ion-button {\n        position: absolute;\n        z-index: 1; }\n      :host .header-container .title-container yoo-ion-button.list {\n        position: relative;\n        right: 0; }\n        :host .header-container .title-container yoo-ion-button.list yoo-icon.yo-list-view yoo-badge {\n          position: absolute;\n          top: 2px;\n          right: 5px;\n          border-radius: 50%; }\n    :host .header-container .tab-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex: 1;\n      flex: 1;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: distribute;\n      justify-content: space-around;\n      height: 60px;\n      padding-top: var(--padding-10, 0.625rem);\n      padding-bottom: var(--padding-10, 0.625rem); }\n      :host .header-container .tab-container .tab-item {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: column;\n        flex-direction: column;\n        -ms-flex-align: center;\n        align-items: center;\n        -webkit-transition: opacity .3s ease;\n        transition: opacity .3s ease;\n        opacity: 0.4; }\n        :host .header-container .tab-container .tab-item .icon-text {\n          padding-top: var(--padding-5, 0.3125rem);\n          font-size: var(--font-s, 13px); }\n        :host .header-container .tab-container .tab-item.active {\n          -webkit-transition: opacity .3s ease;\n          transition: opacity .3s ease;\n          opacity: 1; }\n        :host .header-container .tab-container .tab-item yoo-icon {\n          color: var(--black, #000000);\n          font-size: var(--font-lx, 27px); }\n  :host .scanner-container {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0; }\n    :host .scanner-container .test-div {\n      width: 100%;\n      height: 200px;\n      background: grey; }\n  :host .input-container {\n    display: -ms-flexbox;\n    display: flex;\n    position: relative;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    -ms-flex-align: center;\n    align-items: center;\n    height: 100%; }\n    :host .input-container .input-inner-container {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-direction: column;\n      flex-direction: column;\n      -ms-flex-align: center;\n      align-items: center;\n      height: 100%; }\n      :host .input-container .input-inner-container .content-code {\n        margin-top: var(--padding-20, 1.25rem);\n        color: var(--black, #000000);\n        font-size: 100px; }\n        :host .input-container .input-inner-container .content-code yoo-img, :host .input-container .input-inner-container .content-code yoo-barcode {\n          width: 180px;\n          height: 60px;\n          margin-bottom: 1rem; }\n      :host .input-container .input-inner-container .content-numbers {\n        width: 180px; }\n    :host .input-container .bottom-toolbar {\n      display: -ms-flexbox;\n      display: flex;\n      position: absolute;\n      bottom: 0px;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: end;\n      justify-content: flex-end;\n      width: 100%;\n      height: 44px;\n      background-color: #fafaf8;\n      -webkit-box-shadow: inset 0 0.5px 0 0 #e1e0e0;\n      box-shadow: inset 0 0.5px 0 0 #e1e0e0;\n      z-index: 40000; }\n      :host .input-container .bottom-toolbar .action {\n        padding-right: 15px;\n        color: var(--success, #04CC99);\n        font-size: var(--font-l, 17px); }\n\n:host(.ios) .header-container {\n  padding-top: var(--padding-15, 0.9375rem); }\n\n:host(.iphone-x) .header-container {\n  padding-top: 35px; }\n\n:host(.iphone-x) .input-container .bottom-toolbar {\n  padding-bottom: 20px; }\n\n:host(.hide) {\n  display: none;\n  overflow: hidden; }"; }
}

class YooFormCreatorComponent {
    constructor() {
        this.showLivePreview = true;
        this.selectedLeftSelection = FormCreatorLeftMenuOptions.blocks;
        this.selectedPageIndex = 0;
        this.slides = [];
        this.simpleFormBlocks = { information: [] };
    }
    setSelectedPage(index) {
        this.selectedPageIndex = index;
    }
    componentWillLoad() {
        this.slides = this.missionDescription.slides;
        this.deviceList = DEVICE_LIST.map((device) => {
            const item = {
                text: device.displayTitle,
                handler: () => this.onSelectedDeviceClicked(device)
            };
            return item;
        });
        this.selectedDevice = DEVICE_LIST[0];
        this.setSelectedDeviceColors();
        this.setSimpleFormBlockArrays();
    }
    componentDidLoad() {
    }
    componentWillUpdate() {
        this.setSelectedDeviceColors();
    }
    componentDidUpdate() {
        if (this.slides && this.slides.length > 0 && this.selectedDevice) {
            this.selectedDeviceChanged.emit({ loaded: true });
        }
    }
    isSelectedLeftMenu(leftMenu) {
        return leftMenu === this.selectedLeftSelection;
    }
    setSimpleFormBlockArrays() {
        FORM_FIELD_CATEGORIES.forEach(category => {
            this.simpleFormBlocks[category] = [];
        });
        const formFields = [...MOBILE_FORM_FIELDS, ...MOBILE_FORM_FIELDS_ADVANCED];
        formFields.forEach((field) => {
            this.simpleFormBlocks[field.category].push(field);
        });
    }
    setSelectedDeviceColors() {
        if (this.selectedDevice.colors) {
            this.selectedDeviceColors = this.selectedDevice.colors.map(color => color.hexCode);
        }
    }
    onLeftMenuIconSelected(leftMenuIcon) {
        this.selectedLeftSelection = leftMenuIcon;
    }
    onSelectedDeviceClicked(device) {
        this.selectedDeviceChanged.emit({ loaded: false });
        this.selectedDevice = device;
    }
    onHelpClicked() { }
    onSaveCloseClicked(ev) {
        ev.stopPropagation();
        this.saveCloseClicked.emit();
    }
    onToggleLivePreviewClicked() {
        const TRANSITION_DURATION = 300;
        this.livePreview.classList.toggle('hide');
        setTimeout(() => {
            this.showLivePreview = !this.showLivePreview;
        }, TRANSITION_DURATION);
    }
    onColorChanged(event) {
        const selectedColorHex = event.detail;
        const [selectedColor] = this.selectedDevice.colors.filter((color) => color.hexCode === selectedColorHex);
        this.selectedDevice.selectedColor = selectedColor;
        this.selectedDevice = Object.assign({}, this.selectedDevice);
    }
    onAddNewPage() {
    }
    onPageClicked(event) {
        this.selectedPageIndex = event.detail;
        this.pageHeaderClicked.emit(event.detail);
    }
    renderHeader() {
        return (h("yoo-form-creator-header", { formTitle: this.missionDescription.title, isLivePreviewVisible: this.showLivePreview, onHelpClicked: () => this.onHelpClicked(), onSaveCloseClicked: (ev) => this.onSaveCloseClicked(ev), onToggleLivePreviewClicked: () => this.onToggleLivePreviewClicked() }));
    }
    renderContent() {
        return (h("div", { class: "content" },
            this.renderLeftMenu(),
            this.renderLeftSelection(),
            this.renderFormContent(),
            this.renderLivePreview()));
    }
    renderLeftMenu() {
        return (h("div", { class: "left-menu" },
            this.renderIcon(FormCreatorLeftMenuOptions.blocks),
            this.renderIcon(FormCreatorLeftMenuOptions.logic),
            this.renderIcon(FormCreatorLeftMenuOptions.scoring),
            this.renderIcon(FormCreatorLeftMenuOptions.translate)));
    }
    renderIcon(leftMenuOption) {
        const icon = leftMenuOption === FormCreatorLeftMenuOptions.blocks ? 'categories' : leftMenuOption;
        return (h("yoo-icon", { onClick: () => this.onLeftMenuIconSelected(leftMenuOption), class: {
                [`yo-${icon}`]: true,
                [this.isSelectedLeftMenu(leftMenuOption) ? 'success' : 'stable']: true
            } }));
    }
    renderLeftSelection() {
        return (h("div", { class: "left-selection" },
            h("yoo-ion-scroll", { class: "relative" }, this.renderLeftSelectionContent())));
    }
    renderLeftSelectionContent() {
        switch (this.selectedLeftSelection) {
            case 'blocks':
                return this.renderBlockCategorySelection();
            case 'logic':
                return this.renderLogicSelection();
            case 'scoring':
                return this.renderScoringSelection();
            case 'translate':
                return this.renderTranslateSelection();
        }
    }
    renderBlockCategorySelection() {
        const entries = FORM_FIELD_CATEGORIES.map((category) => {
            return { title: category.toUpperCase(), selected: true, subItemCount: this.simpleFormBlocks[category].length };
        });
        return (h("yoo-accordion", { masterTitle: this.selectedLeftSelection.toUpperCase(), class: "sub-accordion", entries: entries, iconPairLeft: ARROW_PAIR, showBottomBorder: true, allowMultipleSelection: true }, FORM_FIELD_CATEGORIES.map(category => h("div", { slot: category.toUpperCase() },
            h("div", { class: "category-block-selection" }, this.simpleFormBlocks[category].map(field => this.renderSimpleBlock(field, category)))))));
    }
    renderLogicSelection() {
        const entries = [{ title: 'CONDITION', selected: true }, { title: 'ACTION', selected: true }];
        const formField = { title: 'PLACEHOLDER', icon: 'yo-info', category: FormFieldCategory.information };
        return (h("yoo-accordion", { class: "sub-accordion", entries: entries, iconPairLeft: ARROW_PAIR, showBottomBorder: true, allowMultipleSelection: true },
            h("div", { slot: "CONDITION" },
                h("yoo-form-creator-block-simple", { formField: formField })),
            h("div", { slot: "ACTION" },
                h("yoo-form-creator-block-simple", { formField: formField }))));
    }
    renderScoringSelection() {
        const entries = [
            { title: 'COMPLIANCESCORING', selected: true },
            { title: 'SECONDARYSCORING', selected: true },
            { title: 'BLOCKSCORING', selected: true }
        ];
        const formField = { title: 'PLACEHOLDER', icon: 'yo-info', category: FormFieldCategory.information };
        return (h("yoo-accordion", { class: "sub-accordion", entries: entries, iconPairLeft: ARROW_PAIR, showBottomBorder: true, allowMultipleSelection: true },
            h("div", { slot: "COMPLIANCESCORING" },
                h("yoo-form-creator-block-simple", { formField: formField })),
            h("div", { slot: "SECONDARYSCORING" },
                h("yoo-form-creator-block-simple", { formField: formField })),
            h("div", { slot: "BLOCKSCORING" },
                h("yoo-form-creator-block-simple", { formField: formField }))));
    }
    renderTranslateSelection() {
        const entries = [{ title: 'TRANSLATE', selected: true }];
        const formField = { title: 'PLACEHOLDER', icon: 'yo-info', category: FormFieldCategory.information };
        return (h("yoo-accordion", { class: "sub-accordion", entries: entries, iconPairLeft: ARROW_PAIR, showBottomBorder: true, allowMultipleSelection: true },
            h("div", { slot: "TRANSLATE" },
                h("yoo-form-creator-block-simple", { formField: formField }))));
    }
    renderSimpleBlock(field, category) {
        if (field.category === category) {
            const formField = { title: field.title, icon: field.icon, category: field.category };
            return (h("yoo-form-creator-block-simple", { formField: formField }));
        }
    }
    renderFormContent() {
        const newPageButton = { text: translate('NEWPAGE'), cssClass: 'small new-page', handler: () => this.onAddNewPage() };
        return (h("div", { class: "form-content" },
            h("yoo-accordion", { class: "pages-accordion", entries: [{ title: 'PAGES', subItemCount: this.slides.length, selected: true, actionButton: newPageButton }, { title: 'CONTENT', selected: true }], iconPairLeft: ARROW_PAIR, showBottomBorder: true, allowMultipleSelection: true },
                h("div", { slot: "PAGES" },
                    h("yoo-from-creator-page-card-list", { missionSlides: this.slides, onPageClicked: (event) => this.onPageClicked(event), selectedPageIndex: this.selectedPageIndex })),
                h("div", { slot: "CONTENT" }, this.renderFormContentBlocks()))));
    }
    renderFormContentBlocks() {
        const formField = { title: 'PLACEHOLDER', icon: 'yo-info', category: FormFieldCategory.information };
        return (h("yoo-form-creator-block-expandable", { formField: formField }));
    }
    renderLivePreview() {
        const selectedDevice = this.selectedDevice && this.selectedDevice.device ? this.selectedDevice.device : '';
        return (h("div", { ref: (el) => this.livePreview = el, class: { 'live-preview': true } },
            this.renderLivePreviewHeader(),
            h("yoo-ion-scroll", { class: "relative" },
                h("div", { class: { 'device-container': true, [selectedDevice]: true } }, this.showLivePreview && [
                    this.selectedDevice.colors &&
                        h("yoo-color-selector", { colors: this.selectedDeviceColors, showTickIcon: false, onColorChanged: (event) => this.onColorChanged(event) }),
                    h("yoo-device", { deviceEntry: this.selectedDevice }, this.renderFormDynamic())
                ]))));
    }
    renderLivePreviewHeader() {
        return (h("div", { class: "live-preview-header" },
            h("div", { class: "title" }, translate('LIVEPREVIEW')),
            h("yoo-context-menu", { contentButtons: this.deviceList, contentPosition: { top: '3.125rem', right: '2rem', bottom: 'auto', left: 'auto' }, onClick: (ev) => ev.stopPropagation() },
                h("div", { class: "icon-container" },
                    h("yoo-icon", { class: "yo-more stable" })))));
    }
    renderFormDynamic() {
        return (h("div", { class: "form-dynamic-slot-container" },
            h("slot", { name: "livePreview" })));
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return (h("div", { class: "container" },
            this.renderHeader(),
            this.renderContent()));
    }
    static get is() { return "yoo-form-creator"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "host": {
            "elementRef": true
        },
        "missionDescription": {
            "type": "Any",
            "attr": "mission-description"
        },
        "selectedDevice": {
            "state": true
        },
        "selectedLeftSelection": {
            "state": true
        },
        "selectedPageIndex": {
            "state": true
        },
        "setSelectedPage": {
            "method": true
        },
        "showLivePreview": {
            "state": true
        }
    }; }
    static get events() { return [{
            "name": "saveCloseClicked",
            "method": "saveCloseClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "pageHeaderClicked",
            "method": "pageHeaderClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "selectedDeviceChanged",
            "method": "selectedDeviceChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  width: 100%;\n  height: 100%;\n  background: var(--light, #FFFFFF); }\n  :host .container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: column;\n    flex-direction: column;\n    height: 100%; }\n    :host .container .content {\n      display: -ms-flexbox;\n      display: flex;\n      height: calc(100% - 3rem); }\n      :host .container .content .left-menu {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: column;\n        flex-direction: column;\n        -ms-flex-align: center;\n        align-items: center;\n        min-width: 3rem;\n        border-right: 1px solid var(--stable-light, #f1f1f1);\n        font-size: 1.125rem; }\n        :host .container .content .left-menu yoo-icon {\n          margin-top: var(--padding-20, 1.25rem); }\n      :host .container .content .left-selection {\n        min-width: 22rem;\n        height: 100%;\n        padding-top: var(--padding-20, 1.25rem);\n        border-right: 1px solid var(--stable-light, #f1f1f1); }\n        :host .container .content .left-selection yoo-accordion {\n          --outer-container-padding: 0 var(--padding-20, 1.25rem);\n          --outer-container-width: calc(100% - 2.5rem); }\n          :host .container .content .left-selection yoo-accordion yoo-accordion.sub-accordion {\n            --outer-container-padding: 0;\n            --outer-container-width: 100%; }\n      :host .container .content .form-content {\n        width: 100%;\n        padding: var(--padding-20, 1.25rem);\n        background-color: #fafafa; }\n        :host .container .content .form-content yoo-accordion.pages-accordion {\n          --accordion-background: var(--stable-background, #fafafa)\n                ; }\n      :host .container .content .live-preview {\n        display: -ms-flexbox;\n        display: flex;\n        position: relative;\n        -ms-flex-direction: column;\n        flex-direction: column;\n        min-width: 30rem;\n        padding: var(--padding-20, 1.25rem);\n        -webkit-transition: 0.3s;\n        transition: 0.3s;\n        border-left: 1px solid var(--stable-light, #f1f1f1); }\n        :host .container .content .live-preview.hide {\n          width: 0;\n          min-width: 0;\n          padding: 0; }\n          :host .container .content .live-preview.hide .live-preview-header {\n            width: 0;\n            opacity: 0; }\n          :host .container .content .live-preview.hide .device-container {\n            opacity: 0; }\n        :host .container .content .live-preview .live-preview-header {\n          display: -ms-flexbox;\n          display: flex;\n          -ms-flex-align: center;\n          align-items: center;\n          -ms-flex-item-align: end;\n          align-self: flex-end;\n          -ms-flex-pack: justify;\n          justify-content: space-between;\n          width: 100%;\n          padding-bottom: 0.5625rem;\n          -webkit-transition: 0.5s;\n          transition: 0.5s;\n          border-bottom: 1px solid var(--stable-light, #f1f1f1);\n          font-size: 1.125rem;\n          white-space: nowrap; }\n          :host .container .content .live-preview .live-preview-header .icon-container {\n            display: -ms-flexbox;\n            display: flex;\n            -ms-flex-align: center;\n            align-items: center;\n            -ms-flex-pack: center;\n            justify-content: center;\n            width: 2rem;\n            height: 1.625rem; }\n        :host .container .content .live-preview .device-container {\n          display: -ms-flexbox;\n          display: flex;\n          -ms-flex-direction: column;\n          flex-direction: column;\n          -ms-flex-align: center;\n          align-items: center;\n          -ms-flex-pack: center;\n          justify-content: center;\n          width: 100%;\n          height: 100%; }\n          :host .container .content .live-preview .device-container.iphone-x .form-dynamic-slot-container {\n            top: 2rem;\n            right: 0;\n            bottom: 1rem;\n            left: 0;\n            position: absolute; }"; }
}

class YooFormCreatorBlockExpandableComponent {
    constructor() {
        this.isExpanded = false;
    }
    onHeaderIconClicked(icon) {
        switch (icon) {
            case 'yo-down':
                this.isExpanded = true;
                break;
            case 'yo-up':
                this.isExpanded = false;
                break;
        }
    }
    renderHeader() {
        return (h("div", { class: "header" },
            h("div", { class: 'form-icon ' + this.formField.category },
                h("yoo-icon", { class: this.formField.icon + ' always-light' })),
            h("div", { class: "title" }, translate(this.formField.title)),
            h("div", { class: "icons-container" },
                this.renderIcon('yo-logic'),
                this.renderIcon('yo-scoring'),
                this.renderIcon('yo-translate'),
                this.renderIcon('yo-more'),
                this.renderIcon(this.isExpanded ? 'yo-up' : 'yo-down'))));
    }
    renderIcon(icon) {
        return (h("div", { class: "icon-container", onClick: () => this.onHeaderIconClicked(icon) },
            h("yoo-icon", { class: { [icon]: true, 'stable': true } })));
    }
    renderContent() {
        return (h("div", { class: "content-container" },
            h("slot", null)));
    }
    render() {
        return (h("div", { class: { 'outer-container': true, 'expanded': this.isExpanded } },
            this.renderHeader(),
            this.isExpanded && this.renderContent()));
    }
    static get is() { return "yoo-form-creator-block-expandable"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "formField": {
            "type": "Any",
            "attr": "form-field"
        },
        "host": {
            "elementRef": true
        },
        "isExpanded": {
            "state": true
        }
    }; }
    static get style() { return ":host .outer-container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  width: 100%;\n  min-height: 2.5rem;\n  -webkit-transition: 0.3s;\n  transition: 0.3s;\n  border-radius: 0.25rem;\n  background: var(--light, #FFFFFF);\n  -webkit-box-shadow: 0 5px 15px 0 rgba(40, 47, 54, 0.08);\n  box-shadow: 0 5px 15px 0 rgba(40, 47, 54, 0.08); }\n  :host .outer-container.expanded {\n    min-height: 100px; }\n  :host .outer-container .header {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    min-height: 2.5rem; }\n    :host .outer-container .header .form-icon {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      width: 1.25rem;\n      height: 1.25rem;\n      margin-left: var(--padding-10, 0.625rem);\n      border-radius: 0.25rem;\n      background: var(--accent, #1FB6FF);\n      font-size: 0.875rem; }\n      :host .outer-container .header .form-icon.multimedia {\n        background: var(--info, #fc459e); }\n      :host .outer-container .header .form-icon.select {\n        background: var(--accent, #1FB6FF); }\n      :host .outer-container .header .form-icon.text {\n        background: var(--energized, #fed05b); }\n      :host .outer-container .header .form-icon.number {\n        background: var(--royal, #845cff); }\n      :host .outer-container .header .form-icon.information {\n        background: var(--warning, #ff6402); }\n    :host .outer-container .header .title {\n      -ms-flex: 1;\n      flex: 1;\n      margin-left: var(--padding-10, 0.625rem); }\n    :host .outer-container .header .icons-container {\n      display: -ms-flexbox;\n      display: flex; }\n      :host .outer-container .header .icons-container .icon-container {\n        display: -ms-flexbox;\n        display: flex;\n        position: relative;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: var(--padding-20, 1.25rem);\n        margin-right: var(--padding-10, 0.625rem); }\n        :host .outer-container .header .icons-container .icon-container:last-child {\n          width: 34px;\n          margin-right: 0;\n          font-size: var(--font-s, 13px); }\n          :host .outer-container .header .icons-container .icon-container:last-child::after {\n            position: absolute;\n            left: 0;\n            width: 1px;\n            height: 1.125rem;\n            background: var(--stable-light, #f1f1f1);\n            content: \"\"; }"; }
}

class YooFormCreatorBlockSimpleComponent {
    render() {
        return (h("div", { class: "container" },
            h("div", { class: 'icon-container form-icon ' + this.formField.category },
                h("yoo-icon", { class: this.formField.icon + ' always-light' })),
            h("div", { class: "title" }, translate(this.formField.title)),
            h("div", { class: "icon-container plus" },
                h("yoo-icon", { class: "yo-plus always-light" }))));
    }
    static get is() { return "yoo-form-creator-block-simple"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "formField": {
            "type": "Any",
            "attr": "form-field"
        },
        "host": {
            "elementRef": true
        }
    }; }
    static get style() { return ":host .container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n  align-items: center;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  width: 100%;\n  max-width: 19.5rem;\n  height: 2.5rem;\n  margin: var(--padding-10, 0.625rem) 0;\n  border-radius: 0.25rem;\n  background-color: var(--light, #FFFFFF);\n  -webkit-box-shadow: var(--card-shadow-2, 0 5px 15px 0 rgba(40, 47, 54, 0.08));\n  box-shadow: var(--card-shadow-2, 0 5px 15px 0 rgba(40, 47, 54, 0.08)); }\n  :host .container .icon-container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    margin: 0 var(--padding-10, 0.625rem);\n    background: var(--accent, #1FB6FF); }\n    :host .container .icon-container.plus {\n      width: 0.875rem;\n      height: 0.875rem;\n      border-radius: 50%;\n      background: var(--stable-alt, #d0d0d0);\n      font-size: 0.625rem; }\n    :host .container .icon-container.form-icon {\n      width: 1.25rem;\n      height: 1.25rem;\n      border-radius: 0.25rem;\n      font-size: 0.875rem; }\n    :host .container .icon-container.multimedia {\n      background: var(--info, #fc459e); }\n    :host .container .icon-container.select {\n      background: var(--accent, #1FB6FF); }\n    :host .container .icon-container.text {\n      background: var(--energized, #fed05b); }\n    :host .container .icon-container.number {\n      background: var(--royal, #845cff); }\n    :host .container .icon-container.information {\n      background: var(--warning, #ff6402); }\n  :host .container .title {\n    -ms-flex: 1;\n    flex: 1; }"; }
}

class YooFormCreatorHeaderComponent {
    constructor() {
        this.secondaryActions = [
            { text: translate('IMPORTCSV'), icon: 'yo-file-csv', handler: () => this.exportClicked.emit() },
            { text: translate('EXPORTTOCSV'), icon: 'yo-export', handler: () => this.importClicked.emit() }
        ];
    }
    renderLogoImage() {
        const src = getAppContext()['boost'] ? 'boost' : 'operations';
        return (h("div", { class: "image-container" },
            h("yoo-img", { class: "header-logo", src: `assets/logo/${src}_simple.svg` })));
    }
    renderBreadCrumbs() {
        return (h("div", { class: "title" },
            h("div", { class: "stable" }, translate('CAMPAIGNCREATOR')),
            h("div", { class: "stable" }, "/"),
            h("span", null, this.formTitle)));
    }
    renderButtons() {
        return (h("div", { class: "buttons-container" },
            h("div", { class: "icon-container", onClick: () => this.helpClicked.emit() },
                h("yoo-icon", { class: "yo-help stable" })),
            h("div", { class: "icon-container context-menu" },
                h("yoo-context-menu", { class: "flex-column", contentButtons: this.secondaryActions, contentPosition: { top: '4rem', right: 'auto', bottom: 'auto', left: '1rem' } },
                    h("yoo-button", { class: "secondary-actions icon-only", icon: "yo-more" }))),
            h("yoo-button", { onClick: () => this.saveCloseClicked.emit(), class: "success", text: "SAVEANDCLOSE" }),
            h("div", { onClick: () => this.toggleLivePreviewClicked.emit(), class: "icon-container end" },
                h("yoo-icon", { class: {
                        'yo-sidebar-right': true,
                        'stable': !this.isLivePreviewVisible,
                        'success': this.isLivePreviewVisible
                    } }))));
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return [
            this.renderLogoImage(),
            this.renderBreadCrumbs(),
            this.renderButtons()
        ];
    }
    static get is() { return "yoo-form-creator-header"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "formTitle": {
            "type": String,
            "attr": "form-title"
        },
        "host": {
            "elementRef": true
        },
        "isLivePreviewVisible": {
            "type": Boolean,
            "attr": "is-live-preview-visible"
        }
    }; }
    static get events() { return [{
            "name": "helpClicked",
            "method": "helpClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "saveCloseClicked",
            "method": "saveCloseClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "toggleLivePreviewClicked",
            "method": "toggleLivePreviewClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "exportClicked",
            "method": "exportClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "importClicked",
            "method": "importClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n  align-items: center;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  height: 3rem;\n  border-bottom: 1px solid var(--stable-light, #f1f1f1); }\n  :host .image-container {\n    display: -ms-flexbox;\n    display: flex;\n    position: relative;\n    -ms-flex-align: center;\n    align-items: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    width: 3rem;\n    height: 100%; }\n    :host .image-container yoo-img {\n      display: -ms-flexbox;\n      display: flex;\n      width: 1.5rem;\n      height: 1.5rem; }\n    :host .image-container::after {\n      position: absolute;\n      right: 0;\n      width: 1px;\n      height: 1.125rem;\n      background: var(--stable-light, #f1f1f1);\n      content: \"\"; }\n  :host .title {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1;\n    padding-left: var(--padding-20, 1.25rem);\n    font-size: var(--font-s, 13px); }\n    :host .title .stable {\n      margin-right: var(--padding-5, 0.3125rem); }\n  :host .buttons-container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n    height: 100%; }\n    :host .buttons-container .icon-container {\n      min-width: 1.125rem;\n      margin-right: var(--padding-20, 1.25rem);\n      font-size: 1.125rem;\n      text-align: center; }\n      :host .buttons-container .icon-container.end {\n        display: -ms-flexbox;\n        display: flex;\n        position: relative;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: 3.625rem;\n        height: 100%;\n        margin-right: 0; }\n        :host .buttons-container .icon-container.end::after {\n          position: absolute;\n          left: 0;\n          width: 1px;\n          height: 1.125rem;\n          background: var(--stable-light, #f1f1f1);\n          content: \"\"; }\n      :host .buttons-container .icon-container.context-menu {\n        position: relative; }\n        :host .buttons-container .icon-container.context-menu yoo-button.secondary-actions {\n          --shadow: none; }\n    :host .buttons-container yoo-button {\n      --min-height-container: 1.625rem;\n      --min-width-container: 4.6875rem;\n      --font-size-text: cssvar(font-s);\n      margin-right: var(--padding-20, 1.25rem); }"; }
}

class YooFormCreatorPageCardComponent {
    onPageCardClicked() {
        this.pageClicked.emit();
    }
    renderHeading() {
        return (h("div", { class: "heading" },
            h("div", { class: "page-number" }, `${translate('PAGE')} ${this.pageCardEntry.pageNumber}`),
            this.pageCardEntry.selected && h("div", { class: "check-container" },
                h("yoo-icon", { class: "yo-check" }))));
    }
    renderSubheading() {
        return (h("div", { class: "subheading" },
            h("div", { class: "page-title" }, this.pageCardEntry.pageTitle)));
    }
    renderFooter() {
        return (h("div", { class: "footer" },
            h("div", { class: "block-number" }, `${this.pageCardEntry.blockNumber} Blocks`),
            h("div", { class: "more-container" },
                h("yoo-icon", { class: "yo-more" }))));
    }
    render() {
        return (h("div", { class: { 'outer-container': true, 'selected': this.pageCardEntry.selected }, onClick: () => this.onPageCardClicked() },
            this.renderHeading(),
            this.renderSubheading(),
            this.renderFooter()));
    }
    static get is() { return "yoo-form-creator-page-card"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "host": {
            "elementRef": true
        },
        "pageCardEntry": {
            "type": "Any",
            "attr": "page-card-entry"
        }
    }; }
    static get events() { return [{
            "name": "pageClicked",
            "method": "pageClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host .outer-container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  width: 7.5rem;\n  height: 4.375rem;\n  padding: var(--padding-10, 0.625rem);\n  border-radius: 0.25rem;\n  background: var(--light, #FFFFFF);\n  -webkit-box-shadow: 0px 5px 15px 0 rgba(40, 47, 54, 0.08);\n  box-shadow: 0px 5px 15px 0 rgba(40, 47, 54, 0.08); }\n  :host .outer-container.selected {\n    border: 1px solid var(--success, #04CC99); }\n  :host .outer-container .heading {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    min-height: var(--padding-25, 1.5625rem); }\n    :host .outer-container .heading .page-number {\n      -ms-flex: 1;\n      flex: 1;\n      color: var(--black, #000000);\n      font-size: var(--font-s, 13px); }\n    :host .outer-container .heading .check-container {\n      color: var(--success, #04CC99); }\n  :host .outer-container .subheading {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1;\n    color: var(--black, #000000);\n    font-size: var(--font-xs, 10px); }\n  :host .outer-container .footer {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    color: var(--stable, #adadad);\n    font-size: var(--font-xs, 10px); }\n    :host .outer-container .footer .block-number {\n      -ms-flex: 1;\n      flex: 1; }"; }
}

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DatePickerOriginal = /** @class */ (function (_super) {
    __extends(DatePickerOriginal, _super);
    function DatePickerOriginal() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @hidden
         */
        _this.ANDROID_THEMES = {
            THEME_TRADITIONAL: 1,
            THEME_HOLO_DARK: 2,
            THEME_HOLO_LIGHT: 3,
            THEME_DEVICE_DEFAULT_DARK: 4,
            THEME_DEVICE_DEFAULT_LIGHT: 5
        };
        return _this;
    }
    DatePickerOriginal.prototype.show = function (options) { return cordova(this, "show", {}, arguments); };
    DatePickerOriginal.pluginName = "DatePicker";
    DatePickerOriginal.plugin = "cordova-plugin-datepicker";
    DatePickerOriginal.pluginRef = "datePicker";
    DatePickerOriginal.repo = "https://github.com/VitaliiBlagodir/cordova-plugin-datepicker";
    DatePickerOriginal.platforms = ["Android", "iOS", "Windows"];
    return DatePickerOriginal;
}(IonicNativePlugin));
var DatePicker = new DatePickerOriginal();

const MINUTES_INCREMENT_SIZE = 1;
const CALENDAR_SIZE = 450;
class YooFormDateTimeComponent {
    constructor() {
        this.type = 'date';
        this.validators = [];
        this.externalValidators = [];
        this.clearable = true;
        this.nativePickerLabelColor = '#04CC99';
        this.isSchedule = false;
        this.isRange = false;
        this.isCordovaDatePicker = false;
        this.isNativeDatePickerOpen = false;
        this.isCustomDatePickerOpen = false;
        this.dateDisplayFormat = 'L';
        this.datetimeDisplayFormat = 'L LT';
        this.timeDisplayFormat = 'LT';
        this.is24Hour = true;
        this.needsScrolling = true;
        this.preventDateChange = false;
    }
    isClickBlur(event) {
        if (this.isCustomDatePickerOpen && event.path) {
            let clickPath = event.path;
            for (let i = 0; i < clickPath.length; i++) {
                let element = clickPath[i];
                if (element.tagName === 'YOO-CALENDAR' || element.tagName === 'YOO-FORM-TIME') {
                    return;
                }
            }
            this.isCustomDatePickerOpen = false;
            this.currentTime = null;
            this.needsScrolling = true;
            onInputBlurred(event, this, '.outer-container');
        }
    }
    async getElement() {
        return this;
    }
    componentWillLoad() {
        setValidator(this);
        this.is24Hour = getCurrentLanguage() !== 'en';
        if (!this.is24Hour) {
            this.datetimeDisplayFormat = 'Pp';
            this.timeDisplayFormat = 'LTP';
        }
        this.isCordovaDatePicker = isCordova() && [FormFieldType.date.toString(), FormFieldType.time.toString(), FormFieldType.datetime.toString()].indexOf(this.type) >= 0;
        switch (this.type) {
            case FormFieldType.date:
                this.iconPrefix = this.allowOcr ? 'yo-barcode' : 'yo-calendar';
                break;
            case FormFieldType.datetime:
                this.iconPrefix = 'yo-date-time';
                break;
            case FormFieldType.time:
                this.iconPrefix = 'yo-alarm';
                break;
        }
    }
    componentDidLoad() {
        this.contentParent = findParent(this.host, 'yoo-ion-content');
        this.inputContainer = findParent(this.host, 'yoo-form-input-container');
        this.ionScroll = findParent(this.host, 'yoo-ion-scroll');
        if (this.autofocus && this.inputField) {
            this.inputField.click();
        }
    }
    componentDidUpdate() {
        if (this.isCustomDatePickerOpen && this.needsScrolling) {
            let contentHeight = getElementDimensions(this.contentParent).height;
            let inputContainerPosition = this.inputContainer.getBoundingClientRect().top;
            let shouldScroll = inputContainerPosition + CALENDAR_SIZE > contentHeight;
            const TOP_PADDING = 150;
            if (shouldScroll && this.ionScroll) {
                this.ionScroll.scrollByPoint(0, inputContainerPosition - TOP_PADDING, 50);
            }
            this.needsScrolling = false;
        }
    }
    animateCalendar(open, timeout = 100) {
        setTimeout(() => {
            let calendarPickerContainer = querySelectorDeep(this.host, '.calendar-picker-container');
            setAnimation('fade', calendarPickerContainer, { open });
        }, timeout);
    }
    isTimeInput(inputType) {
        return inputType === FormFieldType.time;
    }
    isDateTimeInput(inputType) {
        return inputType === FormFieldType.datetime;
    }
    isDateInput(inputType) {
        return inputType === FormFieldType.date;
    }
    onInputChanged(ev) {
        let inputValue = querySelectorDeep(this.host, 'input').value; //ev.target.value WHY NOT USE this.inputField? 
        let value = convertValueForInputType(inputValue, this.type);
        setValueAndValidateInput(value, this);
    }
    getDisplayValue() {
        if (isNullOrUndefined(this.value)) {
            return null;
        }
        if (this.isRange) {
            if (this.value[0] && this.value[1] && typeof this.value === 'object') {
                let lowerBound = dateFormat(this.value[0], this.dateDisplayFormat);
                let upperBound = dateFormat(this.value[1], this.dateDisplayFormat);
                return `${lowerBound} - ${upperBound}`;
            }
        }
        let formattedDate;
        switch (this.type) {
            case FormFieldType.time: {
                return getTimeDisplayValue(this.value, this.is24Hour);
            }
            case FormFieldType.date:
                return dateFormat(this.value, this.dateDisplayFormat);
            case FormFieldType.datetime:
                formattedDate = dateFormat(this.value, this.datetimeDisplayFormat);
                let dateTime = formattedDate.split(' ');
                return `${dateTime[0]} ${translate('AT')} ${dateTime[1]} ${!this.is24Hour ? dateTime[2] : ''}`;
            default:
                return this.value;
        }
    }
    onInputClick(ev) {
        const ANDROID_NATIVE_DATE_PICKER_LOAD_TIME = 1000;
        ev.stopPropagation();
        if (this.isCordovaDatePicker && !this.isRange) {
            blurActiveElement(ev);
            // Picker only opens in Android if it receives a date object
            // https://github.com/VitaliiBlagodir/cordova-plugin-datepicker/commit/473f1bdc31bc68163b85bdb842516ed320876fa3
            let initValue = this.value ? isAndroid() && typeof this.value === 'string' ?
                new Date(this.value) : this.value
                : new Date();
            let { minDate, maxDate } = formatMinMaxDate(this.minDate, this.maxDate);
            if (!this.isNativeDatePickerOpen) {
                this.isNativeDatePickerOpen = true;
                if (isAndroid()) {
                    //This is to fix an issue with the Android back button
                    //Another istance of the date picker can not be opened once a date picker is open
                    setTimeout(() => {
                        this.isNativeDatePickerOpen = false;
                    }, ANDROID_NATIVE_DATE_PICKER_LOAD_TIME);
                }
                DatePicker.show({
                    date: initValue,
                    mode: this.type === FormFieldType.datetime ? 'datetime' : this.type,
                    is24Hour: getCurrentLanguage() !== 'en',
                    maxDate,
                    minDate,
                    okText: translate('OK'),
                    cancelText: translate('CANCEL'),
                    todayText: translate('TODAY'),
                    doneButtonLabel: translate('DONE'),
                    doneButtonColor: this.nativePickerLabelColor,
                    cancelButtonColor: this.nativePickerLabelColor,
                    cancelButtonLabel: translate('CANCEL'),
                    minuteInterval: MINUTES_INCREMENT_SIZE,
                    locale: getCurrentLanguage(),
                    nowText: translate('NOW'),
                    androidTheme: DatePicker.ANDROID_THEMES.THEME_DEVICE_DEFAULT_LIGHT
                }).then((date) => {
                    // When the picker is closed used 'Cancel', the date is undefined
                    this.isNativeDatePickerOpen = false;
                    if (date) {
                        let value = convertValueForInputType(date, this.type);
                        setValueAndValidateInput(value, this);
                    }
                }, (err) => {
                    this.isNativeDatePickerOpen = false;
                }).catch((err) => {
                    this.isNativeDatePickerOpen = false;
                });
            }
        }
        else {
            if (!this.isCustomDatePickerOpen) {
                // this.animateCalendar(true);
                this.isCustomDatePickerOpen = true;
                if (this.value) {
                    this.preventDateChange = true;
                }
            }
        }
    }
    onDateInputFocused(ev) {
        // prevent the native date picker fired up when the input is focused
        if (this.isCordovaDatePicker) {
            ev.stopPropagation();
            ev.preventDefault();
            return;
        }
        onInputFocused(ev, this, '.outer-container');
    }
    onClearClicked(event) {
        event.stopPropagation();
        onInputClear(event, this);
        if (this.isCustomDatePickerOpen) {
            this.isCustomDatePickerOpen = false;
            this.currentTime = null;
        }
    }
    getReadOnlyValue() {
        switch (this.type) {
            case FormFieldType.date:
                return pipes.dateFormat.transform(this.value, this.dateDisplayFormat);
            case FormFieldType.datetime:
                return pipes.dateFormat.transform(this.value, this.datetimeDisplayFormat);
            case FormFieldType.time:
                return pipes.dateFormat.transform(this.value, this.timeDisplayFormat);
            default:
                return pipes.dateFormat.transform(this.value, this.dateDisplayFormat);
        }
    }
    updateTimeValue(originalDate, newTime) {
        let updatedValue = originalDate;
        let newHours = getHours(newTime);
        let newMinutes = getMinutes(newTime);
        updatedValue = setDateHours(updatedValue, newHours);
        updatedValue = setDateMinutes(updatedValue, newMinutes);
        return updatedValue;
    }
    onToggle(event, htmlElement) {
        event.stopPropagation();
        if (this.isCustomDatePickerOpen) {
            // this.animateCalendar(false, 0);
            this.isCustomDatePickerOpen = false;
            this.needsScrolling = true;
            onInputBlurred(event, htmlElement, '.outer-container');
        }
        else if (!this.isCustomDatePickerOpen) {
            this.isCustomDatePickerOpen = true;
            if (this.value) {
                // Do nothing if toggled when there is already a value
                this.preventDateChange = true;
            }
            if (this.currentTime) {
                this.currentTime = null;
            }
        }
    }
    onDateChanged(event) {
        if (!this.isRange && !this.preventDateChange) {
            let newDate = new Date(event.detail.date);
            if (!this.isDateInput(this.type)) {
                if (this.currentTime) {
                    let currentHours = getHours(this.currentTime);
                    let currentMinutes = getMinutes(this.currentTime);
                    newDate = dateAdd(newDate, 'h', currentHours);
                    newDate = dateAdd(newDate, 'mm', currentMinutes);
                }
            }
            let value = convertValueForInputType(newDate, this.type);
            this.currentTime = value;
            setValueAndValidateInput(value, this);
        }
        this.preventDateChange = false;
    }
    onDateRangeChanged(event) {
        let dateRange = event.detail;
        let lowerBound = dateRange[0].date;
        let upperBound = dateRange[1].date;
        let formattedLowerBound = convertValueForInputType(lowerBound, 'date');
        if (upperBound) {
            let formattedUpperBound = convertValueForInputType(upperBound, 'date');
            let formattedRange = [formattedLowerBound, formattedUpperBound];
            setValueAndValidateInput(formattedRange, this);
        }
        else {
            setValueAndValidateInput(formattedLowerBound, this);
        }
        // IOS display bug - it was not refreshing the values without it
        if (isIOS$1()) {
            this.inputField.value = this.getDisplayValue();
        }
    }
    onTimeInputChanged(event) {
        this.currentTime = event.detail;
        if (this.isTimeInput(this.type)) {
            setValueAndValidateInput(this.currentTime, this);
        }
        else if (this.isSchedule && !isCordova()) {
            // Here we simply increment/decrement time to avoid changing dates
            let updatedValue = this.updateTimeValue(this.value, this.currentTime);
            setValueAndValidateInput(updatedValue, this);
        }
    }
    onCalendarDayClicked() {
        if (this.isDateInput(this.type) && this.isCustomDatePickerOpen && !this.isRange) {
            this.isCustomDatePickerOpen = false;
        }
    }
    onAmPmToggled(event) {
        if (!this.is24Hour) {
            const timePeriod = event.detail;
            if (timePeriod === 'AM') {
                // We subtract 12h to the current time
                const updatedDate = dateSub(this.value, 'h', 12);
                setValueAndValidateInput(updatedDate, this);
            }
            else if (timePeriod === 'PM') {
                // We add 12h to the current time
                const updatedDate = dateAdd(this.value, 'h', 12);
                setValueAndValidateInput(updatedDate, this);
            }
        }
    }
    onTriggerOCR() {
        if (!this.isShowingOcr) {
            this.isShowingOcr = true;
            let dialog = document.createElement('yoo-form-barcode-dialog');
            dialog.mainMode = 'ocr';
            let scannedSuccessListener = (ev) => {
                this.isShowingOcr = false;
                if (ev && ev.detail) {
                    setValueAndValidateInput(ev.detail, this);
                    this.value = ev.detail;
                }
                closeModal(dialog);
            };
            dialog.addEventListener('scannedSuccess', scannedSuccessListener);
            showModal(dialog).then(() => {
                if (dialog) {
                    dialog.removeEventListener('scannedSuccess', scannedSuccessListener);
                    dialog = null;
                }
            });
        }
    }
    renderInputField() {
        let displayValue = this.getDisplayValue();
        return (h("input", { class: (this.isCordovaDatePicker ? 'native' : ''), readonly: true, ref: (el) => this.inputField = el, placeholder: !this.placeholdertolabel ? this.placeholder : '', value: displayValue, required: this.required, onInput: ev => this.onInputChanged(ev), onFocus: ev => this.onDateInputFocused(ev), onClick: ev => this.onInputClick(ev) }));
    }
    renderNativeInput() {
        return (h("div", { class: 'outer-container ' + (this.isSchedule ? 'hidden' : '') },
            this.iconPrefix ?
                h("div", { class: "icon-prefix", onClick: ev => this.onInputClick(ev) },
                    h("yoo-icon", { class: this.iconPrefix })) : null,
            h("div", { class: "input-container flex" }, this.renderInputField()),
            this.validity === false &&
                h("div", { class: 'icon-suffix invalid' },
                    h("yoo-icon", { class: 'yo-rejected2' })),
            this.value && this.clearable ?
                h("div", { class: "icon-suffix clear", onClick: ev => this.onClearClicked(ev) },
                    h("yoo-icon", { class: "yo-cross" }))
                : null,
            this.allowOcr && getSession().hasScandit && h("div", { class: "icon-suffix ocr", onClick: (ev) => this.onTriggerOCR() },
                h("yoo-icon", { class: "yo-camera" })),
            !isCordova() ?
                h("div", { class: "icon-suffix toggle", onClick: (event) => this.onToggle(event, this) }, this.isCustomDatePickerOpen ? h("yoo-icon", { class: "yo-up" }) : h("yoo-icon", { class: "yo-down" })) : null));
    }
    renderTimeInput() {
        return (h("yoo-form-time", { class: {
                'time-only': this.isTimeInput(this.type)
            }, onInputChanged: (event) => this.onTimeInputChanged(event), onAmPmToggled: (event) => this.onAmPmToggled(event), value: this.value, maxDate: this.maxDate, minDate: this.minDate, clearable: this.clearable, isSchedule: this.isSchedule }));
    }
    renderEditable() {
        return [
            this.renderNativeInput(),
            (!isCordova() && this.isCustomDatePickerOpen) || this.isSchedule || (isCordova() && this.isRange && this.isCustomDatePickerOpen) ?
                h("div", { class: "calendar-picker-container" },
                    !this.isTimeInput(this.type) ? h("yoo-calendar", { class: 'calendar-picker ' + (this.type), isRange: this.isRange, isDatePicker: true, maxDate: this.maxDate, activeDay: this.value, minDate: this.isSchedule ? dateSub(new Date(), 'd', 1) : this.minDate, dateRange: this.value && isArray(this.value) && this.value.length === 2 ? this.value : null, onDateChanged: (event) => this.onDateChanged(event), onDateRangeChanged: (event) => this.onDateRangeChanged(event), onDayClicked: () => this.onCalendarDayClicked() }) : null,
                    !isCordova() && (this.isTimeInput(this.type) || this.isDateTimeInput(this.type) || this.isSchedule) ?
                        this.renderTimeInput()
                        : isCordova() && this.isSchedule ? this.renderTimeInput() : null)
                : null
        ];
    }
    renderReadonly() {
        return h("div", { class: "readonly" }, this.getReadOnlyValue());
    }
    hostData() {
        return {
            class: Object.assign({ 'schedule': this.isSchedule }, getAppContext(true), { [this.extraClass]: true })
        };
    }
    render() {
        return this.readonly ? this.renderReadonly() : this.renderEditable();
    }
    static get is() { return "yoo-form-date-time"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "allowOcr": {
            "type": Boolean,
            "attr": "allow-ocr"
        },
        "autofocus": {
            "type": Boolean,
            "attr": "autofocus"
        },
        "clearable": {
            "type": Boolean,
            "attr": "clearable"
        },
        "externalValidators": {
            "type": "Any",
            "attr": "external-validators"
        },
        "extraClass": {
            "type": String,
            "attr": "extra-class"
        },
        "getElement": {
            "method": true
        },
        "host": {
            "elementRef": true
        },
        "iconSuffix": {
            "type": String,
            "attr": "icon-suffix"
        },
        "isCordovaDatePicker": {
            "state": true
        },
        "isCustomDatePickerOpen": {
            "state": true
        },
        "isNativeDatePickerOpen": {
            "state": true
        },
        "isRange": {
            "type": Boolean,
            "attr": "is-range"
        },
        "isSchedule": {
            "type": Boolean,
            "attr": "is-schedule"
        },
        "maxDate": {
            "type": "Any",
            "attr": "max-date"
        },
        "minDate": {
            "type": "Any",
            "attr": "min-date"
        },
        "name": {
            "type": String,
            "attr": "name"
        },
        "nativePickerLabelColor": {
            "type": String,
            "attr": "native-picker-label-color"
        },
        "placeholder": {
            "type": String,
            "attr": "placeholder"
        },
        "placeholdertolabel": {
            "type": Boolean,
            "attr": "placeholdertolabel"
        },
        "readonly": {
            "type": Boolean,
            "attr": "readonly"
        },
        "required": {
            "type": Boolean,
            "attr": "required"
        },
        "type": {
            "type": String,
            "attr": "type"
        },
        "validators": {
            "type": "Any",
            "attr": "validators",
            "mutable": true
        },
        "validity": {
            "type": Boolean,
            "attr": "validity",
            "mutable": true
        },
        "value": {
            "type": "Any",
            "attr": "value",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "validityChanged",
            "method": "validityChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputBlurred",
            "method": "inputBlurred",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputFocused",
            "method": "inputFocused",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputChanged",
            "method": "inputChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "iconClicked",
            "method": "iconClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "body:click",
            "method": "isClickBlur"
        }]; }
    static get style() { return ":host {\n  display: block;\n  opacity: 1; }\n  :host .flex {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1; }\n  :host .calendar-picker-container {\n    margin-top: var(--padding-10, 0.625rem);\n    margin-bottom: 0.1875rem;\n    padding-top: var(--padding-10, 0.625rem);\n    border-radius: 5px;\n    -webkit-box-shadow: 0 5px 15px 0 rgba(40, 47, 54, 0.08);\n    box-shadow: 0 5px 15px 0 rgba(40, 47, 54, 0.08); }\n    :host .calendar-picker-container yoo-calendar {\n      --date-picker-margin: var(--padding-5, 0.3125rem);\n      min-height: 28.75rem; }\n    :host .calendar-picker-container yoo-form-time {\n      margin-top: var(--padding-15, 0.9375rem); }\n      :host .calendar-picker-container yoo-form-time.time-only {\n        --margin: 0 var(--padding-15, 0.9375rem)\n            ; }\n  :host .outer-container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    border: 1px solid var(--input-container-border-color, #E6E6E6);\n    border-radius: var(--border-radius-input, 5px); }\n    :host .outer-container.hidden {\n      display: none; }\n    :host .outer-container.valid {\n      border: 1px solid var(--success, #04CC99); }\n    :host .outer-container.invalid {\n      border: 1px solid var(--danger, #ff625f); }\n    :host .outer-container.focused {\n      border: 1px solid var(--dark, #2b3648); }\n    :host .outer-container .input-container input {\n      margin: 0;\n      border: 0;\n      padding: 0;\n      display: inline-block;\n      vertical-align: middle;\n      white-space: normal;\n      background: none;\n      line-height: 1;\n      font-size: var(--font-m, 15px);\n      font-family: \"Lato\" !important;\n      min-width: 0;\n      -webkit-box-sizing: content-box;\n      box-sizing: content-box;\n      width: 100%;\n      height: 2.5rem;\n      padding-left: var(--padding-15, 0.9375rem);\n      border: none;\n      border-radius: var(--border-radius-input, 5px);\n      background: var(--light, #FFFFFF);\n      color: var(--black, #000000);\n      font-size: var(--font-m, 15px);\n      line-height: 1.5;\n      vertical-align: unset; }\n      :host .outer-container .input-container input:focus {\n        outline: 0; }\n      :host .outer-container .input-container input[type=reset], :host .outer-container .input-container input[type=button], :host .outer-container .input-container input[type=submit], :host .outer-container .input-container input[type=checkbox], :host .outer-container .input-container input[type=radio] {\n        -webkit-box-sizing: border-box;\n        box-sizing: border-box; }\n      :host .outer-container .input-container input[type=search] {\n        -webkit-appearance: textfield;\n        -webkit-box-sizing: content-box;\n        box-sizing: content-box; }\n      :host .outer-container .input-container input.native {\n        padding: 0rem 1rem; }\n    :host .outer-container .icon-prefix,\n    :host .outer-container .icon-suffix {\n      display: -ms-flexbox;\n      display: flex;\n      -ms-flex-direction: row;\n      flex-direction: row;\n      -ms-flex-align: center;\n      align-items: center;\n      padding: 0.5rem 1rem;\n      color: var(--stable, #adadad);\n      font-size: var(--icon-m, 20px); }\n      :host .outer-container .icon-prefix .yo-down,\n      :host .outer-container .icon-prefix .yo-up,\n      :host .outer-container .icon-suffix .yo-down,\n      :host .outer-container .icon-suffix .yo-up {\n        margin: 0 0 0 -0.8rem;\n        font-size: var(--font-xs, 10px); }\n      :host .outer-container .icon-prefix .yo-cross,\n      :host .outer-container .icon-suffix .yo-cross {\n        margin: 0 0 0 -0.8rem; }\n      :host .outer-container .icon-prefix.invalid,\n      :host .outer-container .icon-suffix.invalid {\n        color: var(--danger, #ff625f); }\n    :host .outer-container .icon-suffix {\n      color: var(--control-icon-color, #adadad); }\n    :host .outer-container .icon-prefix {\n      border-right: 1px solid var(--input-container-border-color, #E6E6E6);\n      color: csscolor(stable); }\n    :host .outer-container .icon-close {\n      color: var(--stable, #adadad); }\n  :host .readonly {\n    padding: 0.5rem;\n    padding-left: 0;\n    padding-bottom: 0; }\n\n:host(.schedule) .calendar-picker-container {\n  height: 100%; }\n\n:host(.ios) .outer-container .input-container input {\n  caret-color: transparent; }\n\n:host(.history) {\n  margin: 0 !important;\n  padding: 0 !important;\n  border: 0 !important; }\n  :host(.history) .readonly {\n    padding: 0 !important; }\n\n:host(.x-large) .readonly {\n  font-size: var(--font-xl, 36px); }"; }
}

class YooFormFooterComponent {
    constructor() {
        this.timerStart = null; // in seconds
        this.isTabbarHidden = false;
    }
    onListenTimerCounterValue(ev) {
        this.session.timerCountDownState = ev.detail;
    }
    onHideShowTabbar(ev) {
        this.isTabbarHidden = hideShowTabbar(ev, this.host, this.isTabbarHidden);
    }
    componentWillLoad() {
        this.session = getSession();
    }
    onButtonClick(ev, button) {
        if (!button.disabled || button.performHandlerWhenDisabled) {
            button.handler(ev);
        }
    }
    renderButton(button, index) {
        return (h("div", { class: { 'button-container': true, 'first': (index === 0 && this.timerStart === null) } },
            h("yoo-button", { onClick: (ev => this.onButtonClick(ev, button)), text: button.text, icon: button.icon, class: 'footer ' + button.cssClass, disabled: button.disabled, isLoading: button.isLoading })));
    }
    renderTimer() {
        const SECOND_COEFFICIENT = 60;
        let countDownProgressParams = {
            countDownMode: true,
            countDownStartValue: this.timerStart * SECOND_COEFFICIENT,
            circleWidth: isWeb() ? 20 : 45
        };
        return (h("div", { class: "button-container first" },
            h("yoo-progress-bar-core", { shape: "circle", progressParameters: countDownProgressParams })));
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return (h("div", { class: "mission-footer" },
            this.timerStart !== null && this.renderTimer(),
            this.buttons &&
                this.buttons.map((button, index) => this.renderButton(button, index))));
    }
    static get is() { return "yoo-form-footer"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "buttons": {
            "type": "Any",
            "attr": "buttons"
        },
        "host": {
            "elementRef": true
        },
        "onHideShowTabbar": {
            "method": true
        },
        "timerStart": {
            "type": "Any",
            "attr": "timer-start"
        }
    }; }
    static get listeners() { return [{
            "name": "sendTimerCountDownState",
            "method": "onListenTimerCounterValue"
        }]; }
    static get style() { return ":host {\n  --border-radius: 0;\n  --border: none;\n  --button-width-container: 100%;\n  --footer-height: 5.75rem;\n  top: auto;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  position: absolute;\n  z-index: 1; }\n  :host .mission-footer {\n    top: auto;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    position: absolute;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-align: center;\n    align-items: center;\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n    width: 100%;\n    height: var(--footer-height);\n    border-top: 1px solid var(--stable-30, #E6E6E6);\n    background-color: var(--light, #FFFFFF);\n    z-index: 2; }\n    :host .mission-footer yoo-button {\n      z-index: 3; }\n    :host .mission-footer .button-container {\n      width: 100%;\n      padding-right: var(--padding-15, 0.9375rem);\n      z-index: 3; }\n      :host .mission-footer .button-container yoo-button {\n        --width-container: var(--button-width-container); }\n      :host .mission-footer .button-container.first {\n        padding-left: var(--padding-15, 0.9375rem); }\n\n:host(.iphone-x) .mission-footer {\n  padding-bottom: 20px; }\n\n:host(.no-gradient) .mission-footer {\n  height: 3.125rem; }"; }
}

const MINUTES_INCREMENT_SIZE$1 = 5;
class YooFormTimeComponent {
    constructor() {
        this.validators = [];
        this.type = 'time';
        this.clearable = true;
        this.isSchedule = false;
        this.is24Hour = true;
        this.isCordovaTimePicker = false;
        this.isCordovaTimePickerOpen = false;
        this.timePeriod = 'AM';
    }
    componentWillLoad() {
        setValidator(this);
        this.isCordovaTimePicker = isCordova();
        this.is24Hour = getCurrentLanguage() !== 'en';
        if (this.value) {
            this.setAmPm(this.value);
        }
        else {
            this.value = new Date();
            this.setAmPm(this.value);
        }
    }
    incrementValue(date = new Date(), timePortion = 'h') {
        let incrementedTime;
        date = roundToNearestMinutes(date, MINUTES_INCREMENT_SIZE$1);
        if (timePortion === 'ampm') {
            this.toggleAmPm();
            return;
        }
        else {
            this.setAmPm(date);
            if (timePortion === 'h') {
                incrementedTime = dateAdd(date, 'h', 1);
            }
            else if (timePortion === 'min') {
                incrementedTime = dateAdd(date, 'mm', MINUTES_INCREMENT_SIZE$1);
            }
        }
        setValueAndValidateInput(incrementedTime.toISOString(), this);
    }
    decrementValue(date = new Date(), timePortion = 'h') {
        let decrementedTime;
        date = roundToNearestMinutes(date, MINUTES_INCREMENT_SIZE$1);
        if (timePortion === 'ampm') {
            this.toggleAmPm();
            return;
        }
        else {
            this.setAmPm(date);
            if (timePortion === 'h') {
                decrementedTime = dateSub(date, 'h', 1);
            }
            else if (timePortion === 'min') {
                decrementedTime = dateSub(date, 'mm', MINUTES_INCREMENT_SIZE$1);
            }
        }
        setValueAndValidateInput(decrementedTime.toISOString(), this);
    }
    isAm(date) {
        return getHours(date) <= 12 ? true : false;
    }
    setAmPm(date) {
        if (!this.is24Hour) {
            if (this.isAm(date)) {
                this.timePeriod = 'AM';
            }
            else {
                this.timePeriod = 'PM';
            }
        }
    }
    toggleAmPm() {
        if (!this.is24Hour) {
            if (this.timePeriod === 'AM') {
                this.timePeriod = 'PM';
            }
            else if (this.timePeriod === 'PM') {
                this.timePeriod = 'AM';
            }
            this.amPmToggled.emit(this.timePeriod);
        }
    }
    onInputChanged(ev) {
    }
    onInputClick(ev) {
        const ANDROID_NATIVE_TIME_PICKER_LOAD_TIME = 1000;
        ev.stopPropagation();
        if (this.isCordovaTimePicker) {
            blurActiveElement(ev);
            // Picker only opens in Android if it receives a date object
            // https://github.com/VitaliiBlagodir/cordova-plugin-datepicker/commit/473f1bdc31bc68163b85bdb842516ed320876fa3
            let initValue = this.value ? isAndroid() && typeof this.value === 'string' ?
                new Date(this.value) : this.value
                : new Date();
            initValue = roundToNearestMinutes(initValue, 5);
            let { minDate, maxDate } = formatMinMaxDate(this.minDate, this.maxDate);
            if (!this.isCordovaTimePickerOpen) {
                this.isCordovaTimePickerOpen = true;
                if (isAndroid()) {
                    //This is to fix an issue with the Android back button
                    //Another istance of the time picker can not be opened once a date picker is open
                    setTimeout(() => {
                        this.isCordovaTimePicker = false;
                    }, ANDROID_NATIVE_TIME_PICKER_LOAD_TIME);
                }
                DatePicker.show({
                    date: initValue,
                    mode: this.type,
                    is24Hour: this.is24Hour,
                    maxDate,
                    minDate,
                    okText: translate('OK'),
                    cancelText: translate('CANCEL'),
                    todayText: translate('TODAY'),
                    nowText: this.isSchedule ? '' : translate('NOW'),
                    doneButtonLabel: translate('DONE'),
                    cancelButtonLabel: translate('CANCEL'),
                    locale: getCurrentLanguage(),
                    minuteInterval: MINUTES_INCREMENT_SIZE$1,
                    androidTheme: DatePicker.ANDROID_THEMES.THEME_DEVICE_DEFAULT_LIGHT
                }).then(date => {
                    this.isCordovaTimePickerOpen = false;
                    let value = convertValueForInputType(date, this.type);
                    setValueAndValidateInput(value, this);
                }, (err) => {
                    this.isCordovaTimePickerOpen = false;
                }).catch(() => {
                    this.isCordovaTimePickerOpen = false;
                });
            }
        }
        else {
            if (!this.isCordovaTimePickerOpen) {
                this.isCordovaTimePickerOpen = true;
            }
        }
    }
    onDateInputFocused(ev) {
        // prevent the native date picker fired up when the input is focused
        if (this.isCordovaTimePicker) {
            ev.stopPropagation();
            ev.preventDefault();
            return;
        }
        onInputFocused(ev, this, '.outer-container');
    }
    onClearClicked(ev) {
        onInputClear(ev, this);
    }
    renderTimeControls(timePortion) {
        return (h("div", { class: "time-controls-container" },
            h("div", { class: "time-control-up", onClick: () => this.incrementValue(this.value, timePortion) },
                h("yoo-icon", { class: "yo-up" })),
            h("div", { class: "time-control-down", onClick: () => this.decrementValue(this.value, timePortion) },
                h("yoo-icon", { class: "yo-down" }))));
    }
    renderMinutesInput() {
        return (h("div", { class: "minutes-container" },
            h("input", { class: "input-minutes", type: "text", value: this.value ? getRoundedMinutes(this.value) : getRoundedMinutes(new Date()), required: this.required, readonly: true }),
            this.renderTimeControls('min')));
    }
    renderAmPmContainer() {
        return (h("div", { class: "am-pm-container" },
            h("input", { class: "input-am-pm", type: "text", value: this.timePeriod, required: this.required, readonly: true }),
            this.renderTimeControls('ampm')));
    }
    getDisplayHours(value) {
        let hours = getHours(value);
        if (!this.is24Hour) {
            // e.g. 03:30 PM
            let amPmTime = dateFormat(this.value ? this.value : new Date(), 'hh:mm a');
            let splitTime = amPmTime.split(':');
            hours = splitTime[0];
        }
        return hours;
    }
    renderHoursInput() {
        return (h("div", { class: "hours-container" },
            h("input", { class: "input-hours", type: "text", value: this.value ? this.getDisplayHours(this.value) : this.getDisplayHours(new Date()), required: this.required, readonly: true }),
            this.renderTimeControls('h')));
    }
    renderInputField() {
        return (h("input", { class: (this.isCordovaTimePicker ? 'native' : ''), type: "", value: getTimeDisplayValue(this.value), required: this.required, onInput: ev => this.onInputChanged(ev), onFocus: ev => this.onDateInputFocused(ev), onClick: ev => this.onInputClick(ev), onBlur: ev => onInputBlurred(ev, this, '.outer-container') }));
    }
    renderNativeInput() {
        return (h("div", { class: "outer-container" },
            h("div", { class: "icon-prefix" },
                h("yoo-icon", { class: "yo-alarm" })),
            h("div", { class: "input-container flex" }, this.renderInputField()),
            this.value && this.clearable ?
                h("div", { class: "icon-suffix clear", onClick: ev => this.onClearClicked(ev) },
                    h("yoo-icon", { class: "yo-cross icon-close" }))
                : null,
            h("div", { class: "icon-suffix toggle" },
                h("yoo-icon", { class: "yo-down" }))));
    }
    renderCustomInput() {
        return (h("div", { class: "time-input-container" },
            h("div", { class: "time-input-header" }, translate('TIME')),
            h("div", { class: "flex time-inputs" },
                this.renderHoursInput(),
                this.renderMinutesInput(),
                !this.is24Hour && !isCordova() ? this.renderAmPmContainer() : null)));
    }
    renderReadonly() {
        return h("div", { class: "readonly" }, pipes.dateFormat.transform(this.value, 'LT'));
    }
    renderEditable() {
        return (isCordova() ? this.renderNativeInput() : this.renderCustomInput());
    }
    hostData() {
        return {
            class: {
                'cordova': isCordova()
            }
        };
    }
    render() {
        return this.readonly ? this.renderReadonly() : this.renderEditable();
    }
    static get is() { return "yoo-form-time"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "asyncValidators": {
            "type": "Any",
            "attr": "async-validators"
        },
        "clearable": {
            "type": Boolean,
            "attr": "clearable"
        },
        "host": {
            "elementRef": true
        },
        "is24Hour": {
            "state": true
        },
        "isCordovaTimePicker": {
            "state": true
        },
        "isCordovaTimePickerOpen": {
            "state": true
        },
        "isSchedule": {
            "type": Boolean,
            "attr": "is-schedule"
        },
        "maxDate": {
            "type": "Any",
            "attr": "max-date"
        },
        "minDate": {
            "type": "Any",
            "attr": "min-date"
        },
        "placeholder": {
            "type": String,
            "attr": "placeholder"
        },
        "readonly": {
            "type": Boolean,
            "attr": "readonly"
        },
        "required": {
            "type": Boolean,
            "attr": "required"
        },
        "timePeriod": {
            "state": true
        },
        "type": {
            "type": String,
            "attr": "type"
        },
        "validators": {
            "type": "Any",
            "attr": "validators"
        },
        "validity": {
            "type": Boolean,
            "attr": "validity",
            "mutable": true
        },
        "value": {
            "type": "Any",
            "attr": "value",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "validityChanged",
            "method": "validityChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputBlurred",
            "method": "inputBlurred",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputFocused",
            "method": "inputFocused",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "inputChanged",
            "method": "inputChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "amPmToggled",
            "method": "amPmToggled",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  --margin: var(--padding-15, 0.9375rem); }\n\n:host .outer-container {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  margin: 0 var(--padding-15, 0.9375rem);\n  border: 1px solid var(--stable-30, #E6E6E6);\n  border-radius: var(--border-radius-input, 5px); }\n  :host .outer-container.focused {\n    border: 1px solid var(--dark, #2b3648); }\n  :host .outer-container .flex {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1; }\n  :host .outer-container .input-container input {\n    margin: 0;\n    border: 0;\n    padding: 0;\n    display: inline-block;\n    vertical-align: middle;\n    white-space: normal;\n    background: none;\n    line-height: 1;\n    font-size: var(--font-m, 15px);\n    font-family: \"Lato\" !important;\n    min-width: 0;\n    -webkit-box-sizing: content-box;\n    box-sizing: content-box;\n    width: 100%;\n    height: 2.5rem;\n    padding-left: var(--padding-15, 0.9375rem);\n    border: none;\n    border-radius: var(--border-radius-input, 5px);\n    background: var(--light, #FFFFFF);\n    color: var(--tex-color);\n    font-size: var(--font-m, 15px);\n    line-height: 1.5;\n    vertical-align: unset; }\n    :host .outer-container .input-container input:focus {\n      outline: 0; }\n    :host .outer-container .input-container input[type=reset], :host .outer-container .input-container input[type=button], :host .outer-container .input-container input[type=submit], :host .outer-container .input-container input[type=checkbox], :host .outer-container .input-container input[type=radio] {\n      -webkit-box-sizing: border-box;\n      box-sizing: border-box; }\n    :host .outer-container .input-container input[type=search] {\n      -webkit-appearance: textfield;\n      -webkit-box-sizing: content-box;\n      box-sizing: content-box; }\n    :host .outer-container .input-container input.native {\n      padding: 0rem 1rem; }\n  :host .outer-container .icon-prefix,\n  :host .outer-container .icon-suffix {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    color: var(--dark, #2b3648); }\n  :host .outer-container .icon-prefix {\n    -ms-flex-line-pack: center;\n    align-content: center;\n    -ms-flex-align: center;\n    align-items: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    padding: 0.5rem 1rem;\n    padding-left: var(--padding-15, 0.9375rem);\n    border-right: 1px solid var(--stable-30, #E6E6E6);\n    color: csscolor(stable);\n    font-size: var(--font-m, 15px); }\n  :host .outer-container .icon-close {\n    color: var(--stable, #adadad); }\n  :host .outer-container .icon-suffix {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    padding-right: var(--padding-15, 0.9375rem); }\n    :host .outer-container .icon-suffix.toggle {\n      font-size: var(--font-xs, 10px); }\n    :host .outer-container .icon-suffix.clear {\n      padding-right: var(--padding-10, 0.625rem); }\n\n:host .time-input-container {\n  margin: var(--margin);\n  padding-bottom: var(--padding-15, 0.9375rem); }\n  :host .time-input-container .time-input-header {\n    padding-bottom: var(--padding-10, 0.625rem); }\n  :host .time-input-container .time-inputs {\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-direction: row;\n    flex-direction: row; }\n    :host .time-input-container .time-inputs .hours-container,\n    :host .time-input-container .time-inputs .minutes-container,\n    :host .time-input-container .time-inputs .am-pm-container {\n      -webkit-box-sizing: border-box;\n      box-sizing: border-box;\n      display: -webkit-box;\n      display: -webkit-flex;\n      display: -moz-box;\n      display: -ms-flexbox;\n      display: flex;\n      width: 4.375rem;\n      height: 2.5rem;\n      border: solid 1px var(--form-time-border-color, rgba(173, 173, 173, 0.3));\n      border-radius: 0.3125rem; }\n      :host .time-input-container .time-inputs .hours-container .time-controls-container,\n      :host .time-input-container .time-inputs .minutes-container .time-controls-container,\n      :host .time-input-container .time-inputs .am-pm-container .time-controls-container {\n        -webkit-box-sizing: border-box;\n        box-sizing: border-box;\n        display: -webkit-box;\n        display: -webkit-flex;\n        display: -moz-box;\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: column;\n        flex-direction: column;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        font-size: var(--font-xs, 10px); }\n        :host .time-input-container .time-inputs .hours-container .time-controls-container .time-control-up,\n        :host .time-input-container .time-inputs .hours-container .time-controls-container .time-control-down,\n        :host .time-input-container .time-inputs .minutes-container .time-controls-container .time-control-up,\n        :host .time-input-container .time-inputs .minutes-container .time-controls-container .time-control-down,\n        :host .time-input-container .time-inputs .am-pm-container .time-controls-container .time-control-up,\n        :host .time-input-container .time-inputs .am-pm-container .time-controls-container .time-control-down {\n          -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n          display: -webkit-box;\n          display: -webkit-flex;\n          display: -moz-box;\n          display: -ms-flexbox;\n          display: flex;\n          -ms-flex-align: center;\n          align-items: center;\n          -ms-flex-pack: center;\n          justify-content: center;\n          width: 100%;\n          height: 100%;\n          margin-right: var(--padding-10, 0.625rem);\n          color: var(--black, #000000); }\n          :host .time-input-container .time-inputs .hours-container .time-controls-container .time-control-up yoo-icon,\n          :host .time-input-container .time-inputs .hours-container .time-controls-container .time-control-down yoo-icon,\n          :host .time-input-container .time-inputs .minutes-container .time-controls-container .time-control-up yoo-icon,\n          :host .time-input-container .time-inputs .minutes-container .time-controls-container .time-control-down yoo-icon,\n          :host .time-input-container .time-inputs .am-pm-container .time-controls-container .time-control-up yoo-icon,\n          :host .time-input-container .time-inputs .am-pm-container .time-controls-container .time-control-down yoo-icon {\n            font-weight: bold; }\n      :host .time-input-container .time-inputs .hours-container .input-hours,\n      :host .time-input-container .time-inputs .hours-container .input-minutes,\n      :host .time-input-container .time-inputs .hours-container .input-am-pm,\n      :host .time-input-container .time-inputs .minutes-container .input-hours,\n      :host .time-input-container .time-inputs .minutes-container .input-minutes,\n      :host .time-input-container .time-inputs .minutes-container .input-am-pm,\n      :host .time-input-container .time-inputs .am-pm-container .input-hours,\n      :host .time-input-container .time-inputs .am-pm-container .input-minutes,\n      :host .time-input-container .time-inputs .am-pm-container .input-am-pm {\n        margin: 0;\n        border: 0;\n        padding: 0;\n        display: inline-block;\n        vertical-align: middle;\n        white-space: normal;\n        background: none;\n        line-height: 1;\n        font-size: var(--font-m, 15px);\n        font-family: \"Lato\" !important;\n        min-width: 0;\n        -webkit-box-sizing: content-box;\n        box-sizing: content-box;\n        max-width: 2.0625rem;\n        padding-left: var(--padding-15, 0.9375rem);\n        opacity: 0.3; }\n        :host .time-input-container .time-inputs .hours-container .input-hours:focus,\n        :host .time-input-container .time-inputs .hours-container .input-minutes:focus,\n        :host .time-input-container .time-inputs .hours-container .input-am-pm:focus,\n        :host .time-input-container .time-inputs .minutes-container .input-hours:focus,\n        :host .time-input-container .time-inputs .minutes-container .input-minutes:focus,\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm:focus,\n        :host .time-input-container .time-inputs .am-pm-container .input-hours:focus,\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes:focus,\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm:focus {\n          outline: 0; }\n        :host .time-input-container .time-inputs .hours-container .input-hours[type=reset], :host .time-input-container .time-inputs .hours-container .input-hours[type=button], :host .time-input-container .time-inputs .hours-container .input-hours[type=submit], :host .time-input-container .time-inputs .hours-container .input-hours[type=checkbox], :host .time-input-container .time-inputs .hours-container .input-hours[type=radio],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=reset],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=button],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=submit],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=checkbox],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=radio],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=reset],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=button],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=submit],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=checkbox],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=radio],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=reset],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=button],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=submit],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=checkbox],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=radio],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=reset],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=button],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=submit],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=checkbox],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=radio],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=reset],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=button],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=submit],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=checkbox],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=radio],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=reset],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=button],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=submit],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=checkbox],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=radio],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=reset],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=button],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=submit],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=checkbox],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=radio],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=reset],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=button],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=submit],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=checkbox],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=radio] {\n          -webkit-box-sizing: border-box;\n          box-sizing: border-box; }\n        :host .time-input-container .time-inputs .hours-container .input-hours[type=search],\n        :host .time-input-container .time-inputs .hours-container .input-minutes[type=search],\n        :host .time-input-container .time-inputs .hours-container .input-am-pm[type=search],\n        :host .time-input-container .time-inputs .minutes-container .input-hours[type=search],\n        :host .time-input-container .time-inputs .minutes-container .input-minutes[type=search],\n        :host .time-input-container .time-inputs .minutes-container .input-am-pm[type=search],\n        :host .time-input-container .time-inputs .am-pm-container .input-hours[type=search],\n        :host .time-input-container .time-inputs .am-pm-container .input-minutes[type=search],\n        :host .time-input-container .time-inputs .am-pm-container .input-am-pm[type=search] {\n          -webkit-appearance: textfield;\n          -webkit-box-sizing: content-box;\n          box-sizing: content-box; }\n    :host .time-input-container .time-inputs .minutes-container {\n      margin: 0 var(--padding-15, 0.9375rem); }\n\n:host(.cordova) {\n  display: -ms-flexbox;\n  display: flex; }"; }
}

class YooFromCreatorPageCardListComponent {
    onPageIndexSelected(newIndex) {
        this.selectPageIndexState = newIndex;
    }
    componentWillLoad() {
        this.selectPageIndexState = this.selectedPageIndex;
    }
    onPageClicked(event, pageIndex) {
        event.stopPropagation();
        this.pageClicked.emit(pageIndex);
    }
    renderPageCards() {
        return (this.missionSlides.map((slide, index) => {
            const selected = (!this.selectPageIndexState && index === 0) || (this.selectPageIndexState === index);
            const pageEntry = {
                pageTitle: slide.title,
                pageNumber: index + 1,
                selected,
                blockNumber: slide.items.length
            };
            return h("yoo-form-creator-page-card", { pageCardEntry: pageEntry, onPageClicked: (event) => this.onPageClicked(event, index) });
        }));
    }
    render() {
        return (h("yoo-ion-scroll", { class: "relative", horizontalMode: true },
            h("div", { class: "cards-container" }, this.renderPageCards())));
    }
    static get is() { return "yoo-from-creator-page-card-list"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "host": {
            "elementRef": true
        },
        "missionSlides": {
            "type": "Any",
            "attr": "mission-slides"
        },
        "selectedPageIndex": {
            "type": Number,
            "attr": "selected-page-index",
            "watchCallbacks": ["onPageIndexSelected"]
        },
        "selectPageIndexState": {
            "state": true
        }
    }; }
    static get events() { return [{
            "name": "pageClicked",
            "method": "pageClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host yoo-ion-scroll {\n  --relative-contain: strict;\n  height: 6.875rem;\n  margin-right: -cssvar(padding-15); }\n  :host yoo-ion-scroll .cards-container {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-align: center;\n    align-items: center;\n    width: 100%;\n    margin-bottom: var(--padding-10, 0.625rem); }\n    :host yoo-ion-scroll .cards-container yoo-form-creator-page-card {\n      margin-top: var(--padding-10, 0.625rem);\n      margin-right: var(--padding-10, 0.625rem); }"; }
}

class YooIonInfiniteScrollComponent {
    constructor() {
        this.position = 'bottom';
        this.threshold = '15%';
        this.disabled = false;
        this.isLoading = false;
        this.thrPx = 0;
        this.thrPc = 0;
        this.didFire = false;
        this.isBusy = false;
    }
    /**
     * The threshold distance from the bottom
     * of the content to call the `infinite` output event when scrolled.
     * The threshold value can be either a percent, or
     * in pixels. For example, use the value of `10%` for the `infinite`
     * output event to get called when the user has scrolled 10%
     * from the bottom of the page. Use the value `100px` when the
     * scroll is within 100 pixels from the bottom of the page.
     * Defaults to `15%`.
     */
    thresholdChanged(val) {
        if (val.lastIndexOf('%') > -1) {
            this.thrPx = 0;
            this.thrPc = (parseFloat(val) / 100);
        }
        else {
            this.thrPx = parseFloat(val);
            this.thrPc = 0;
        }
    }
    /**
     * If true, the infinite scroll will be hidden and scroll event listeners
     * will be removed.
     *
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     */
    disabledChanged(val) {
        this.enableScrollEvents(!val);
    }
    onScroll() {
        const scrollEl = this.scrollEl;
        if (!scrollEl || !this.canStart()) {
            return 1;
        }
        const infiniteHeight = this.el.offsetHeight;
        if (!infiniteHeight) {
            // if there is no height of this element then do nothing
            return 2;
        }
        const scrollTop = scrollEl.scrollTop;
        const scrollHeight = scrollEl.scrollHeight;
        const height = scrollEl.offsetHeight;
        const threshold = this.thrPc ? (height * this.thrPc) : this.thrPx;
        const distanceFromInfinite = (this.position === 'bottom')
            ? scrollHeight - infiniteHeight - scrollTop - threshold - height
            : scrollTop - infiniteHeight - threshold;
        if (distanceFromInfinite < 0) {
            if (!this.didFire) {
                this.isLoading = true;
                this.didFire = true;
                this.ionInfinite.emit();
                return 3;
            }
        }
        else {
            this.didFire = false;
        }
        return 4;
    }
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     */
    complete() {
        const scrollEl = this.scrollEl;
        if (!this.isLoading || !scrollEl) {
            return;
        }
        this.isLoading = false;
        if (this.position === 'top') {
            /**
             * New content is being added at the top, but the scrollTop position stays the same,
             * which causes a scroll jump visually. This algorithm makes sure to prevent this.
             * (Frame 1)
             *    - complete() is called, but the UI hasn't had time to update yet.
             *    - Save the current content dimensions.
             *    - Wait for the next frame using _dom.read, so the UI will be updated.
             * (Frame 2)
             *    - Read the new content dimensions.
             *    - Calculate the height difference and the new scroll position.
             *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.
             * (Still frame 2, if I'm correct)
             *    - Change the scroll position (= visually maintain the scroll position).
             *    - Change the state to re-enable the InfiniteScroll.
             *    - This should be after changing the scroll position, or it could
             *    cause the InfiniteScroll to be triggered again immediately.
             * (Frame 3)
             *    Done.
             */
            this.isBusy = true;
            // ******** DOM READ ****************
            // Save the current content dimensions before the UI updates
            const prev = scrollEl.scrollHeight - scrollEl.scrollTop;
            // ******** DOM READ ****************
            this.queue.read(() => {
                // UI has updated, save the new content dimensions
                const scrollHeight = scrollEl.scrollHeight;
                // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around
                const newScrollTop = scrollHeight - prev;
                // ******** DOM WRITE ****************
                this.queue.write(() => {
                    scrollEl.scrollTop = newScrollTop;
                    this.isBusy = false;
                });
            });
        }
    }
    /**
     * Pass a promise inside `waitFor()` within the `infinite` output event handler in order to
     * change state of infiniteScroll to "complete"
     */
    waitFor(action) {
        const enable = this.complete.bind(this);
        action.then(enable, enable);
    }
    /**
     * The position of the infinite scroll element.
     * The value can be either `top` or `bottom`.
     * Defaults to `bottom`.
     */
    /**
     * Emitted when the scroll reaches
     * the threshold distance. From within your infinite handler,
     * you must call the infinite scroll's `complete()` method when
     * your async operation has completed.
     */
    async componentDidLoad() {
        const scrollEl = findParent(this.el, 'yoo-ion-scroll');
        if (scrollEl) {
            this.scrollEl = scrollEl;
        }
        else {
            const contentEl = findParent(this.el, 'yoo-ion-content');
            if (contentEl) {
                await contentEl.componentOnReady();
                this.scrollEl = await contentEl.getScrollElement();
            }
        }
        this.thresholdChanged(this.threshold);
        this.enableScrollEvents(!this.disabled);
        if (this.position === 'top') {
            this.queue.write(() => this.scrollEl && this.scrollEl.scrollToBottom(0));
        }
    }
    canStart() {
        return (!this.disabled &&
            !this.isBusy &&
            !!this.scrollEl &&
            !this.isLoading);
    }
    enableScrollEvents(shouldListen) {
        if (this.scrollEl) {
            this.enableListener(this, 'scroll', shouldListen, this.scrollEl);
        }
    }
    hostData() {
        return {
            class: {
                'infinite-scroll-loading': this.isLoading,
                'infinite-scroll-enabled': !this.disabled
            }
        };
    }
    static get is() { return "yoo-ion-infinite-scroll"; }
    static get properties() { return {
        "complete": {
            "method": true
        },
        "disabled": {
            "type": Boolean,
            "attr": "disabled",
            "watchCallbacks": ["disabledChanged"]
        },
        "el": {
            "elementRef": true
        },
        "enableListener": {
            "context": "enableListener"
        },
        "isLoading": {
            "state": true
        },
        "position": {
            "type": String,
            "attr": "position"
        },
        "queue": {
            "context": "queue"
        },
        "threshold": {
            "type": String,
            "attr": "threshold",
            "watchCallbacks": ["thresholdChanged"]
        },
        "waitFor": {
            "method": true
        }
    }; }
    static get events() { return [{
            "name": "ionInfinite",
            "method": "ionInfinite",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "scroll",
            "method": "onScroll",
            "passive": true
        }]; }
    static get style() { return "ion-infinite-scroll {\n  display: none;\n  width: 100%; }\n\n.infinite-scroll-enabled {\n  display: block; }"; }
}

class YooIonItemComponent {
    constructor() {
        /**
         * The mode determines which platform styles to use.
         * Possible values are: `"ios"` or `"md"`.
         */
        /**
         * If true, a button tag will be rendered and the item will be tappable. Defaults to `false`.
         */
        this.button = false;
        /**
         * The icon to use when `detail` is set to `true`. Defaults to `"ios-arrow-forward"`.
         */
        this.detailIcon = 'ios-arrow-forward';
        /**
         * If true, the user cannot interact with the item. Defaults to `false`.
         */
        this.disabled = false;
        this.itemStyles = {};
    }
    itemStyle(ev) {
        ev.stopPropagation();
        const tagName = ev.target.tagName;
        const updatedStyles = ev.detail;
        const updatedKeys = Object.keys(ev.detail);
        const newStyles = {};
        const childStyles = this.itemStyles[tagName] || {};
        let hasStyleChange = false;
        for (const key of updatedKeys) {
            const itemKey = `item-${key}`;
            const newValue = updatedStyles[key];
            if (newValue !== childStyles[itemKey]) {
                hasStyleChange = true;
            }
            newStyles[itemKey] = newValue;
        }
        if (hasStyleChange) {
            this.itemStyles[tagName] = newStyles;
            this.el.forceUpdate();
        }
    }
    componentDidLoad() {
        // Change the button size to small for each ion-button in the item
        // unless the size is explicitly set
        const buttons = querySelectorAllDeep(this.el, 'yoo-ion-button');
        for (let i = 0; i < buttons.length; i++) {
            if (!buttons[i].size) {
                buttons[i].size = 'small';
            }
        }
    }
    isClickable() {
        return !!(this.href || this.el.onclick || this.button);
    }
    hostData() {
        const childStyles = {};
        for (const key in this.itemStyles) {
            Object.assign(childStyles, this.itemStyles[key]);
        }
        return {
            'tappable': this.isClickable(),
            class: Object.assign({}, childStyles, getAppContext(), createColorClasses(this.color), { [`item-lines-${this.lines}`]: !!this.lines, 'item-disabled': this.disabled, 'in-list': hostContext('yoo-ion-list', this.el), 'item': true, 
                // added
                'item-ios': true })
        };
    }
    render() {
        const clickable = this.isClickable();
        const TagType = clickable ? (this.href ? 'a' : 'button') : 'div';
        const attrs = TagType === 'button' ? { type: 'button' } : { href: this.href };
        // const showDetail = this.detail !== null ? this.detail : 'ios' === 'ios' && clickable;
        return (h(TagType, Object.assign({}, attrs, { class: "item-native" }),
            h("slot", { name: "start" }),
            h("div", { class: "item-inner" },
                h("div", { class: "input-wrapper" },
                    h("slot", null)),
                h("slot", { name: "end" })),
            this.state && h("div", { class: "item-state" })));
    }
    static get is() { return "yoo-ion-item"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "button": {
            "type": Boolean,
            "attr": "button"
        },
        "color": {
            "type": String,
            "attr": "color"
        },
        "detail": {
            "type": Boolean,
            "attr": "detail"
        },
        "detailIcon": {
            "type": String,
            "attr": "detail-icon"
        },
        "disabled": {
            "type": Boolean,
            "attr": "disabled"
        },
        "el": {
            "elementRef": true
        },
        "href": {
            "type": String,
            "attr": "href"
        },
        "lines": {
            "type": String,
            "attr": "lines"
        },
        "routerDirection": {
            "type": String,
            "attr": "router-direction"
        },
        "state": {
            "type": String,
            "attr": "state"
        }
    }; }
    static get listeners() { return [{
            "name": "ionStyle",
            "method": "itemStyle"
        }]; }
    static get style() { return ":host {\n  --ion-color-contrast: #807f83;\n  --ion-color-tint: cssvar(stable-ultralight);\n  --ion-color-shade: cssvar(stable-light);\n  --transition: background-color 200ms linear;\n  --padding-start: 16px;\n  --inner-padding-end: 8px;\n  --inner-border-width: 0 0 0.55px 0;\n  --padding-entity: 0;\n  --padding-content-container-card-list: 0;\n  --margin-left-card-placeholder: 0;\n  font-family: \"Lato\" !important;\n  font-size: 17px; }\n\n:host yoo-entity {\n  --padding: var(--padding-entity); }\n\n:host yoo-card-list {\n  --padding-content-container: var(--padding-content-container-card-list); }\n\n:host yoo-card-placeholder {\n  margin-left: var(--margin-left-card-placeholder); }\n\n:host(.activated) {\n  --transition: none; }\n\n\@media screen and (orientation: landscape) {\n  .item-inner {\n    padding-left: calc(constant(safe-area-inset-left) + var(--inner-padding-start));\n    padding-right: calc(constant(safe-area-inset-right) + var(--inner-padding-end));\n    padding-left: calc(env(safe-area-inset-left) + var(--inner-padding-start));\n    padding-right: calc(env(safe-area-inset-right) + var(--inner-padding-end)); } }\n\n:host(.item-lines-full) {\n  --border-width: 0 0 0.55px 0; }\n\n:host(.item-lines-inset) {\n  --inner-border-width: 0 0 0.55px 0; }\n\n:host(.item-lines-inset),\n:host(.item-lines-none) {\n  --border-width: 0; }\n\n:host(.item-lines-full),\n:host(.item-lines-none) {\n  --inner-border-width: 0; }\n\n::slotted(:not(.interactive)[slot=\"start\"]) {\n  margin: 2px 16px 2px 0; }\n\n::slotted(:not(.interactive)[slot=\"end\"]) {\n  margin-left: 8px;\n  margin-right: 8px; }\n\n::slotted(ion-icon[slot=\"start\"]),\n::slotted(ion-icon[slot=\"end\"]) {\n  margin-left: 0;\n  margin-top: 7px;\n  margin-bottom: 7px; }\n\n:host(.item-label-stacked) ::slotted([slot=\"end\"]),\n:host(.item-label-floating) ::slotted([slot=\"end\"]) {\n  margin-top: 7px;\n  margin-bottom: 7px; }\n\n::slotted(.button-small) {\n  --padding-top: 0;\n  --padding-bottom: 0;\n  --padding-start: .5em;\n  --padding-end: .5em;\n  --height: 24px;\n  font-size: 13px; }\n\n::slotted(ion-avatar) {\n  width: 36px;\n  height: 36px; }\n\n::slotted(ion-thumbnail) {\n  width: 56px;\n  height: 56px; }\n\n::slotted(ion-avatar[slot=\"end\"]),\n::slotted(ion-thumbnail[slot=\"end\"]) {\n  margin: 8px; }\n\n.item-detail-icon {\n  color: var(--detail-push-color);\n  font-size: 20px; }\n\n:host(.item-radio) ::slotted(ion-label),\n:host(.item-toggle) ::slotted(ion-label) {\n  margin-left: 0; }\n\n:host(.item-label-stacked) ::slotted(ion-input),\n:host(.item-label-floating) ::slotted(ion-input),\n:host(.item-label-stacked) ::slotted(ion-textarea),\n:host(.item-label-floating) ::slotted(ion-textarea) {\n  --padding-top: 8px;\n  --padding-bottom: 8px;\n  --padding-start: 0; }\n\n:host {\n  --min-height: 44px;\n  --background: transparent;\n  --background-active: var(--ion-color-tint);\n  --color: var(--ion-color-contrast);\n  --detail-push-color: var(--ion-color-shade);\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: solid;\n  --border-color: var(--ion-color-shade);\n  --inner-border-width: 0;\n  --padding-top: 0;\n  --padding-bottom: 0;\n  --padding-end: 0;\n  --padding-start: 0;\n  --inner-padding-top: 0;\n  --inner-padding-bottom: 0;\n  --inner-padding-start: 0;\n  --inner-padding-end: 0;\n  --box-shadow: none;\n  --inner-box-shadow: none;\n  --highlight-color-focus: var(--ion-color-primary, #1FB6FF);\n  --highlight-color-valid: var(--ion-color-success, #04CC99);\n  --highlight-color-invalid: var(--ion-color-danger, #ff625f);\n  --highlight-height: 2px;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: block;\n  background: var(--background);\n  color: var(--ion-color-contrast);\n  text-decoration: none;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n:host(.activated) {\n  --background: var(--background-active); }\n\n:host(.item-disabled) {\n  cursor: default;\n  opacity: .3;\n  pointer-events: none; }\n\n.item-native {\n  padding: var(--padding-top) var(--padding-end) var(--padding-bottom) var(--padding-start);\n  border-radius: var(--border-radius, 1px);\n  margin: 0;\n  text-align: initial;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n  -ms-flex-align: center;\n  align-items: center;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  width: 100%;\n  min-height: var(--min-height);\n  -webkit-transition: var(--transition);\n  transition: var(--transition);\n  border-width: var(--border-width, 1px);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  outline: none;\n  background-color: var(--background);\n  color: inherit;\n  font-family: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  text-decoration: inherit;\n  text-transform: inherit;\n  -webkit-box-shadow: var(--box-shadow);\n  box-shadow: var(--box-shadow);\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\nbutton, a {\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-user-drag: none; }\n\n.item-state {\n  right: 0;\n  left: 0;\n  bottom: 0;\n  position: absolute;\n  height: var(--highlight-height); }\n\n.item-inner {\n  margin: 0;\n  padding: var(--inner-padding-top) var(--inner-padding-end) var(--inner-padding-bottom) var(--inner-padding-start);\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: inherit;\n  flex-direction: inherit;\n  -ms-flex-align: inherit;\n  align-items: inherit;\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  min-height: inherit;\n  border-width: var(--inner-border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  -webkit-box-shadow: var(--inner-box-shadow);\n  box-shadow: var(--inner-box-shadow);\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n.input-wrapper {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: inherit;\n  flex-direction: inherit;\n  -ms-flex-align: inherit;\n  align-items: inherit;\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n:host([vertical-align-top]),\n:host(.item-input) {\n  -ms-flex-align: start;\n  align-items: flex-start; }\n\n::slotted(ion-icon) {\n  font-size: 1.6em; }\n\n::slotted(ion-button) {\n  --margin-top: 0;\n  --margin-bottom: 0;\n  --margin-start: 0;\n  --margin-end: 0;\n  z-index: 1; }\n\n:host(.item-label-stacked) .input-wrapper,\n:host(.item-label-floating) .input-wrapper {\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: column;\n  flex-direction: column; }\n\n:host(.item-label-stacked)::slotted(ion-select),\n:host(.item-label-floating)::slotted(ion-select) {\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  max-width: 100%; }\n\n:host(.item-textarea) {\n  -ms-flex-align: stretch;\n  align-items: stretch; }\n\n:host(.item-multiple-inputs) ::slotted(ion-select) {\n  position: relative; }\n\n:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select) {\n  max-width: 100%; }\n\n:host(.overflow-visible) .input-wrapper {\n  overflow: visible; }\n\n:host(.overflow-visible) .item-inner {\n  overflow: visible; }\n\n:host(.overflow-visible) .item-native {\n  overflow: visible; }\n\n:host(.card-feed.web) .input-wrapper {\n  -ms-flex-pack: center;\n  justify-content: center; }\n\n::slotted(ion-reorder[slot]) {\n  margin-top: 0;\n  margin-bottom: 0; }"; }
}

class YooIonItemOptionsComponent {
    constructor() {
        /**
         * The side the option button should be on. Possible values: `"start"` and `"end"`. Defaults to `"end"`. If you have multiple `ion-item-options`, a side must be provided for each.
         *
         */
        this.side = 'end';
    }
    fireSwipeEvent() {
        this.ionSwipe.emit();
    }
    hostData() {
        const isEnd = isEndSide(window, this.side);
        return {
            class: {
                'item-options-start': !isEnd,
                'item-options-end': isEnd
            }
        };
    }
    static get is() { return "yoo-ion-item-options"; }
    static get properties() { return {
        "el": {
            "elementRef": true
        },
        "fireSwipeEvent": {
            "method": true
        },
        "side": {
            "type": String,
            "attr": "side"
        }
    }; }
    static get events() { return [{
            "name": "ionSwipe",
            "method": "ionSwipe",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  --ion-color-contrast: #807f83;\n  --ion-color-tint: cssvar(stable-ultralight);\n  --ion-color-shade: cssvar(stable-light);\n  --transition: background-color 200ms linear;\n  --padding-start: 16px;\n  --inner-padding-end: 8px;\n  --inner-border-width: 0 0 0.55px 0;\n  --padding-entity: 0;\n  --padding-content-container-card-list: 0;\n  --margin-left-card-placeholder: 0;\n  font-family: \"Lato\" !important;\n  font-size: 17px; }\n\n:host yoo-entity {\n  --padding: var(--padding-entity); }\n\n:host yoo-card-list {\n  --padding-content-container: var(--padding-content-container-card-list); }\n\n:host yoo-card-placeholder {\n  margin-left: var(--margin-left-card-placeholder); }\n\n:host(.activated) {\n  --transition: none; }\n\n\@media screen and (orientation: landscape) {\n  .item-inner {\n    padding-left: calc(constant(safe-area-inset-left) + var(--inner-padding-start));\n    padding-right: calc(constant(safe-area-inset-right) + var(--inner-padding-end));\n    padding-left: calc(env(safe-area-inset-left) + var(--inner-padding-start));\n    padding-right: calc(env(safe-area-inset-right) + var(--inner-padding-end)); } }\n\n:host(.item-lines-full) {\n  --border-width: 0 0 0.55px 0; }\n\n:host(.item-lines-inset) {\n  --inner-border-width: 0 0 0.55px 0; }\n\n:host(.item-lines-inset),\n:host(.item-lines-none) {\n  --border-width: 0; }\n\n:host(.item-lines-full),\n:host(.item-lines-none) {\n  --inner-border-width: 0; }\n\n::slotted(:not(.interactive)[slot=\"start\"]) {\n  margin: 2px 16px 2px 0; }\n\n::slotted(:not(.interactive)[slot=\"end\"]) {\n  margin-left: 8px;\n  margin-right: 8px; }\n\n::slotted(ion-icon[slot=\"start\"]),\n::slotted(ion-icon[slot=\"end\"]) {\n  margin-left: 0;\n  margin-top: 7px;\n  margin-bottom: 7px; }\n\n:host(.item-label-stacked) ::slotted([slot=\"end\"]),\n:host(.item-label-floating) ::slotted([slot=\"end\"]) {\n  margin-top: 7px;\n  margin-bottom: 7px; }\n\n::slotted(.button-small) {\n  --padding-top: 0;\n  --padding-bottom: 0;\n  --padding-start: .5em;\n  --padding-end: .5em;\n  --height: 24px;\n  font-size: 13px; }\n\n::slotted(ion-avatar) {\n  width: 36px;\n  height: 36px; }\n\n::slotted(ion-thumbnail) {\n  width: 56px;\n  height: 56px; }\n\n::slotted(ion-avatar[slot=\"end\"]),\n::slotted(ion-thumbnail[slot=\"end\"]) {\n  margin: 8px; }\n\n.item-detail-icon {\n  color: var(--detail-push-color);\n  font-size: 20px; }\n\n:host(.item-radio) ::slotted(ion-label),\n:host(.item-toggle) ::slotted(ion-label) {\n  margin-left: 0; }\n\n:host(.item-label-stacked) ::slotted(ion-input),\n:host(.item-label-floating) ::slotted(ion-input),\n:host(.item-label-stacked) ::slotted(ion-textarea),\n:host(.item-label-floating) ::slotted(ion-textarea) {\n  --padding-top: 8px;\n  --padding-bottom: 8px;\n  --padding-start: 0; }\n\n:host {\n  --min-height: 44px;\n  --background: transparent;\n  --background-active: var(--ion-color-tint);\n  --color: var(--ion-color-contrast);\n  --detail-push-color: var(--ion-color-shade);\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: solid;\n  --border-color: var(--ion-color-shade);\n  --inner-border-width: 0;\n  --padding-top: 0;\n  --padding-bottom: 0;\n  --padding-end: 0;\n  --padding-start: 0;\n  --inner-padding-top: 0;\n  --inner-padding-bottom: 0;\n  --inner-padding-start: 0;\n  --inner-padding-end: 0;\n  --box-shadow: none;\n  --inner-box-shadow: none;\n  --highlight-color-focus: var(--ion-color-primary, #1FB6FF);\n  --highlight-color-valid: var(--ion-color-success, #04CC99);\n  --highlight-color-invalid: var(--ion-color-danger, #ff625f);\n  --highlight-height: 2px;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: block;\n  background: var(--background);\n  color: var(--ion-color-contrast);\n  text-decoration: none;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n:host(.activated) {\n  --background: var(--background-active); }\n\n:host(.item-disabled) {\n  cursor: default;\n  opacity: .3;\n  pointer-events: none; }\n\n.item-native {\n  padding: var(--padding-top) var(--padding-end) var(--padding-bottom) var(--padding-start);\n  border-radius: var(--border-radius, 1px);\n  margin: 0;\n  text-align: initial;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n  -ms-flex-align: center;\n  align-items: center;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  width: 100%;\n  min-height: var(--min-height);\n  -webkit-transition: var(--transition);\n  transition: var(--transition);\n  border-width: var(--border-width, 1px);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  outline: none;\n  background-color: var(--background);\n  color: inherit;\n  font-family: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  text-decoration: inherit;\n  text-transform: inherit;\n  -webkit-box-shadow: var(--box-shadow);\n  box-shadow: var(--box-shadow);\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\nbutton, a {\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-user-drag: none; }\n\n.item-state {\n  right: 0;\n  left: 0;\n  bottom: 0;\n  position: absolute;\n  height: var(--highlight-height); }\n\n.item-inner {\n  margin: 0;\n  padding: var(--inner-padding-top) var(--inner-padding-end) var(--inner-padding-bottom) var(--inner-padding-start);\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: inherit;\n  flex-direction: inherit;\n  -ms-flex-align: inherit;\n  align-items: inherit;\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  min-height: inherit;\n  border-width: var(--inner-border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  -webkit-box-shadow: var(--inner-box-shadow);\n  box-shadow: var(--inner-box-shadow);\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n.input-wrapper {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: inherit;\n  flex-direction: inherit;\n  -ms-flex-align: inherit;\n  align-items: inherit;\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n\n:host([vertical-align-top]),\n:host(.item-input) {\n  -ms-flex-align: start;\n  align-items: flex-start; }\n\n::slotted(ion-icon) {\n  font-size: 1.6em; }\n\n::slotted(ion-button) {\n  --margin-top: 0;\n  --margin-bottom: 0;\n  --margin-start: 0;\n  --margin-end: 0;\n  z-index: 1; }\n\n:host(.item-label-stacked) .input-wrapper,\n:host(.item-label-floating) .input-wrapper {\n  -ms-flex: 1;\n  flex: 1;\n  -ms-flex-direction: column;\n  flex-direction: column; }\n\n:host(.item-label-stacked)::slotted(ion-select),\n:host(.item-label-floating)::slotted(ion-select) {\n  -ms-flex-item-align: stretch;\n  align-self: stretch;\n  max-width: 100%; }\n\n:host(.item-textarea) {\n  -ms-flex-align: stretch;\n  align-items: stretch; }\n\n:host(.item-multiple-inputs) ::slotted(ion-select) {\n  position: relative; }\n\n:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select) {\n  max-width: 100%; }\n\n:host(.overflow-visible) .input-wrapper {\n  overflow: visible; }\n\n:host(.overflow-visible) .item-inner {\n  overflow: visible; }\n\n:host(.overflow-visible) .item-native {\n  overflow: visible; }\n\n:host(.card-feed.web) .input-wrapper {\n  -ms-flex-pack: center;\n  justify-content: center; }\n\n::slotted(ion-reorder[slot]) {\n  margin-top: 0;\n  margin-bottom: 0; }\n\n.item-options-ios {\n  border-bottom-width: 0;\n  border-bottom-style: solid;\n  border-bottom-color: cssvar(stable-light); }\n  .item-options-ios.item-options-end {\n    border-bottom-width: 0.55px; }\n\n.list-ios-lines-none .item-options-ios {\n  border-bottom-width: 0; }\n\n.list-ios-lines-full .item-options-ios,\n.list-ios-lines-inset .item-options-ios.item-options-end {\n  border-bottom-width: 0.55px; }\n\nyoo-ion-item-options {\n  top: 0;\n  right: 0;\n  -ms-flex-pack: end;\n  justify-content: flex-end;\n  display: none;\n  position: absolute;\n  height: 100%;\n  font-size: 14px;\n  z-index: 1; }\n\n.item-options-start {\n  right: auto;\n  left: 0;\n  -ms-flex-pack: start;\n  justify-content: flex-start; }\n\n.item-sliding-active-slide yoo-ion-item-options {\n  display: -ms-flexbox;\n  display: flex; }\n\n.item-sliding-active-slide.item-sliding-active-options-start .item-options-start,\n.item-sliding-active-slide.item-sliding-active-options-end yoo-ion-item-options:not(.item-options-start) {\n  width: 100%;\n  visibility: visible; }\n\nyoo-ion-item-options.visible {\n  display: -ms-flexbox;\n  display: flex;\n  width: 100%;\n  visibility: visible;\n  z-index: 10; }"; }
}

const SWIPE_MARGIN = 30;
const ELASTIC_FACTOR = 0.55;
class YooIonItemSlidingComponent {
    constructor() {
        this.slidingType = ItemSlidingType.swipe;
        this.state = 2 /* Disabled */;
        this.item = null; //HTMLYooIonItemElement|null = null;
        this.list = null; //HTMLYooIonListElement|null = null;
        this.openAmount = 0;
        this.initialOpenAmount = 0;
        this.optsWidthRightSide = 0;
        this.optsWidthLeftSide = 0;
        this.sides = 0 /* None */;
        this.optsDirty = true;
    }
    /**
     * Get the amount the item is open in pixels.
     */
    getOpenAmount() {
        return Promise.resolve(this.openAmount);
    }
    /**
     * Get the ratio of the open amount of the item compared to the width of the options.
     * If the number returned is positive, then the options on the right side are open.
     * If the number returned is negative, then the options on the left side are open.
     * If the absolute value of the number is greater than 1, the item is open more than
     * the width of the options.
     */
    getSlidingRatio() {
        return Promise.resolve(this.getSlidingRatioSync());
    }
    /**
     * Close the sliding item. Items can also be closed from the [List](../../list/List).
     */
    close() {
        this.setOpenAmount(0, true);
    }
    updateOptions() {
        const options = querySelectorAllDeep(this.el, 'yoo-ion-item-options');
        let sides = 0;
        // Reset left and right options in case they were removed
        this.leftOptions = this.rightOptions = undefined;
        for (let i = 0; i < options.length; i++) {
            const option = options.item(i);
            if (option.side === 'end') {
                this.rightOptions = option;
                sides |= 2 /* End */;
            }
            else {
                this.leftOptions = option;
                sides |= 1 /* Start */;
            }
        }
        this.optsDirty = true;
        this.sides = sides;
    }
    componentDidLoad() {
        this.item = querySelectorDeep(this.el, 'yoo-ion-item');
        this.list = findParent(this.el, 'yoo-ion-list');
        this.updateOptions();
    }
    componentDidUnload() {
        this.item = this.list = null;
        this.leftOptions = this.rightOptions = undefined;
    }
    getSlidingRatioSync() {
        if (this.openAmount > 0) {
            return this.openAmount / this.optsWidthRightSide;
        }
        else if (this.openAmount < 0) {
            return this.openAmount / this.optsWidthLeftSide;
        }
        else {
            return 0;
        }
    }
    /**
     * Close all of the sliding items in the list. Items can also be closed from the [List](../../list/List).
     */
    async closeOpened() {
        if (this.list) {
            let closeItems = await this.list.closeSlidingItems();
            return !!(closeItems);
        }
    }
    async canStart() {
        let selected;
        if (this.list) {
            selected = await this.list.getOpenItem();
        }
        if (selected && selected !== this.el) {
            this.closeOpened();
            return false;
        }
        return true;
    }
    onDragStart() {
        // tslint:disable-next-line:no-unused-expression
        this.list && this.list.setOpenItem(this.el);
        if (this.tmr) {
            clearTimeout(this.tmr);
            this.tmr = undefined;
        }
        if (this.openAmount === 0) {
            this.optsDirty = true;
            this.state = 4 /* Enabled */;
        }
        this.initialOpenAmount = this.openAmount;
        if (this.item) {
            this.item.style.transition = 'none';
        }
    }
    onDragMove(gesture) {
        if (this.optsDirty) {
            this.calculateOptsWidth();
        }
        let openAmount = this.initialOpenAmount - gesture.deltaX;
        switch (this.sides) {
            case 2 /* End */:
                openAmount = Math.max(0, openAmount);
                break;
            case 1 /* Start */:
                openAmount = Math.min(0, openAmount);
                break;
            case 3 /* Both */: break;
            case 0 /* None */: return;
            default:
                console.warn('invalid ItemSideFlags value', this.sides);
                break;
        }
        let optsWidth;
        if (openAmount > this.optsWidthRightSide) {
            optsWidth = this.optsWidthRightSide;
            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        }
        else if (openAmount < -this.optsWidthLeftSide) {
            optsWidth = -this.optsWidthLeftSide;
            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        }
        this.setOpenAmount(openAmount, false);
    }
    onDragEnd(gesture) {
        const velocity = gesture.velocityX;
        let restingPoint = (this.openAmount > 0)
            ? this.optsWidthRightSide
            : -this.optsWidthLeftSide;
        // Check if the drag didn't clear the buttons mid-point
        // and we aren't moving fast enough to swipe open
        const isResetDirection = (this.openAmount > 0) === !(velocity < 0);
        const isMovingFast = Math.abs(velocity) > 0.3;
        const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);
        if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {
            restingPoint = 0;
        }
        this.setOpenAmount(restingPoint, true);
        if (this.state & 32 /* SwipeEnd */ && this.rightOptions) {
            this.rightOptions.fireSwipeEvent();
        }
        else if (this.state & 64 /* SwipeStart */ && this.leftOptions) {
            this.leftOptions.fireSwipeEvent();
        }
    }
    calculateOptsWidth() {
        this.optsWidthRightSide = 0;
        if (this.rightOptions) {
            this.optsWidthRightSide = this.rightOptions.offsetWidth;
        }
        this.optsWidthLeftSide = 0;
        if (this.leftOptions) {
            this.optsWidthLeftSide = this.leftOptions.offsetWidth;
        }
        this.optsDirty = false;
    }
    setOpenAmount(openAmount, isFinal) {
        if (this.tmr) {
            clearTimeout(this.tmr);
            this.tmr = undefined;
        }
        if (!this.item) {
            return;
        }
        const style = this.item.style;
        this.openAmount = openAmount;
        if (isFinal) {
            style.transition = '';
        }
        if (openAmount > 0) {
            this.state = (openAmount >= (this.optsWidthRightSide + SWIPE_MARGIN))
                ? 8 /* End */ | 32 /* SwipeEnd */
                : 8 /* End */;
        }
        else if (openAmount < 0) {
            this.state = (openAmount <= (-this.optsWidthLeftSide - SWIPE_MARGIN))
                ? 16 /* Start */ | 64 /* SwipeStart */
                : 16 /* Start */;
        }
        else {
            this.tmr = window.setTimeout(() => {
                this.state = 2 /* Disabled */;
                this.tmr = undefined;
            }, 600);
            // tslint:disable-next-line:no-unused-expression
            this.list && this.list.setOpenItem(undefined);
            style.transform = '';
            return;
        }
        style.transform = `translate3d(${-openAmount}px,0,0)`;
        this.ionDrag.emit({
            amount: openAmount
        });
    }
    onHoverElement(enter) {
        const option = querySelectorDeep(this.el, 'yoo-ion-item-options');
        if (option) {
            if (enter) {
                option.classList.add('visible');
            }
            else {
                option.classList.remove('visible');
            }
        }
    }
    renderSwipe() {
        return (h("yoo-ion-gesture", { canStart: this.canStart.bind(this), onStart: this.onDragStart.bind(this), onMove: this.onDragMove.bind(this), onEnd: this.onDragEnd.bind(this), gestureName: 'item-swipe', gesturePriority: 10, direction: 'x', maxAngle: 20, threshold: 5, attachTo: 'parent' },
            h("slot", null)));
    }
    renderHover() {
        return (h("div", { class: "hover-container", onMouseLeave: () => this.onHoverElement(false), onMouseEnter: () => this.onHoverElement(true) },
            h("slot", null)));
    }
    hostData() {
        return {
            class: Object.assign({ 'item-sliding': true, 'item-sliding-active-slide': (this.state !== 2 /* Disabled */), 'item-sliding-active-options-end': !!(this.state & 8 /* End */), 'item-sliding-active-options-start': !!(this.state & 16 /* Start */), 'item-sliding-active-swipe-end': !!(this.state & 32 /* SwipeEnd */), 'item-sliding-active-swipe-start': !!(this.state & 64 /* SwipeStart */) }, getAppContext())
        };
    }
    render() {
        switch (this.slidingType) {
            case ItemSlidingType.swipe:
                return this.renderSwipe();
            case ItemSlidingType.hover:
                return this.renderHover();
        }
    }
    static get is() { return "yoo-ion-item-sliding"; }
    static get properties() { return {
        "close": {
            "method": true
        },
        "el": {
            "elementRef": true
        },
        "getOpenAmount": {
            "method": true
        },
        "getSlidingRatio": {
            "method": true
        },
        "slidingType": {
            "type": String,
            "attr": "sliding-type"
        },
        "state": {
            "state": true
        },
        "updateOptions": {
            "method": true
        }
    }; }
    static get events() { return [{
            "name": "ionDrag",
            "method": "ionDrag",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return "yoo-ion-item-sliding {\n  display: block;\n  position: relative;\n  width: 100%;\n  overflow: hidden; }\n  yoo-ion-item-sliding.web {\n    overflow: visible; }\n\nyoo-ion-item {\n  --background: var(--ion-color-light, #FFFFFF); }\n\nion-item-sliding .item {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none; }\n\n.item-sliding-active-slide .item {\n  position: relative;\n  -webkit-transition: -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);\n  transition: -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);\n  transition: transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);\n  transition: transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);\n  background: cssvar(light);\n  opacity: 1;\n  z-index: 2;\n  pointer-events: none;\n  will-change: transform; }\n\n.item-sliding-active-swipe-end .item-options-end .item-option-expandable {\n  padding-left: 90%;\n  -ms-flex-order: 1;\n  order: 1;\n  -webkit-transition-duration: .6s;\n  transition-duration: .6s;\n  -webkit-transition-property: padding-left;\n  transition-property: padding-left; }\n\n.item-sliding-active-swipe-start .item-options-start .item-option-expandable {\n  padding-right: 90%;\n  -ms-flex-order: -1;\n  order: -1;\n  -webkit-transition-duration: .6s;\n  transition-duration: .6s;\n  -webkit-transition-property: padding-right;\n  transition-property: padding-right; }"; }
}
/** @hidden */
function swipeShouldReset(isResetDirection, isMovingFast, isOnResetZone) {
    // The logic required to know when the sliding item should close (openAmount=0)
    // depends on three booleans (isCloseDirection, isMovingFast, isOnCloseZone)
    // and it ended up being too complicated to be written manually without errors
    // so the truth table is attached below: (0=false, 1=true)
    // isCloseDirection | isMovingFast | isOnCloseZone || shouldClose
    //         0        |       0      |       0       ||    0
    //         0        |       0      |       1       ||    1
    //         0        |       1      |       0       ||    0
    //         0        |       1      |       1       ||    0
    //         1        |       0      |       0       ||    0
    //         1        |       0      |       1       ||    1
    //         1        |       1      |       0       ||    1
    //         1        |       1      |       1       ||    1
    // The resulting expression was generated by resolving the K-map (Karnaugh map):
    return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);
}

class YooIonListComponent {
    constructor() {
        /**
         * If true, the list will have margin around it and rounded corners. Defaults to `false`.
         */
        this.inset = false;
    }
    /**
     * Get the [Item Sliding](../../item-sliding/ItemSliding) that is currently open.
     */
    async getOpenItem() {
        return this.openItem;
    }
    /**
     * Set an [Item Sliding](../../item-sliding/ItemSliding) as the open item.
     */
    setOpenItem(itemSliding) {
        this.openItem = itemSliding;
    }
    /**
     * Close the sliding items. Items can also be closed from the [Item Sliding](../../item-sliding/ItemSliding).
     * Returns a boolean value of whether it closed an item or not.
     */
    async closeSlidingItems() {
        if (this.openItem) {
            this.openItem.close();
            this.openItem = undefined;
            return true;
        }
        return false;
    }
    hostData() {
        return {
            class: Object.assign({ [`list-lines-${this.lines}`]: !!this.lines, 'list-inset': this.inset, [`list-${'ios'}-lines-${this.lines}`]: !!this.lines }, getAppContext())
        };
    }
    static get is() { return "yoo-ion-list"; }
    static get properties() { return {
        "closeSlidingItems": {
            "method": true
        },
        "getOpenItem": {
            "method": true
        },
        "inset": {
            "type": Boolean,
            "attr": "inset"
        },
        "lines": {
            "type": String,
            "attr": "lines"
        },
        "setOpenItem": {
            "method": true
        }
    }; }
    static get style() { return ".list-ios.list-inset {\n  margin: 16px;\n  border-radius: 4px; }\n\n.list-ios.list-inset ion-item {\n  --border-width: 0 0 1px 0;\n  --inner-border-width: 0; }\n\n.list-ios.list-inset ion-item:last-child {\n  --border-width: 0;\n  --inner-border-width: 0; }\n\n.list-ios.list-inset + ion-list.list-inset {\n  margin-top: 0; }\n\n.list-ios-lines-none .item {\n  --border-width: 0;\n  --inner-border-width: 0; }\n\n.list-ios-lines-full .item,\n.list-ios .item-lines-full {\n  --border-width: 0 0 0.55px 0; }\n\n.list-ios-lines-full .item {\n  --inner-border-width: 0; }\n\n.list-ios-lines-inset .item,\n.list-ios .item-lines-inset {\n  --inner-border-width: 0 0 0.55px 0; }\n\n.list-ios .item-lines-inset {\n  --border-width: 0; }\n\n.list-ios .item-lines-full {\n  --inner-border-width: 0; }\n\n.list-ios:not(.list-inset):not(.list-ios-lines-none) .item:last-child {\n  --inner-border-width: 0;\n  --border-width: 0 0 0.55px 0; }\n\n.card-list yoo-ion-item {\n  --background: var(--ion-item-backgrond-color); }\n\n.web-photos-tab {\n  -ms-flex-item-align: center;\n  align-self: center;\n  max-width: 25rem; }\n  .web-photos-tab yoo-ion-item {\n    padding: 0.5rem 0; }"; }
}

class YooIonRefresherComponent {
    constructor() {
        // mode!: Mode;
        /**
         * The minimum distance the user must pull down until the
         * refresher will go into the `refreshing` state. Defaults to `60`.
         */
        this.pullMin = 60;
        /**
         * The maximum distance of the pull until the refresher
         * will automatically go into the `refreshing` state.
         * Defaults to the result of `pullMin + 60`.
         */
        this.pullMax = this.pullMin + 60;
        /**
         * Time it takes to close the refresher. Defaults to `280ms`.
         */
        this.closeDuration = '280ms';
        /**
         * Time it takes the refresher to to snap back to the `refreshing` state. Defaults to `280ms`.
         */
        this.snapbackDuration = '280ms';
        /**
         * If true, the refresher will be hidden. Defaults to `true`.
         */
        this.disabled = true;
        /**
         * The current state which the refresher is in. The refresher's states include:
         *
         * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.
         * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.
         * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.
         * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.
         * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.
         * - `completing` - The `refreshing` state has finished and the refresher is in the process of closing itself. Once closed, the refresher will go back to the `inactive` state.
         */
        this.state = 1 /* Inactive */; //private was removed
        this.appliedStyles = false;
        this.didStart = false;
        this.progress = 0;
    }
    /**
    * Call `complete()` when your async operation has completed.
    * For example, the `refreshing` state is while the app is performing
    * an asynchronous operation, such as receiving more data from an
    * AJAX request. Once the data has been received, you then call this
    * method to signify that the refreshing has completed and to close
    * the refresher. This method also changes the refresher's state from
    * `refreshing` to `completing`.
    */
    complete() {
        this.close(32 /* Completing */, '120ms');
    }
    /**
     * Changes the refresher's state from `refreshing` to `cancelling`.
     */
    cancel() {
        this.close(16 /* Cancelling */, '');
    }
    /**
     * A number representing how far down the user has pulled.
     * The number `0` represents the user hasn't pulled down at all. The
     * number `1`, and anything greater than `1`, represents that the user
     * has pulled far enough down that when they let go then the refresh will
     * happen. If they let go and the number is less than `1`, then the
     * refresh will not happen, and the content will return to it's original
     * position.
     */
    getProgress() {
        return Promise.resolve(this.progress);
    }
    async componentDidLoad() {
        if (this.el.getAttribute('slot') !== 'fixed') {
            // tslint:disable-next-line:no-console
            console.error('Make sure you use: ion-refresher slot="fixed">');
            return;
        }
        const contentEl = findParent(this.el, 'yoo-ion-content');
        if (contentEl) {
            await contentEl.componentOnReady();
            this.scrollEl = await contentEl.getScrollElement();
        }
        else {
            this.scrollEl = findParent(this.el, 'yoo-ion-scroll');
        }
    }
    componentDidUnload() {
        this.scrollEl = undefined;
    }
    canStart() {
        if (!this.scrollEl) {
            return false;
        }
        if (this.state !== 1 /* Inactive */) {
            return false;
        }
        // if the scrollTop is greater than zero then it's
        // not possible to pull the content down yet
        if (this.scrollEl.scrollTop > 0) {
            return false;
        }
        return true;
    }
    onStart() {
        this.progress = 0;
        this.state = 1 /* Inactive */;
    }
    onMove(detail) {
        if (!this.scrollEl) {
            return 0;
        }
        // this method can get called like a bazillion times per second,
        // so it's built to be as efficient as possible, and does its
        // best to do any DOM read/writes only when absolutely necessary
        // if multitouch then get out immediately
        const ev = detail.event;
        if (ev.touches && ev.touches.length > 1) {
            return 1;
        }
        // do nothing if it's actively refreshing
        // or it's in the process of closing
        // or this was never a startY
        if (this.state & 56 /* _BUSY_ */) {
            return 2;
        }
        const deltaY = detail.deltaY;
        // don't bother if they're scrolling up
        // and have not already started dragging
        if (deltaY <= 0) {
            // the current Y is higher than the starting Y
            // so they scrolled up enough to be ignored
            this.progress = 0;
            this.state = 1 /* Inactive */;
            if (this.appliedStyles) {
                // reset the styles only if they were applied
                this.setCss(0, '', false, '');
                return 5;
            }
            return 6;
        }
        if (this.state === 1 /* Inactive */) {
            // this refresh is not already actively pulling down
            // get the content's scrollTop
            const scrollHostScrollTop = this.scrollEl.scrollTop;
            // if the scrollTop is greater than zero then it's
            // not possible to pull the content down yet
            if (scrollHostScrollTop > 0) {
                this.progress = 0;
                return 7;
            }
            // content scrolled all the way to the top, and dragging down
            this.state = 2 /* Pulling */;
        }
        // prevent native scroll events
        ev.preventDefault();
        // the refresher is actively pulling at this point
        // move the scroll element within the content element
        this.setCss(deltaY, '0ms', true, '');
        if (!deltaY) {
            // don't continue if there's no delta yet
            this.progress = 0;
            return 8;
        }
        const pullMin = this.pullMin;
        // set pull progress
        this.progress = deltaY / pullMin;
        // emit "start" if it hasn't started yet
        if (!this.didStart) {
            this.didStart = true;
            this.ionStart.emit();
        }
        // emit "pulling" on every move
        this.ionPull.emit();
        // do nothing if the delta is less than the pull threshold
        if (deltaY < pullMin) {
            // ensure it stays in the pulling state, cuz its not ready yet
            this.state = 2 /* Pulling */;
            return 2;
        }
        if (deltaY > this.pullMax) {
            // they pulled farther than the max, so kick off the refresh
            this.beginRefresh();
            return 3;
        }
        // pulled farther than the pull min!!
        // it is now in the `ready` state!!
        // if they let go then it'll refresh, kerpow!!
        this.state = 4 /* Ready */;
        return 4;
    }
    onEnd() {
        // only run in a zone when absolutely necessary
        if (this.state === 4 /* Ready */) {
            // they pulled down far enough, so it's ready to refresh
            this.beginRefresh();
        }
        else if (this.state === 2 /* Pulling */) {
            // they were pulling down, but didn't pull down far enough
            // set the content back to it's original location
            // and close the refresher
            // set that the refresh is actively cancelling
            this.cancel();
        }
    }
    beginRefresh() {
        // assumes we're already back in a zone
        // they pulled down far enough, so it's ready to refresh
        this.state = 8 /* Refreshing */;
        // place the content in a hangout position while it thinks
        this.setCss(this.pullMin, this.snapbackDuration, true, '');
        // emit "refresh" because it was pulled down far enough
        // and they let go to begin refreshing
        this.ionRefresh.emit();
    }
    close(state, delay) {
        // create fallback timer incase something goes wrong with transitionEnd event
        setTimeout(() => {
            this.state = 1 /* Inactive */;
            this.progress = 0;
            this.didStart = false;
            this.setCss(0, '0.3s', false, '');
        }, 600);
        // reset set the styles on the scroll element
        // set that the refresh is actively cancelling/completing
        this.state = state;
        this.setCss(0, '0.3s', true, delay);
    }
    setCss(y, duration, overflowVisible, delay) {
        this.appliedStyles = (y > 0);
        this.queue.write(() => {
            if (this.scrollEl) {
                const style = this.scrollEl.style;
                style.transform = ((y > 0) ? 'translateY(' + y + 'px) translateZ(0px)' : 'translateZ(0px)');
                style.transitionDuration = duration;
                style.transitionDelay = delay;
                style.overflow = (overflowVisible ? 'hidden' : '');
            }
        });
    }
    hostData() {
        return {
            slot: 'fixed',
            class: {
                // ...createThemedClasses(this.mode, 'refresher'),
                'refresher-active': this.state !== 1 /* Inactive */,
                'refresher-pulling': this.state === 2 /* Pulling */,
                'refresher-ready': this.state === 4 /* Ready */,
                'refresher-refreshing': this.state === 8 /* Refreshing */,
                'refresher-cancelling': this.state === 16 /* Cancelling */,
                'refresher-completing': this.state === 32 /* Completing */
            }
        };
    }
    render() {
        return h("yoo-ion-gesture", { canStart: this.canStart.bind(this), onStart: this.onStart.bind(this), onMove: this.onMove.bind(this), onEnd: this.onEnd.bind(this), gestureName: "refresher", gesturePriority: 10, passive: false, direction: "y", threshold: 5, attachTo: findParent(this.el, 'yoo-ion-content'), disabled: this.disabled },
            h("slot", null));
    }
    static get is() { return "yoo-ion-refresher"; }
    static get properties() { return {
        "cancel": {
            "method": true
        },
        "closeDuration": {
            "type": String,
            "attr": "close-duration"
        },
        "complete": {
            "method": true
        },
        "disabled": {
            "type": Boolean,
            "attr": "disabled"
        },
        "el": {
            "elementRef": true
        },
        "getProgress": {
            "method": true
        },
        "pullMax": {
            "type": Number,
            "attr": "pull-max"
        },
        "pullMin": {
            "type": Number,
            "attr": "pull-min"
        },
        "queue": {
            "context": "queue"
        },
        "snapbackDuration": {
            "type": String,
            "attr": "snapback-duration"
        },
        "state": {
            "state": true
        }
    }; }
    static get events() { return [{
            "name": "ionRefresh",
            "method": "ionRefresh",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "ionPull",
            "method": "ionPull",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "ionStart",
            "method": "ionStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return "yoo-ion-refresher {\n  left: 0;\n  top: 0;\n  display: none;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  height: 60px;\n  z-index: 0; }\n  yoo-ion-refresher.refresher-active {\n    display: block; }\n  yoo-ion-refresher.transparent yoo-ion-refresher-content {\n    background-color: transparent; }\n\nyoo-ion-refresher-content {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  -ms-flex-pack: center;\n  justify-content: center;\n  height: 100%;\n  background-color: var(--light-card-background, #FFFFFF); }\n\n.refresher-pulling,\n.refresher-refreshing {\n  display: none;\n  width: 100%; }\n\n.refresher-pulling-icon,\n.refresher-refreshing-icon {\n  -webkit-transform-origin: center;\n  transform-origin: center;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  -ms-flex-align: center;\n  align-items: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-transition: 200ms;\n  transition: 200ms;\n  font-size: 30px;\n  text-align: center; }\n\n.refresher-pulling-text,\n.refresher-refreshing-text {\n  font-size: 16px;\n  text-align: center; }\n\n.refresher-pulling yoo-ion-refresher-content .refresher-pulling {\n  display: block; }\n\n.refresher-ready yoo-ion-refresher-content .refresher-pulling {\n  display: block; }\n\n.refresher-ready yoo-ion-refresher-content .refresher-pulling-icon {\n  -webkit-transform: rotate(180deg);\n  transform: rotate(180deg); }\n\n.refresher-refreshing yoo-ion-refresher-content .refresher-refreshing {\n  display: block; }\n\n.refresher-cancelling yoo-ion-refresher-content .refresher-pulling {\n  display: block; }\n\n.refresher-cancelling yoo-ion-refresher-content .refresher-pulling-icon {\n  -webkit-transform: scale(0);\n  transform: scale(0); }\n\n.refresher-completing yoo-ion-refresher-content .refresher-refreshing {\n  display: block; }\n\n.refresher-completing yoo-ion-refresher-content .refresher-refreshing-icon {\n  -webkit-transform: scale(0);\n  transform: scale(0); }\n\n.refresher-ios .refresher-pulling-icon,\n.refresher-ios .refresher-refreshing-icon {\n  color: #807f83; }\n\n.refresher-ios .refresher-pulling-text,\n.refresher-ios .refresher-refreshing-text {\n  color: #807f83; }\n\n.refresher-ios .refresher-refreshing .spinner-lines-ios line,\n.refresher-ios .refresher-refreshing .spinner-lines-small-ios line,\n.refresher-ios .refresher-refreshing .spinner-crescent circle {\n  stroke: #807f83; }\n\n.refresher-ios .refresher-refreshing .spinner-bubbles circle,\n.refresher-ios .refresher-refreshing .spinner-circles circle,\n.refresher-ios .refresher-refreshing .spinner-dots circle {\n  fill: #807f83; }\n\n.refresher-pulling-icon yoo-icon {\n  font-size: var(--font-s, 13px); }\n\n.refresher-refreshing-icon img {\n  width: 25px; }"; }
}

class YooIonRefresherContentComponent {
    render() {
        return [
            h("div", { class: "refresher-pulling" },
                h("div", { class: "refresher-pulling-icon" },
                    h("yoo-icon", { class: "yo-pull-to-refresh" })),
                this.pullingText &&
                    h("div", { class: "refresher-pulling-text", innerHTML: this.pullingText })),
            h("div", { class: "refresher-refreshing" },
                h("div", { class: "refresher-refreshing-icon" }, getAppContext()['boost'] ? h("img", { src: "assets/loader/loading_thin_boost.svg" }) : h("img", { src: "assets/loader/loading_thin.svg" })),
                this.refreshingText &&
                    h("div", { class: "refresher-refreshing-text", innerHTML: this.refreshingText }))
        ];
    }
    static get is() { return "yoo-ion-refresher-content"; }
    static get properties() { return {
        "pullingText": {
            "type": String,
            "attr": "pulling-text"
        },
        "refreshingText": {
            "type": String,
            "attr": "refreshing-text"
        }
    }; }
}

const DROPDOWN_WIDTH = 40;
const ANIMATION_LOAD_TIME = 200;
class YooNavbarComponent {
    constructor() {
        this.withLine = false;
        this.swipeableIndicator = false;
        this.scrollTabs = false;
        this.slidesOffsetBefore = 0;
        this.reduceFontSize = 10;
        this.showDropdown = false;
        this.loading = true;
        this.elementWidths = [];
        this.scrollByUser = true;
        this.currentScroll = 0;
        this.innerContainers = [];
    }
    onSelectedSwipeIndexChange(newIndex) {
        if (newIndex >= 0) {
            this.navSlides.slideTo(newIndex);
        }
    }
    checkSelectedTab() {
        if (!this.selectedTab) {
            this.setSelectedTab(this.tabs[0]);
            this.selectedTabIndex = 0;
        }
        else {
            this.selectedTabIndex = this.tabs.indexOf(this.selectedTab);
        }
        this.numberOfVisibleItems = this.tabs.length;
    }
    async onSelectScrollTab(tab, index) {
        const isToRight = (index > this.selectedTabIndex);
        const previousIndex = this.selectedTabIndex;
        if (this.selectedTab && this.selectedTab.value !== tab.value) {
            if (this.host.classList.contains('swipeable') && this.navSlides) {
                let activeIndex = await this.navSlides.getActiveIndex();
                index = activeIndex;
            }
            this.setSelectedTab(tab);
            this.selectedTabIndex = index;
            this.tabSelectedIsToRight.emit(isToRight);
        }
        if (this.elementWidths && this.elementWidths[index] && !this.host.classList.contains('swipeable')) {
            this.scrollToTab(this.getElementWidth(index, true), this.getElementWidth(index), isToRight, index, previousIndex);
        }
    }
    onScrollTabChanged() {
        setTimeout(() => {
            if (this.selectedTabIndex > 0) {
                this.onSelectScrollTab(this.selectedTab, this.selectedTabIndex);
            }
        }, ANIMATION_LOAD_TIME);
    }
    setActive(i) {
        this.setSelectedTab(this.tabs[i]);
        this.selectedTabIndex = i;
        this.numberOfVisibleItems = this.tabs.length;
    }
    getActiveIndex() {
        return Promise.resolve(this.tabs.indexOf(this.selectedTab));
    }
    componentWillLoad() {
        if (this.tabs) {
            this.checkSelectedTab();
        }
    }
    componentDidLoad() {
        this.elementWidths = this.width;
        setTimeout(() => {
            this.elementWidths = this.width;
            this.hostWidth = getElementDimensions(this.host).width;
            this.resizePage();
            this.setSlideOffset();
            this.loading = false;
        }, ANIMATION_LOAD_TIME);
        this.resizeListener = debounce$2(this.resizePage, 500).bind(this);
        window.addEventListener('resize', this.resizeListener);
    }
    componentDidUnload() {
        window.removeEventListener('resize', this.resizeListener);
    }
    setSelectedTab(tab) {
        if (!this.selectedTab || this.selectedTab.value !== tab.value) {
            this.selectedTab = tab;
            this.tabSelected.emit(tab);
        }
    }
    get dropDownWidth() {
        return this.activeTitleInDropdown ? this.getElementWidth(this.selectedTabIndex) + 20 : DROPDOWN_WIDTH;
    }
    get width() {
        let elementWidth = 0;
        let tabs = Array.from(querySelectorAllDeep(this.host, '.inner-container'));
        let width = tabs.map(tab => {
            elementWidth += tab.clientWidth;
            return { width: tab.clientWidth, accumulatedWidth: elementWidth };
        });
        return width;
    }
    get activeTitleInDropdown() {
        return this.tabs.slice(0, this.numberOfVisibleItems).findIndex(i => i === this.selectedTab) < 0;
    }
    getElementWidth(index, accumulatedWidth = false) {
        let elementWidth = this.elementWidths[index];
        if (elementWidth) {
            if (accumulatedWidth) {
                return elementWidth.accumulatedWidth;
            }
            else {
                return elementWidth.width;
            }
        }
        else {
            return 0;
        }
    }
    async onIonSlideDidChange() {
        let activeIndex = await this.navSlides.getActiveIndex();
        this.setSelectedTab(this.tabs[activeIndex]);
    }
    setSlideOffset() {
        const HALF_SLIDE_WIDTH = window.innerWidth * 0.2;
        this.slidesOffsetBefore = (this.hostWidth / 2) - HALF_SLIDE_WIDTH;
    }
    onSelectSwipeableTab(index) {
        this.navSlides.slideTo(index, 300);
    }
    onSelectTab(tab, index) {
        if (this.host.classList.contains('swipeable')) {
            this.onSelectSwipeableTab(index);
        }
        else {
            this.onSelectScrollTab(tab, index);
        }
    }
    scrollToTab(tabPosition, tabWidth, isToRight, index, previousIndex) {
        this.scrollByUser = false;
        let tabs = Array.from(querySelectorAllDeep(this.host, '.inner-container'));
        this.applyTabStyles(true, tabs);
        this.activeBarWidth = this.getElementWidth(index);
        if (this.activeBar) {
            this.activeBar.setAttribute('style', `display: block;`);
        }
        const PADDING = 40;
        let maxNavbarPosition = this.currentScroll + this.hostWidth;
        let minNavbarPosition = this.currentScroll;
        if (this.scroll) {
            if (tabPosition > maxNavbarPosition) {
                let newScrollPosition = (tabPosition - maxNavbarPosition) + this.currentScroll + PADDING;
                this.scroll.scrollToPoint(newScrollPosition, 0, 500);
                this.scrollActiveBar((PADDING + (tabPosition - maxNavbarPosition)), index, previousIndex);
            }
            else if ((tabPosition - tabWidth) < minNavbarPosition) {
                let newScrollPosition = this.currentScroll - (minNavbarPosition - (tabPosition - tabWidth)) - PADDING;
                this.scroll.scrollToPoint(newScrollPosition, 0, 500);
                this.scrollActiveBar(((PADDING + (minNavbarPosition - (tabPosition - tabWidth))) * -1), index, previousIndex);
            }
            else {
                let smallPadding = isToRight ? 10 : -10;
                this.scroll.scrollToPoint((this.currentScroll + smallPadding), 0, 500);
                this.scrollActiveBar(smallPadding, index, previousIndex);
            }
        }
        else {
            this.scrollActiveBar(0, index, previousIndex);
        }
        setTimeout(() => {
            if (this.activeBar) {
                this.activeBar.setAttribute('style', `display: none;`);
                this.applyTabStyles(false, tabs);
                this.scrollByUser = true;
            }
        }, 500);
    }
    applyTabStyles(add, tabs) {
        tabs.forEach((tab) => {
            if (add) {
                tab.classList.add('block-color');
            }
            else {
                tab.classList.remove('block-color');
            }
        });
    }
    scrollActiveBar(scrollOffset = 0, index, previousIndex) {
        if (this.activeBar && this.elementWidths && this.elementWidths[this.selectedTabIndex]) {
            let currentLeft = this.activeBarLeftPosition;
            this.activeBarLeftPosition = this.getElementWidth(this.selectedTabIndex, true) - this.getElementWidth(this.selectedTabIndex) - scrollOffset - this.currentScroll;
            if (index !== undefined && index === 0) {
                this.activeBarLeftPosition = 0;
            }
            else if (index === this.tabs.length - 1) {
                this.activeBarLeftPosition = (this.hostWidth - this.activeBarWidth);
            }
            setAnimation(animations.leftSlide, this.activeBar, { startPosition: currentLeft, endPosition: this.activeBarLeftPosition, duration: 300, startWidth: this.getElementWidth(previousIndex), endWidth: this.activeBarWidth });
        }
    }
    getNumberOfVisibleItems(hostWidth, elementWidths) {
        if (elementWidths.length === 0) {
            return this.tabs ? this.tabs.length : 0;
        }
        else if (hostWidth <= elementWidths[0].accumulatedWidth) {
            return 1;
        }
        else if (elementWidths[elementWidths.length - 1].accumulatedWidth <= hostWidth) {
            return elementWidths.length;
        }
        else {
            return elementWidths.findIndex((i) => {
                return i.accumulatedWidth > hostWidth;
            });
        }
    }
    onIonScroll(ev) {
        if (ev && ev.detail) {
            if (this.scrollByUser) {
                this.activeBarLeftPosition = this.activeBarLeftPosition + (this.currentScroll - ev.detail.currentX);
            }
            this.currentScroll = ev.detail.currentX;
        }
    }
    resizePage() {
        let totalTabs = this.tabs ? this.tabs.length : 0;
        let elementDifference = totalTabs - this.getNumberOfVisibleItems(this.hostWidth, this.elementWidths);
        this.scrollTabs = elementDifference > 0;
    }
    actionBtnClicked() {
        this.actionButtonClicked.emit(true);
    }
    renderTab(tab, index, array, wrapperType = '') {
        return (h("yoo-tappable", { class: "center" },
            h("div", { class: 'inner-container ' + wrapperType + ' ' + (this.selectedTab === tab ? (this.withLine ? ' active-line' : ' active') : (this.withLine ? ' line' : '')) + ' tab' + index + (index === array.length - 1 ? ' last' : ''), onClick: () => this.onSelectTab(tab, index), ref: el => this.innerContainers[index] = el },
                tab.notif && h("div", { class: "notification" }),
                h("div", { class: 'text-container' + ` font-size-${this.reduceFontSize}` + (this.selectedTab === tab ? ' active' : '') },
                    h("span", { class: {
                            'wrap-title': this.host.classList.contains('swipeable')
                        } }, tab.title)))));
    }
    renderSwipeable() {
        return [
            h("div", { class: "slide-container" },
                h("yoo-ion-slides", { onIonSlideWillChange: () => this.onIonSlideDidChange(), options: { width: window.innerWidth * 0.4, centeredSlides: true, slidesOffsetBefore: this.slidesOffsetBefore }, ref: el => this.navSlides = el }, this.tabs.slice(0, this.numberOfVisibleItems).map((tab, index, array) => h("yoo-ion-slide", null, this.renderTab(tab, index, array, 'inside-slide'))))),
            this.swipeableIndicator && h("div", { class: "active-indicator" }),
            this.swipeableIndicator && h("div", { class: "shadow-border" })
        ];
    }
    renderScrollable() {
        return [
            this.scrollTabs ?
                h("div", { class: "scroll-container" },
                    h("yoo-ion-scroll", { class: {
                            'horizontal no-scrollbar': true,
                            'vertical-center': this.host.classList.contains('swipeable')
                        }, scrollEvents: true, ref: el => this.scroll = el, onIonScroll: (ev) => this.onIonScroll(ev) }, this.tabs.slice(0, this.numberOfVisibleItems).map((tab, index, array) => this.renderTab(tab, index, array))))
                : this.tabs.slice(0, this.numberOfVisibleItems).map((tab, index, array) => this.renderTab(tab, index, array)),
            h("div", { class: "active-bar", ref: el => this.activeBar = el }),
            this.showDropdown ? [
                h("yoo-context-menu", null,
                    h("div", { class: 'inner-container' + (this.activeTitleInDropdown ? ' active' : ''), slot: "trigger", id: "dropdown" },
                        this.activeTitleInDropdown ? this.selectedTab.title : translate('MORE'),
                        " ",
                        h("span", { class: "icon" },
                            h("yoo-icon", { class: "yo-arrow-dropdown" }))),
                    this.tabs.slice(this.numberOfVisibleItems, this.tabs.length).map((tab, i) => h("div", { class: 'dropdown' + (this.selectedTab === tab ? ' active' : '') + ' tab' + i, onClick: () => this.onSelectTab(tab, i) }, tab.title)))
            ]
                : null,
            this.actionBtnText ? h("yoo-button", { class: 'medium ' + this.host.className, text: this.actionBtnText, onClick: () => this.actionBtnClicked() }) : ''
        ];
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return (this.tabs ? ([
            h("div", { class: {
                    'outer-container': true,
                    'scroll': this.scrollTabs,
                    'loading': this.loading
                } }, this.host.classList.contains('swipeable') ? this.renderSwipeable() : this.renderScrollable())
        ]) : null);
    }
    static get is() { return "yoo-navbar"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "actionBtnText": {
            "type": String,
            "attr": "action-btn-text"
        },
        "getActiveIndex": {
            "method": true
        },
        "host": {
            "elementRef": true
        },
        "loading": {
            "state": true
        },
        "numberOfVisibleItems": {
            "state": true
        },
        "reduceFontSize": {
            "state": true
        },
        "scrollTabs": {
            "type": Boolean,
            "attr": "scroll-tabs",
            "mutable": true,
            "watchCallbacks": ["onScrollTabChanged"]
        },
        "selectedSwipeIndex": {
            "type": Number,
            "attr": "selected-swipe-index",
            "watchCallbacks": ["onSelectedSwipeIndexChange"]
        },
        "selectedTab": {
            "type": "Any",
            "attr": "selected-tab",
            "mutable": true,
            "watchCallbacks": ["onSelectScrollTab"]
        },
        "setActive": {
            "method": true
        },
        "showDropdown": {
            "state": true
        },
        "slidesOffsetBefore": {
            "state": true
        },
        "swipeableIndicator": {
            "type": Boolean,
            "attr": "swipeable-indicator"
        },
        "tabs": {
            "type": "Any",
            "attr": "tabs",
            "watchCallbacks": ["checkSelectedTab"]
        },
        "withLine": {
            "type": Boolean,
            "attr": "with-line"
        }
    }; }
    static get events() { return [{
            "name": "tabSelected",
            "method": "tabSelected",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "tabSelectedIsToRight",
            "method": "tabSelectedIsToRight",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "actionButtonClicked",
            "method": "actionButtonClicked",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  --width-outer-container: 100%; }\n\n:host {\n  height: 48px; }\n  :host .outer-container {\n    display: -ms-flexbox;\n    display: flex;\n    position: relative;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    -ms-flex-align: center;\n    align-items: center;\n    width: var(--width-outer-container);\n    height: 50px;\n    -webkit-transition: 0.3s;\n    transition: 0.3s;\n    line-height: normal;\n    opacity: 1; }\n    :host .outer-container.loading {\n      opacity: 0; }\n    :host .outer-container.scroll {\n      min-height: 2rem;\n      padding: 0rem; }\n    :host .outer-container .dropdown {\n      position: relative;\n      width: 100%;\n      padding: 0.5rem 1rem;\n      border-bottom: 1px solid var(--stable, #adadad);\n      line-height: 1.5; }\n      :host .outer-container .dropdown:hover {\n        cursor: pointer; }\n      :host .outer-container .dropdown.active {\n        color: ccsvar(stable); }\n    :host .outer-container yoo-tappable {\n      height: 100%; }\n    :host .outer-container .inner-container {\n      display: -ms-flexbox;\n      display: flex;\n      position: relative;\n      -ms-flex-direction: row;\n      flex-direction: row;\n      -ms-flex-align: center;\n      align-items: center;\n      -ms-flex-pack: center;\n      justify-content: center;\n      height: 100%;\n      padding-right: 1rem;\n      color: var(--stable-alt, #d0d0d0);\n      font-size: var(--font-l, 17px);\n      font-weight: 400;\n      -webkit-box-sizing: border-box;\n      box-sizing: border-box; }\n      :host .outer-container .inner-container .icon {\n        padding: 0.1rem; }\n      :host .outer-container .inner-container.line {\n        border-bottom: 1px solid var(--stable-light, #f1f1f1); }\n      :host .outer-container .inner-container.active {\n        color: var(--text-color, #807f83);\n        font-weight: 600; }\n      :host .outer-container .inner-container.last {\n        padding-right: 0; }\n      :host .outer-container .inner-container:hover {\n        cursor: pointer; }\n      :host .outer-container .inner-container#dropdown {\n        padding-right: 0rem;\n        padding-left: 1rem; }\n      :host .outer-container .inner-container.block-color {\n        border-bottom: 1px solid var(--stable-light, #f1f1f1) !important; }\n      :host .outer-container .inner-container.inside-slide .text-container {\n        padding-top: var(--padding-15, 0.9375rem);\n        padding-bottom: var(--padding-15, 0.9375rem); }\n        :host .outer-container .inner-container.inside-slide .text-container .wrap-title {\n          margin-top: -0.75rem;\n          white-space: pre-wrap; }\n      :host .outer-container .inner-container .notification {\n        position: absolute;\n        top: 0;\n        right: 0;\n        width: 0.3125rem;\n        height: 0.3125rem;\n        margin-top: var(--padding-15, 0.9375rem);\n        margin-right: var(--padding-5, 0.3125rem);\n        border-radius: 0.15625rem;\n        background-color: var(--danger, #ff625f); }\n      :host .outer-container .inner-container .text-container {\n        display: -ms-flexbox;\n        display: flex;\n        position: relative;\n        -ms-flex: 1;\n        flex: 1;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        width: 100%;\n        height: 100%;\n        padding-right: var(--padding-15, 0.9375rem);\n        padding-left: var(--padding-15, 0.9375rem);\n        border-bottom: 2px solid transparent;\n        text-align: center;\n        white-space: nowrap;\n        overflow: hidden; }\n        :host .outer-container .inner-container .text-container .dot {\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n          z-index: -1;\n          background-color: var(--success, #04CC99);\n          opacity: 0.2; }\n\n\@-webkit-keyframes expand-to-full {\n  0% {\n    width: 0%;\n    background-color: var(--success, #04CC99);\n    opacity: 0; }\n  100% {\n    width: 100%;\n    background-color: var(--success, #04CC99);\n    opacity: 0.8; } }\n\n\@keyframes expand-to-full {\n  0% {\n    width: 0%;\n    background-color: var(--success, #04CC99);\n    opacity: 0; }\n  100% {\n    width: 100%;\n    background-color: var(--success, #04CC99);\n    opacity: 0.8; } }\n\n\@-webkit-keyframes anim-in {\n  0% {\n    width: 0%; }\n  100% {\n    width: 100%;\n    z-index: -1; } }\n\n\@keyframes anim-in {\n  0% {\n    width: 0%; }\n  100% {\n    width: 100%;\n    z-index: -1; } }\n          :host .outer-container .inner-container .text-container .dot:before {\n            position: relative;\n            content: '';\n            display: block;\n            margin-top: 100%;\n            border-radius: 50%; }\n          :host .outer-container .inner-container .text-container .dot:after {\n            content: '';\n            position: absolute;\n            top: 0;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            border-radius: 50%; }\n          :host .outer-container .inner-container .text-container .dot.tapped, :host .outer-container .inner-container .text-container .dot.active, :host .outer-container .inner-container .text-container .dot.tapped:after, :host .outer-container .inner-container .text-container .dot.active:after {\n            border-radius: 50%;\n            -webkit-animation: anim-in 0.35s;\n            animation: anim-in 0.35s; }\n          :host .outer-container .inner-container .text-container .dot.hovered, :host .outer-container .inner-container .text-container .dot.hovered:after {\n            border-radius: 50%;\n            -webkit-animation: anim-in 0.15s;\n            animation: anim-in 0.15s;\n            -webkit-animation-fill-mode: forwards;\n            animation-fill-mode: forwards; }\n        :host .outer-container .inner-container .text-container.active {\n          border-bottom: none; }\n        :host .outer-container .inner-container .text-container.font-size-9 {\n          font-size: var(--font-m, 15px); }\n        :host .outer-container .inner-container .text-container.font-size-8 {\n          font-size: var(--font-s, 13px); }\n        :host .outer-container .inner-container .text-container.font-size-7 {\n          font-size: var(--font-xs, 10px); }\n    :host .outer-container yoo-button {\n      position: absolute;\n      top: 48px;\n      right: 0px; }\n    :host .outer-container .active-bar {\n      display: none;\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      height: 2px;\n      background-color: var(--succes);\n      z-index: 2; }\n  :host .nav-line {\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex: 1;\n    flex: 1;\n    -ms-flex-direction: row;\n    flex-direction: row;\n    height: 2px;\n    border: solid 1px #ececec; }\n\n:host(.small) .outer-container {\n  height: 36px; }\n  :host(.small) .outer-container .inner-container {\n    font-size: var(--font-s, 13px);\n    font-weight: 300; }\n    :host(.small) .outer-container .inner-container.font-size-9 {\n      font-size: var(--font-s, 13px); }\n    :host(.small) .outer-container .inner-container.active-line {\n      border-bottom-width: 1px !important; }\n  :host(.small) .outer-container .active-bar {\n    height: 1px !important; }\n\n:host(.items-center) {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: end;\n  align-items: flex-end;\n  -ms-flex-pack: center;\n  justify-content: center; }\n  :host(.items-center) .outer-container {\n    -ms-flex-pack: center;\n    justify-content: center;\n    width: -webkit-max-content;\n    width: -moz-max-content;\n    width: max-content; }\n    :host(.items-center) .outer-container yoo-tappable {\n      width: auto; }\n    :host(.items-center) .outer-container .inner-container {\n      -ms-flex-pack: center;\n      justify-content: center;\n      padding-right: 0; }\n\n:host(.items-space-around) .outer-container {\n  -ms-flex-pack: distribute;\n  justify-content: space-around; }\n  :host(.items-space-around) .outer-container .inner-container {\n    -ms-flex-pack: center;\n    justify-content: center;\n    width: 100%;\n    padding-right: 0; }\n\n:host(.items-full-width) .outer-container {\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  padding-right: 0.625rem;\n  padding-left: 0.625rem; }\n\n:host(.boost) .outer-container {\n  background-color: var(--light, #FFFFFF);\n  z-index: 2; }\n  :host(.boost) .outer-container .dropdown {\n    border-color: var(--danger-light, #F46885); }\n    :host(.boost) .outer-container .dropdown.active {\n      color: var(--danger-light, #F46885); }\n  :host(.boost) .outer-container .inner-container {\n    color: var(--stable, #adadad); }\n    :host(.boost) .outer-container .inner-container.active-line .text-container, :host(.boost) .outer-container .inner-container.active .text-container {\n      color: var(--black, #000000); }\n    :host(.boost) .outer-container .inner-container.active-line {\n      border-bottom: 2px solid var(--danger-light, #F46885); }\n  :host(.boost) .outer-container .active-bar {\n    background-color: var(--danger-light, #F46885); }\n\n:host(.operations) .outer-container {\n  background-color: var(--light, #FFFFFF);\n  z-index: 2; }\n  :host(.operations) .outer-container .dropdown {\n    border-color: var(--success-20, #c4feef); }\n    :host(.operations) .outer-container .dropdown.active {\n      color: var(--success, #04CC99); }\n  :host(.operations) .outer-container .inner-container {\n    color: var(--stable, #adadad); }\n    :host(.operations) .outer-container .inner-container.active-line .text-container, :host(.operations) .outer-container .inner-container.active .text-container {\n      color: var(--black, #000000); }\n    :host(.operations) .outer-container .inner-container.active-line {\n      border-bottom: 2px solid var(--success, #04CC99); }\n  :host(.operations) .outer-container .active-bar {\n    background-color: var(--success, #04CC99); }\n\n:host(.swipeable) {\n  height: 100%; }\n  :host(.swipeable) .outer-container {\n    min-height: 6.875rem;\n    margin-top: 0;\n    background: var(--stable-light, #f1f1f1); }\n    :host(.swipeable) .outer-container .slide-container {\n      width: 100%;\n      height: 100%; }\n  :host(.swipeable) .inner-container {\n    margin: 0 auto;\n    padding: 0 !important; }\n  :host(.swipeable) .text-container.active {\n    color: var(--black, #000000); }\n  :host(.swipeable) .shadow-border {\n    top: auto;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    position: absolute;\n    background: var(--light, #FFFFFF);\n    -webkit-box-shadow: var(--footer-shadow, 0 1px 10px 0 rgba(0, 0, 0, 0.15));\n    box-shadow: var(--footer-shadow, 0 1px 10px 0 rgba(0, 0, 0, 0.15)); }\n  :host(.swipeable) .active-indicator {\n    top: auto;\n    right: calc(50% - 12.5px);\n    bottom: 0;\n    left: auto;\n    position: absolute;\n    border-top: 15px solid transparent;\n    border-right: 12.5px solid transparent;\n    border-bottom: 15px solid var(--light, #FFFFFF);\n    border-left: 12.5px solid transparent; }\n\n:host(.web) .outer-container {\n  overflow: hidden; }\n  :host(.web) .outer-container .inner-container .text-container {\n    font-size: var(--font-m, 15px); }\n\n:host(.web) .text-container {\n  -ms-flex-align: end !important;\n  align-items: flex-end !important; }\n  :host(.web) .text-container span {\n    padding-bottom: var(--padding-10, 0.625rem); }"; }
}

var browser = createCommonjsModule(function (module, exports) {
/*!
 * @license
 *
 * Scandit Barcode Scanner SDK for the Web
 * v. 4.1.1
 *
 * Copyright  2019 Scandit AG. All Rights Reserved.
 *
 * The use of this software is governed by the Scandit Terms and Conditions.
 * https://ssl.scandit.com/terms/test.pdf
 *
 * The following sets forth attribution notices for third party software that may be contained in portions of the product.
 * https://docs.scandit.com/stable/web/LICENSE
 */
(function(global, factory) {
  "object" === 'object' && "undefined" !== 'object'
    ? factory(exports)
    : "function" === typeof undefined && undefined.amd
    ? undefined(["exports"], factory)
    : ((global = global || self), factory((global.ScanditSDK = {})));
})(commonjsGlobal, function(exports) {
  "use strict";
  function ___$insertStyle(css) {
    if (!css) return;
    if ("undefined" === typeof window) return;
    var style = document.createElement("style");
    style.setAttribute("type", "text/css");
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
  }
  var _isObject = function(it) {
    return "object" === typeof it ? null !== it : "function" === typeof it;
  };
  var _anObject = function(it) {
    if (!_isObject(it)) throw TypeError(it + " is not an object!");
    return it;
  };
  var _fails = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  var _descriptors = !_fails(function() {
    return (
      7 !=
      Object.defineProperty({}, "a", {
        get: function() {
          return 7;
        }
      }).a
    );
  });
  var commonjsGlobal$1 =
    "undefined" !== typeof window
      ? window
      : "undefined" !== typeof commonjsGlobal
      ? commonjsGlobal
      : "undefined" !== typeof self
      ? self
      : {};
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
  }
  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
  }
  function createCommonjsModule(fn, module) {
    return (module = { exports: {} }), fn(module, module.exports), module.exports;
  }
  var _global = createCommonjsModule(function(module) {
    var global = (module.exports =
      "undefined" != typeof window && window.Math == Math
        ? window
        : "undefined" != typeof self && self.Math == Math
        ? self
        : Function("return this")());
    if ("number" == typeof __g) __g = global;
  });
  var document$1 = _global.document;
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function(it) {
    return is ? document$1.createElement(it) : {};
  };
  var _ie8DomDefine =
    !_descriptors &&
    !_fails(function() {
      return (
        7 !=
        Object.defineProperty(_domCreate("div"), "a", {
          get: function() {
            return 7;
          }
        }).a
      );
    });
  var _toPrimitive = function(it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && "function" == typeof (fn = it.toString) && !_isObject((val = fn.call(it)))) return val;
    if ("function" == typeof (fn = it.valueOf) && !_isObject((val = fn.call(it)))) return val;
    if (!S && "function" == typeof (fn = it.toString) && !_isObject((val = fn.call(it)))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var dP = Object.defineProperty;
  var f = _descriptors
    ? Object.defineProperty
    : function defineProperty(O, P, Attributes) {
        _anObject(O);
        P = _toPrimitive(P, true);
        _anObject(Attributes);
        if (_ie8DomDefine)
          try {
            return dP(O, P, Attributes);
          } catch (e) {}
        if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
        if ("value" in Attributes) O[P] = Attributes.value;
        return O;
      };
  var _objectDp = { f: f };
  var _propertyDesc = function(bitmap, value) {
    return { enumerable: !(1 & bitmap), configurable: !(2 & bitmap), writable: !(4 & bitmap), value: value };
  };
  var _hide = _descriptors
    ? function(object, key, value) {
        return _objectDp.f(object, key, _propertyDesc(1, value));
      }
    : function(object, key, value) {
        object[key] = value;
        return object;
      };
  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  var id = 0;
  var px = Math.random();
  var _uid = function(key) {
    return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
  };
  var _core = createCommonjsModule(function(module) {
    var core = (module.exports = { version: "2.5.1" });
    if ("number" == typeof __e) __e = core;
  });
  _core.version;
  var _redefine = createCommonjsModule(function(module) {
    var SRC = _uid("src");
    var TO_STRING = "toString";
    var $toString = Function[TO_STRING];
    var TPL = ("" + $toString).split(TO_STRING);
    _core.inspectSource = function(it) {
      return $toString.call(it);
    };
    (module.exports = function(O, key, val, safe) {
      var isFunction = "function" == typeof val;
      if (isFunction) _has(val, "name") || _hide(val, "name", key);
      if (O[key] === val) return;
      if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
      if (O === _global) O[key] = val;
      else if (!safe) {
        delete O[key];
        _hide(O, key, val);
      } else if (O[key]) O[key] = val;
      else _hide(O, key, val);
    })(Function.prototype, TO_STRING, function toString() {
      return ("function" == typeof this && this[SRC]) || $toString.call(this);
    });
  });
  var _defined = function(it) {
    if (void 0 == it) throw TypeError("Can't call method on  " + it);
    return it;
  };
  var SHARED = "__core-js_shared__";
  var store = _global[SHARED] || (_global[SHARED] = {});
  var _shared = function(key) {
    return store[key] || (store[key] = {});
  };
  var _wks = createCommonjsModule(function(module) {
    var store = _shared("wks");
    var Symbol = _global.Symbol;
    var USE_SYMBOL = "function" == typeof Symbol;
    var $exports = (module.exports = function(name) {
      return (
        store[name] || (store[name] = (USE_SYMBOL && Symbol[name]) || (USE_SYMBOL ? Symbol : _uid)("Symbol." + name))
      );
    });
    $exports.store = store;
  });
  var _fixReWks = function(KEY, length, exec) {
    var SYMBOL = _wks(KEY);
    var fns = exec(_defined, SYMBOL, ""[KEY]);
    var strfn = fns[0];
    var rxfn = fns[1];
    if (
      _fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return 7 != ""[KEY](O);
      })
    ) {
      _redefine(String.prototype, KEY, strfn);
      _hide(
        RegExp.prototype,
        SYMBOL,
        2 == length
          ? function(string, arg) {
              return rxfn.call(string, this, arg);
            }
          : function(string) {
              return rxfn.call(string, this);
            }
      );
    }
  };
  var toString = {}.toString;
  var _cof = function(it) {
    return toString.call(it).slice(8, -1);
  };
  var MATCH = _wks("match");
  var _isRegexp = function(it) {
    var isRegExp;
    return _isObject(it) && (void 0 !== (isRegExp = it[MATCH]) ? !!isRegExp : "RegExp" == _cof(it));
  };
  _fixReWks("split", 2, function(defined, SPLIT, $split) {
    var isRegExp = _isRegexp;
    var _split = $split;
    var $push = [].push;
    var $SPLIT = "split";
    var LENGTH = "length";
    var LAST_INDEX = "lastIndex";
    if (
      "c" == "abbc"[$SPLIT](/(b)*/)[1] ||
      4 != "test"[$SPLIT](/(?:)/, -1)[LENGTH] ||
      2 != "ab"[$SPLIT](/(?:ab)*/)[LENGTH] ||
      4 != "."[$SPLIT](/(.?)(.?)/)[LENGTH] ||
      "."[$SPLIT](/()()/)[LENGTH] > 1 ||
      ""[$SPLIT](/.?/)[LENGTH]
    ) {
      var NPCG = void 0 === /()??/.exec("")[1];
      $split = function(separator, limit) {
        var string = String(this);
        if (void 0 === separator && 0 === limit) return [];
        if (!isRegExp(separator)) return _split.call(string, separator, limit);
        var output = [];
        var flags =
          (separator.ignoreCase ? "i" : "") +
          (separator.multiline ? "m" : "") +
          (separator.unicode ? "u" : "") +
          (separator.sticky ? "y" : "");
        var lastLastIndex = 0;
        var splitLimit = void 0 === limit ? 4294967295 : limit >>> 0;
        var separatorCopy = new RegExp(separator.source, flags + "g");
        var separator2, match, lastIndex, lastLength, i;
        if (!NPCG) separator2 = new RegExp("^" + separatorCopy.source + "$(?!\\s)", flags);
        while ((match = separatorCopy.exec(string))) {
          lastIndex = match.index + match[0][LENGTH];
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (!NPCG && match[LENGTH] > 1)
              match[0].replace(separator2, function() {
                for (i = 1; i < arguments[LENGTH] - 2; i++) if (void 0 === arguments[i]) match[i] = void 0;
              });
            if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
            lastLength = match[0][LENGTH];
            lastLastIndex = lastIndex;
            if (output[LENGTH] >= splitLimit) break;
          }
          if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++;
        }
        if (lastLastIndex === string[LENGTH]) {
          if (lastLength || !separatorCopy.test("")) output.push("");
        } else output.push(string.slice(lastLastIndex));
        return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
      };
    } else if ("0"[$SPLIT](void 0, 0)[LENGTH])
      $split = function(separator, limit) {
        return void 0 === separator && 0 === limit ? [] : _split.call(this, separator, limit);
      };
    return [
      function split(separator, limit) {
        var O = defined(this);
        var fn = void 0 == separator ? void 0 : separator[SPLIT];
        return void 0 !== fn ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
      },
      $split
    ];
  });
  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function(it) {
    return isNaN((it = +it)) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  var _defined$1 = function(it) {
    if (void 0 == it) throw TypeError("Can't call method on  " + it);
    return it;
  };
  var _stringAt = function(TO_STRING) {
    return function(that, pos) {
      var s = String(_defined$1(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
      a = s.charCodeAt(i);
      return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343
        ? TO_STRING
          ? s.charAt(i)
          : a
        : TO_STRING
        ? s.slice(i, i + 2)
        : ((a - 55296) << 10) + (b - 56320) + 65536;
    };
  };
  var _library = true;
  var _global$1 = createCommonjsModule(function(module) {
    var global = (module.exports =
      "undefined" != typeof window && window.Math == Math
        ? window
        : "undefined" != typeof self && self.Math == Math
        ? self
        : Function("return this")());
    if ("number" == typeof __g) __g = global;
  });
  var _core$1 = createCommonjsModule(function(module) {
    var core = (module.exports = { version: "2.6.2" });
    if ("number" == typeof __e) __e = core;
  });
  _core$1.version;
  var _aFunction = function(it) {
    if ("function" != typeof it) throw TypeError(it + " is not a function!");
    return it;
  };
  var _ctx = function(fn, that, length) {
    _aFunction(fn);
    if (void 0 === that) return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var _isObject$1 = function(it) {
    return "object" === typeof it ? null !== it : "function" === typeof it;
  };
  var _anObject$1 = function(it) {
    if (!_isObject$1(it)) throw TypeError(it + " is not an object!");
    return it;
  };
  var _fails$1 = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  var _descriptors$1 = !_fails$1(function() {
    return (
      7 !=
      Object.defineProperty({}, "a", {
        get: function() {
          return 7;
        }
      }).a
    );
  });
  var document$2 = _global$1.document;
  var is$1 = _isObject$1(document$2) && _isObject$1(document$2.createElement);
  var _domCreate$1 = function(it) {
    return is$1 ? document$2.createElement(it) : {};
  };
  var _ie8DomDefine$1 =
    !_descriptors$1 &&
    !_fails$1(function() {
      return (
        7 !=
        Object.defineProperty(_domCreate$1("div"), "a", {
          get: function() {
            return 7;
          }
        }).a
      );
    });
  var _toPrimitive$1 = function(it, S) {
    if (!_isObject$1(it)) return it;
    var fn, val;
    if (S && "function" == typeof (fn = it.toString) && !_isObject$1((val = fn.call(it)))) return val;
    if ("function" == typeof (fn = it.valueOf) && !_isObject$1((val = fn.call(it)))) return val;
    if (!S && "function" == typeof (fn = it.toString) && !_isObject$1((val = fn.call(it)))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  var dP$1 = Object.defineProperty;
  var f$1 = _descriptors$1
    ? Object.defineProperty
    : function defineProperty(O, P, Attributes) {
        _anObject$1(O);
        P = _toPrimitive$1(P, true);
        _anObject$1(Attributes);
        if (_ie8DomDefine$1)
          try {
            return dP$1(O, P, Attributes);
          } catch (e) {}
        if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
        if ("value" in Attributes) O[P] = Attributes.value;
        return O;
      };
  var _objectDp$1 = { f: f$1 };
  var _propertyDesc$1 = function(bitmap, value) {
    return { enumerable: !(1 & bitmap), configurable: !(2 & bitmap), writable: !(4 & bitmap), value: value };
  };
  var _hide$1 = _descriptors$1
    ? function(object, key, value) {
        return _objectDp$1.f(object, key, _propertyDesc$1(1, value));
      }
    : function(object, key, value) {
        object[key] = value;
        return object;
      };
  var hasOwnProperty$1 = {}.hasOwnProperty;
  var _has$1 = function(it, key) {
    return hasOwnProperty$1.call(it, key);
  };
  var PROTOTYPE = "prototype";
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core$1 : _core$1[name] || (_core$1[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global$1 : IS_STATIC ? _global$1[name] : (_global$1[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && void 0 !== target[key];
      if (own && _has$1(exports, key)) continue;
      out = own ? target[key] : source[key];
      exports[key] =
        IS_GLOBAL && "function" != typeof target[key]
          ? source[key]
          : IS_BIND && own
          ? _ctx(out, _global$1)
          : IS_WRAP && target[key] == out
          ? (function(C) {
              var F = function(a, b, c) {
                if (this instanceof C) {
                  switch (arguments.length) {
                    case 0:
                      return new C();
                    case 1:
                      return new C(a);
                    case 2:
                      return new C(a, b);
                  }
                  return new C(a, b, c);
                }
                return C.apply(this, arguments);
              };
              F[PROTOTYPE] = C[PROTOTYPE];
              return F;
            })(out)
          : IS_PROTO && "function" == typeof out
          ? _ctx(Function.call, out)
          : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) _hide$1(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  var _export = $export;
  var _redefine$1 = _hide$1;
  var _iterators = {};
  var toString$1 = {}.toString;
  var _cof$1 = function(it) {
    return toString$1.call(it).slice(8, -1);
  };
  var _iobject = Object("z").propertyIsEnumerable(0)
    ? Object
    : function(it) {
        return "String" == _cof$1(it) ? it.split("") : Object(it);
      };
  var _toIobject = function(it) {
    return _iobject(_defined$1(it));
  };
  var min = Math.min;
  var _toLength = function(it) {
    return it > 0 ? min(_toInteger(it), 9007199254740991) : 0;
  };
  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function(index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };
  var _arrayIncludes = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value) return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) if (O[index] === el) return IS_INCLUDES || index || 0;
      return !IS_INCLUDES && -1;
    };
  };
  var _shared$1 = createCommonjsModule(function(module) {
    var SHARED = "__core-js_shared__";
    var store = _global$1[SHARED] || (_global$1[SHARED] = {});
    (module.exports = function(key, value) {
      return store[key] || (store[key] = void 0 !== value ? value : {});
    })("versions", []).push({
      version: _core$1.version,
      mode: "pure",
      copyright: " 2019 Denis Pushkarev (zloirock.ru)"
    });
  });
  var id$1 = 0;
  var px$1 = Math.random();
  var _uid$1 = function(key) {
    return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id$1 + px$1).toString(36));
  };
  var shared = _shared$1("keys");
  var _sharedKey = function(key) {
    return shared[key] || (shared[key] = _uid$1(key));
  };
  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey("IE_PROTO");
  var _objectKeysInternal = function(object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has$1(O, key) && result.push(key);
    while (names.length > i) if (_has$1(O, (key = names[i++]))) ~arrayIndexOf(result, key) || result.push(key);
    return result;
  };
  var _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
    ","
  );
  var _objectKeys =
    Object.keys ||
    function keys(O) {
      return _objectKeysInternal(O, _enumBugKeys);
    };
  var _objectDps = _descriptors$1
    ? Object.defineProperties
    : function defineProperties(O, Properties) {
        _anObject$1(O);
        var keys = _objectKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;
        while (length > i) _objectDp$1.f(O, (P = keys[i++]), Properties[P]);
        return O;
      };
  var document$3 = _global$1.document;
  var _html = document$3 && document$3.documentElement;
  var IE_PROTO$1 = _sharedKey("IE_PROTO");
  var Empty = function() {};
  var PROTOTYPE$1 = "prototype";
  var createDict = function() {
    var iframe = _domCreate$1("iframe");
    var i = _enumBugKeys.length;
    var lt = "<";
    var gt = ">";
    var iframeDocument;
    iframe.style.display = "none";
    _html.appendChild(iframe);
    iframe.src = "javascript:";
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };
  var _objectCreate =
    Object.create ||
    function create(O, Properties) {
      var result;
      if (null !== O) {
        Empty[PROTOTYPE$1] = _anObject$1(O);
        result = new Empty();
        Empty[PROTOTYPE$1] = null;
        result[IE_PROTO$1] = O;
      } else result = createDict();
      return void 0 === Properties ? result : _objectDps(result, Properties);
    };
  var _wks$1 = createCommonjsModule(function(module) {
    var store = _shared$1("wks");
    var Symbol = _global$1.Symbol;
    var USE_SYMBOL = "function" == typeof Symbol;
    var $exports = (module.exports = function(name) {
      return (
        store[name] || (store[name] = (USE_SYMBOL && Symbol[name]) || (USE_SYMBOL ? Symbol : _uid$1)("Symbol." + name))
      );
    });
    $exports.store = store;
  });
  var def = _objectDp$1.f;
  var TAG = _wks$1("toStringTag");
  var _setToStringTag = function(it, tag, stat) {
    if (it && !_has$1((it = stat ? it : it.prototype), TAG)) def(it, TAG, { configurable: true, value: tag });
  };
  var IteratorPrototype = {};
  _hide$1(IteratorPrototype, _wks$1("iterator"), function() {
    return this;
  });
  var _iterCreate = function(Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc$1(1, next) });
    _setToStringTag(Constructor, NAME + " Iterator");
  };
  var _toObject = function(it) {
    return Object(_defined$1(it));
  };
  var IE_PROTO$2 = _sharedKey("IE_PROTO");
  var ObjectProto = Object.prototype;
  var _objectGpo =
    Object.getPrototypeOf ||
    function(O) {
      O = _toObject(O);
      if (_has$1(O, IE_PROTO$2)) return O[IE_PROTO$2];
      if ("function" == typeof O.constructor && O instanceof O.constructor) return O.constructor.prototype;
      return O instanceof Object ? ObjectProto : null;
    };
  var ITERATOR = _wks$1("iterator");
  var BUGGY = !([].keys && "next" in [].keys());
  var FF_ITERATOR = "@@iterator";
  var KEYS = "keys";
  var VALUES = "values";
  var returnThis = function() {
    return this;
  };
  var _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + " Iterator";
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || (DEFAULT && proto[DEFAULT]);
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? (!DEF_VALUES ? $default : getMethod("entries")) : void 0;
    var $anyNative = "Array" == NAME ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        _setToStringTag(IteratorPrototype, TAG, true);
        if (!_library && "function" != typeof IteratorPrototype[ITERATOR])
          _hide$1(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() {
        return $native.call(this);
      };
    }
    if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) _hide$1(proto, ITERATOR, $default);
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) {
        for (key in methods) if (!(key in proto)) _redefine$1(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  var $at = _stringAt(true);
  _iterDefine(
    String,
    "String",
    function(iterated) {
      this._t = String(iterated);
      this._i = 0;
    },
    function() {
      var O = this._t;
      var index = this._i;
      var point;
      if (index >= O.length) return { value: void 0, done: true };
      point = $at(O, index);
      this._i += point.length;
      return { value: point, done: false };
    }
  );
  var _iterStep = function(done, value) {
    return { value: value, done: !!done };
  };
  _iterDefine(
    Array,
    "Array",
    function(iterated, kind) {
      this._t = _toIobject(iterated);
      this._i = 0;
      this._k = kind;
    },
    function() {
      var O = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O || index >= O.length) {
        this._t = void 0;
        return _iterStep(1);
      }
      if ("keys" == kind) return _iterStep(0, index);
      if ("values" == kind) return _iterStep(0, O[index]);
      return _iterStep(0, [index, O[index]]);
    },
    "values"
  );
  _iterators.Arguments = _iterators.Array;
  var TO_STRING_TAG = _wks$1("toStringTag");
  var DOMIterables = (
    "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList," +
    "DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement," +
    "MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList," +
    "SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList," +
    "TextTrackList,TouchList"
  ).split(",");
  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = _global$1[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide$1(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }
  var TAG$1 = _wks$1("toStringTag");
  var ARG =
    "Arguments" ==
    _cof$1(
      (function() {
        return arguments;
      })()
    );
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (e) {}
  };
  var _classof = function(it) {
    var O, T, B;
    return void 0 === it
      ? "Undefined"
      : null === it
      ? "Null"
      : "string" == typeof (T = tryGet((O = Object(it)), TAG$1))
      ? T
      : ARG
      ? _cof$1(O)
      : "Object" == (B = _cof$1(O)) && "function" == typeof O.callee
      ? "Arguments"
      : B;
  };
  var _anInstance = function(it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (void 0 !== forbiddenField && forbiddenField in it))
      throw TypeError(name + ": incorrect invocation!");
    return it;
  };
  var _iterCall = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject$1(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator["return"];
      if (void 0 !== ret) _anObject$1(ret.call(iterator));
      throw e;
    }
  };
  var ITERATOR$1 = _wks$1("iterator");
  var ArrayProto = Array.prototype;
  var _isArrayIter = function(it) {
    return void 0 !== it && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };
  var ITERATOR$2 = _wks$1("iterator");
  var core_getIteratorMethod = (_core$1.getIteratorMethod = function(it) {
    if (void 0 != it) return it[ITERATOR$2] || it["@@iterator"] || _iterators[_classof(it)];
  });
  var _forOf = createCommonjsModule(function(module) {
    var BREAK = {};
    var RETURN = {};
    var exports = (module.exports = function(iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR
        ? function() {
            return iterable;
          }
        : core_getIteratorMethod(iterable);
      var f = _ctx(fn, that, entries ? 2 : 1);
      var index = 0;
      var length, step, iterator, result;
      if ("function" != typeof iterFn) throw TypeError(iterable + " is not iterable!");
      if (_isArrayIter(iterFn))
        for (length = _toLength(iterable.length); length > index; index++) {
          result = entries ? f(_anObject$1((step = iterable[index]))[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN) return result;
        }
      else
        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
          result = _iterCall(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN) return result;
        }
    });
    exports.BREAK = BREAK;
    exports.RETURN = RETURN;
  });
  var SPECIES = _wks$1("species");
  var _speciesConstructor = function(O, D) {
    var C = _anObject$1(O).constructor;
    var S;
    return void 0 === C || void 0 == (S = _anObject$1(C)[SPECIES]) ? D : _aFunction(S);
  };
  var _invoke = function(fn, args, that) {
    var un = void 0 === that;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  var process = _global$1.process;
  var setTask = _global$1.setImmediate;
  var clearTask = _global$1.clearImmediate;
  var MessageChannel = _global$1.MessageChannel;
  var Dispatch = _global$1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = "onreadystatechange";
  var defer, channel, port;
  var run = function() {
    var id = +this;
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function(event) {
    run.call(event.data);
  };
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function() {
        _invoke("function" == typeof fn ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    if ("process" == _cof$1(process))
      defer = function(id) {
        process.nextTick(_ctx(run, id, 1));
      };
    else if (Dispatch && Dispatch.now)
      defer = function(id) {
        Dispatch.now(_ctx(run, id, 1));
      };
    else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1);
    } else if (_global$1.addEventListener && "function" == typeof postMessage && !_global$1.importScripts) {
      defer = function(id) {
        _global$1.postMessage(id + "", "*");
      };
      _global$1.addEventListener("message", listener, false);
    } else if (ONREADYSTATECHANGE in _domCreate$1("script"))
      defer = function(id) {
        _html.appendChild(_domCreate$1("script"))[ONREADYSTATECHANGE] = function() {
          _html.removeChild(this);
          run.call(id);
        };
      };
    else
      defer = function(id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
  }
  var _task = { set: setTask, clear: clearTask };
  var macrotask = _task.set;
  var Observer = _global$1.MutationObserver || _global$1.WebKitMutationObserver;
  var process$1 = _global$1.process;
  var Promise$1 = _global$1.Promise;
  var isNode = "process" == _cof$1(process$1);
  var _microtask = function() {
    var head, last, notify;
    var flush = function() {
      var parent, fn;
      if (isNode && (parent = process$1.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = void 0;
          throw e;
        }
      }
      last = void 0;
      if (parent) parent.enter();
    };
    if (isNode)
      notify = function() {
        process$1.nextTick(flush);
      };
    else if (Observer && !(_global$1.navigator && _global$1.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode("");
      new Observer(flush).observe(node, { characterData: true });
      notify = function() {
        node.data = toggle = !toggle;
      };
    } else if (Promise$1 && Promise$1.resolve) {
      var promise = Promise$1.resolve(void 0);
      notify = function() {
        promise.then(flush);
      };
    } else
      notify = function() {
        macrotask.call(_global$1, flush);
      };
    return function(fn) {
      var task = { fn: fn, next: void 0 };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  };
  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
      if (void 0 !== resolve || void 0 !== reject) throw TypeError("Bad Promise constructor");
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }
  var f$2 = function(C) {
    return new PromiseCapability(C);
  };
  var _newPromiseCapability = { f: f$2 };
  var _perform = function(exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };
  var navigator$1 = _global$1.navigator;
  var _userAgent = (navigator$1 && navigator$1.userAgent) || "";
  var _promiseResolve = function(C, x) {
    _anObject$1(C);
    if (_isObject$1(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };
  var _redefineAll = function(target, src, safe) {
    for (var key in src)
      if (safe && target[key]) target[key] = src[key];
      else _hide$1(target, key, src[key]);
    return target;
  };
  var SPECIES$1 = _wks$1("species");
  var _setSpecies = function(KEY) {
    var C = "function" == typeof _core$1[KEY] ? _core$1[KEY] : _global$1[KEY];
    if (_descriptors$1 && C && !C[SPECIES$1])
      _objectDp$1.f(C, SPECIES$1, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  var ITERATOR$3 = _wks$1("iterator");
  var SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR$3]();
    riter["return"] = function() {
      SAFE_CLOSING = true;
    };
  } catch (e) {}
  var _iterDetect = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function() {
        return { done: (safe = true) };
      };
      arr[ITERATOR$3] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  var task = _task.set;
  var microtask = _microtask();
  var PROMISE = "Promise";
  var TypeError$1 = _global$1.TypeError;
  var process$2 = _global$1.process;
  var versions = process$2 && process$2.versions;
  var v8 = (versions && versions.v8) || "";
  var $Promise = _global$1[PROMISE];
  var isNode$1 = "process" == _classof(process$2);
  var empty = function() {};
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = (newGenericPromiseCapability = _newPromiseCapability.f);
  var USE_NATIVE = !!(function() {
    try {
      var promise = $Promise.resolve(1);
      var FakePromise = ((promise.constructor = {})[_wks$1("species")] = function(exec) {
        exec(empty, empty);
      });
      return (
        (isNode$1 || "function" == typeof PromiseRejectionEvent) &&
        promise.then(empty) instanceof FakePromise &&
        0 !== v8.indexOf("6.6") &&
        -1 === _userAgent.indexOf("Chrome/66")
      );
    } catch (e) {}
  })();
  var isThenable = function(it) {
    var then;
    return _isObject$1(it) && "function" == typeof (then = it.then) ? then : false;
  };
  var notify = function(promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function() {
      var value = promise._v;
      var ok = 1 == promise._s;
      var i = 0;
      var run = function(reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (2 == promise._h) onHandleUnhandled(promise);
              promise._h = 1;
            }
            if (true === handler) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) reject(TypeError$1("Promise-chain cycle"));
            else if ((then = isThenable(result))) then.call(result, resolve, reject);
            else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]);
      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };
  var onUnhandled = function(promise) {
    task.call(_global$1, function() {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;
      if (unhandled) {
        result = _perform(function() {
          if (isNode$1) process$2.emit("unhandledRejection", value, promise);
          else if ((handler = _global$1.onunhandledrejection)) handler({ promise: promise, reason: value });
          else if ((console = _global$1.console) && console.error) console.error("Unhandled promise rejection", value);
        });
        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
      }
      promise._a = void 0;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function(promise) {
    return 1 !== promise._h && 0 === (promise._a || promise._c).length;
  };
  var onHandleUnhandled = function(promise) {
    task.call(_global$1, function() {
      var handler;
      if (isNode$1) process$2.emit("rejectionHandled", promise);
      else if ((handler = _global$1.onrejectionhandled)) handler({ promise: promise, reason: promise._v });
    });
  };
  var $reject = function(value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise;
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function(value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise;
    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      if ((then = isThenable(value)))
        microtask(function() {
          var wrapper = { _w: promise, _d: false };
          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({ _w: promise, _d: false }, e);
    }
  };
  if (!USE_NATIVE) {
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, "_h");
      _aFunction(executor);
      Internal.call(this);
      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    Internal = function Promise(executor) {
      this._c = [];
      this._a = void 0;
      this._s = 0;
      this._d = false;
      this._v = void 0;
      this._h = 0;
      this._n = false;
    };
    Internal.prototype = _redefineAll($Promise.prototype, {
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = "function" == typeof onFulfilled ? onFulfilled : true;
        reaction.fail = "function" == typeof onRejected && onRejected;
        reaction.domain = isNode$1 ? process$2.domain : void 0;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      catch: function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    OwnPromiseCapability = function() {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };
    _newPromiseCapability.f = newPromiseCapability = function(C) {
      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
  }
  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core$1[PROMISE];
  _export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {
    resolve: function resolve(x) {
      return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
    }
  });
  _export(
    _export.S +
      _export.F *
        !(
          USE_NATIVE &&
          _iterDetect(function(iter) {
            $Promise.all(iter)["catch"](empty);
          })
        ),
    PROMISE,
    {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = _perform(function() {
          var values = [];
          var index = 0;
          var remaining = 1;
          _forOf(iterable, false, function(promise) {
            var $index = index++;
            var alreadyCalled = false;
            values.push(void 0);
            remaining++;
            C.resolve(promise).then(function(value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[$index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.e) reject(result.v);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = _perform(function() {
          _forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (result.e) reject(result.v);
        return capability.promise;
      }
    }
  );
  _export(_export.P + _export.R, "Promise", {
    finally: function(onFinally) {
      var C = _speciesConstructor(this, _core$1.Promise || _global$1.Promise);
      var isFunction = "function" == typeof onFinally;
      return this.then(
        isFunction
          ? function(x) {
              return _promiseResolve(C, onFinally()).then(function() {
                return x;
              });
            }
          : onFinally,
        isFunction
          ? function(e) {
              return _promiseResolve(C, onFinally()).then(function() {
                throw e;
              });
            }
          : onFinally
      );
    }
  });
  _export(_export.S, "Promise", {
    try: function(callbackfn) {
      var promiseCapability = _newPromiseCapability.f(this);
      var result = _perform(callbackfn);
      (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
      return promiseCapability.promise;
    }
  });
  var promise = _core$1.Promise;
  var promise$1 = promise;
  !(function() {
    if ("undefined" != typeof window) {
      var t = window.navigator.userAgent.match(/Edge\/(\d{2})\./),
        e = !!t && parseInt(t[1], 10) >= 16;
      if ("objectFit" in document.documentElement.style != !1 && !e)
        return void (window.objectFitPolyfill = function() {
          return !1;
        });
      var i = function(t) {
          var e = window.getComputedStyle(t, null),
            i = e.getPropertyValue("position"),
            n = e.getPropertyValue("overflow"),
            o = e.getPropertyValue("display");
          (i && "static" !== i) || (t.style.position = "relative"),
            "hidden" !== n && (t.style.overflow = "hidden"),
            (o && "inline" !== o) || (t.style.display = "block"),
            0 === t.clientHeight && (t.style.height = "100%"),
            -1 === t.className.indexOf("object-fit-polyfill") && (t.className = t.className + " object-fit-polyfill");
        },
        n = function(t) {
          var e = window.getComputedStyle(t, null),
            i = {
              "max-width": "none",
              "max-height": "none",
              "min-width": "0px",
              "min-height": "0px",
              top: "auto",
              right: "auto",
              bottom: "auto",
              left: "auto",
              "margin-top": "0px",
              "margin-right": "0px",
              "margin-bottom": "0px",
              "margin-left": "0px"
            };
          for (var n in i) e.getPropertyValue(n) !== i[n] && (t.style[n] = i[n]);
        },
        o = function(t, e, i) {
          var n, o, l, a, d;
          if (((i = i.split(" ")), i.length < 2 && (i[1] = i[0]), "x" === t))
            (n = i[0]), (o = i[1]), (l = "left"), (a = "right"), (d = e.clientWidth);
          else {
            if ("y" !== t) return;
            (n = i[1]), (o = i[0]), (l = "top"), (a = "bottom"), (d = e.clientHeight);
          }
          return n === l || o === l
            ? void (e.style[l] = "0")
            : n === a || o === a
            ? void (e.style[a] = "0")
            : "center" === n || "50%" === n
            ? ((e.style[l] = "50%"), void (e.style["margin-" + l] = d / -2 + "px"))
            : n.indexOf("%") >= 0
            ? ((n = parseInt(n)),
              void (n < 50
                ? ((e.style[l] = n + "%"), (e.style["margin-" + l] = d * (n / -100) + "px"))
                : ((n = 100 - n), (e.style[a] = n + "%"), (e.style["margin-" + a] = d * (n / -100) + "px"))))
            : void (e.style[l] = n);
        },
        l = function(t) {
          var e = t.dataset ? t.dataset.objectFit : t.getAttribute("data-object-fit"),
            l = t.dataset ? t.dataset.objectPosition : t.getAttribute("data-object-position");
          (e = e || "cover"), (l = l || "50% 50%");
          var a = t.parentNode;
          i(a),
            n(t),
            (t.style.position = "absolute"),
            (t.style.height = "100%"),
            (t.style.width = "auto"),
            "scale-down" === e &&
              ((t.style.height = "auto"),
              t.clientWidth < a.clientWidth && t.clientHeight < a.clientHeight
                ? (o("x", t, l), o("y", t, l))
                : ((e = "contain"), (t.style.height = "100%"))),
            "none" === e
              ? ((t.style.width = "auto"), (t.style.height = "auto"), o("x", t, l), o("y", t, l))
              : ("cover" === e && t.clientWidth > a.clientWidth) || ("contain" === e && t.clientWidth < a.clientWidth)
              ? ((t.style.top = "0"), (t.style.marginTop = "0"), o("x", t, l))
              : "scale-down" !== e &&
                ((t.style.width = "100%"),
                (t.style.height = "auto"),
                (t.style.left = "0"),
                (t.style.marginLeft = "0"),
                o("y", t, l));
        },
        a = function(t) {
          if (void 0 === t) t = document.querySelectorAll("[data-object-fit]");
          else if (t && t.nodeName) t = [t];
          else {
            if ("object" != typeof t || !t.length || !t[0].nodeName) return !1;
            t = t;
          }
          for (var i = 0; i < t.length; i++)
            if (t[i].nodeName) {
              var n = t[i].nodeName.toLowerCase();
              "img" !== n || e
                ? "video" === n &&
                  (t[i].readyState > 0
                    ? l(t[i])
                    : t[i].addEventListener("loadedmetadata", function() {
                        l(this);
                      }))
                : t[i].complete
                ? l(t[i])
                : t[i].addEventListener("load", function() {
                    l(this);
                  });
            }
          return !0;
        };
      document.addEventListener("DOMContentLoaded", function() {
        a();
      }),
        window.addEventListener("resize", function() {
          a();
        }),
        (window.objectFitPolyfill = a);
    }
  })();
  var adapter_no_global = createCommonjsModule(function(module) {
    (function() {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c) return c(i, !0);
              if (u) return u(i, !0);
              var a = new Error("Cannot find module '" + i + "'");
              throw ((a.code = "MODULE_NOT_FOUND"), a);
            }
            var p = (n[i] = { exports: {} });
            e[i][0].call(
              p.exports,
              function(r) {
                var n = e[i][1][r];
                return o(n || r);
              },
              p,
              p.exports,
              r,
              e,
              n,
              t
            );
          }
          return n[i].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++) o(t[i]);
        return o;
      }
      return r;
    })()(
      {
        1: [
          function(require, module, exports) {
            var _adapter_factory = require("./adapter_factory.js");
            var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
            module.exports = adapter;
          },
          { "./adapter_factory.js": 2 }
        ],
        2: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.adapterFactory = adapterFactory;
            var _utils = require("./utils");
            var utils = _interopRequireWildcard(_utils);
            var _chrome_shim = require("./chrome/chrome_shim");
            var chromeShim = _interopRequireWildcard(_chrome_shim);
            var _edge_shim = require("./edge/edge_shim");
            var edgeShim = _interopRequireWildcard(_edge_shim);
            var _firefox_shim = require("./firefox/firefox_shim");
            var firefoxShim = _interopRequireWildcard(_firefox_shim);
            var _safari_shim = require("./safari/safari_shim");
            var safariShim = _interopRequireWildcard(_safari_shim);
            var _common_shim = require("./common_shim");
            var commonShim = _interopRequireWildcard(_common_shim);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function adapterFactory() {
              var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                window = _ref.window;
              var options =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : { shimChrome: true, shimFirefox: true, shimEdge: true, shimSafari: true };
              var logging = utils.log;
              var browserDetails = utils.detectBrowser(window);
              var adapter = {
                browserDetails: browserDetails,
                commonShim: commonShim,
                extractVersion: utils.extractVersion,
                disableLog: utils.disableLog,
                disableWarnings: utils.disableWarnings
              };
              switch (browserDetails.browser) {
                case "chrome":
                  if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
                    logging("Chrome shim is not included in this adapter release.");
                    return adapter;
                  }
                  logging("adapter.js shimming chrome.");
                  adapter.browserShim = chromeShim;
                  chromeShim.shimGetUserMedia(window);
                  chromeShim.shimMediaStream(window);
                  chromeShim.shimPeerConnection(window);
                  chromeShim.shimOnTrack(window);
                  chromeShim.shimAddTrackRemoveTrack(window);
                  chromeShim.shimGetSendersWithDtmf(window);
                  chromeShim.shimSenderReceiverGetStats(window);
                  chromeShim.fixNegotiationNeeded(window);
                  commonShim.shimRTCIceCandidate(window);
                  commonShim.shimConnectionState(window);
                  commonShim.shimMaxMessageSize(window);
                  commonShim.shimSendThrowTypeError(window);
                  commonShim.removeAllowExtmapMixed(window);
                  break;
                case "firefox":
                  if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
                    logging("Firefox shim is not included in this adapter release.");
                    return adapter;
                  }
                  logging("adapter.js shimming firefox.");
                  adapter.browserShim = firefoxShim;
                  firefoxShim.shimGetUserMedia(window);
                  firefoxShim.shimPeerConnection(window);
                  firefoxShim.shimOnTrack(window);
                  firefoxShim.shimRemoveStream(window);
                  firefoxShim.shimSenderGetStats(window);
                  firefoxShim.shimReceiverGetStats(window);
                  firefoxShim.shimRTCDataChannel(window);
                  commonShim.shimRTCIceCandidate(window);
                  commonShim.shimConnectionState(window);
                  commonShim.shimMaxMessageSize(window);
                  commonShim.shimSendThrowTypeError(window);
                  break;
                case "edge":
                  if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                    logging("MS edge shim is not included in this adapter release.");
                    return adapter;
                  }
                  logging("adapter.js shimming edge.");
                  adapter.browserShim = edgeShim;
                  edgeShim.shimGetUserMedia(window);
                  edgeShim.shimGetDisplayMedia(window);
                  edgeShim.shimPeerConnection(window);
                  edgeShim.shimReplaceTrack(window);
                  commonShim.shimMaxMessageSize(window);
                  commonShim.shimSendThrowTypeError(window);
                  break;
                case "safari":
                  if (!safariShim || !options.shimSafari) {
                    logging("Safari shim is not included in this adapter release.");
                    return adapter;
                  }
                  logging("adapter.js shimming safari.");
                  adapter.browserShim = safariShim;
                  safariShim.shimRTCIceServerUrls(window);
                  safariShim.shimCreateOfferLegacy(window);
                  safariShim.shimCallbacksAPI(window);
                  safariShim.shimLocalStreamsAPI(window);
                  safariShim.shimRemoteStreamsAPI(window);
                  safariShim.shimTrackEventTransceiver(window);
                  safariShim.shimGetUserMedia(window);
                  commonShim.shimRTCIceCandidate(window);
                  commonShim.shimMaxMessageSize(window);
                  commonShim.shimSendThrowTypeError(window);
                  commonShim.removeAllowExtmapMixed(window);
                  break;
                default:
                  logging("Unsupported browser!");
              }
              return adapter;
            }
          },
          {
            "./chrome/chrome_shim": 3,
            "./common_shim": 6,
            "./edge/edge_shim": 7,
            "./firefox/firefox_shim": 11,
            "./safari/safari_shim": 14,
            "./utils": 15
          }
        ],
        3: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = exports.shimGetUserMedia = void 0;
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            var _getusermedia = require("./getusermedia");
            Object.defineProperty(exports, "shimGetUserMedia", {
              enumerable: true,
              get: function get() {
                return _getusermedia.shimGetUserMedia;
              }
            });
            var _getdisplaymedia = require("./getdisplaymedia");
            Object.defineProperty(exports, "shimGetDisplayMedia", {
              enumerable: true,
              get: function get() {
                return _getdisplaymedia.shimGetDisplayMedia;
              }
            });
            exports.shimMediaStream = shimMediaStream;
            exports.shimOnTrack = shimOnTrack;
            exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
            exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
            exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
            exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
            exports.shimPeerConnection = shimPeerConnection;
            exports.fixNegotiationNeeded = fixNegotiationNeeded;
            var _utils = require("../utils.js");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function walkStats(stats, base, resultSet) {
              if (!base || resultSet.has(base.id)) return;
              resultSet.set(base.id, base);
              Object.keys(base).forEach(function(name) {
                if (name.endsWith("Id")) walkStats(stats, stats.get(base[name]), resultSet);
                else if (name.endsWith("Ids"))
                  base[name].forEach(function(id) {
                    walkStats(stats, stats.get(id), resultSet);
                  });
              });
            }
            function filterStats(result, track, outbound) {
              var streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
              var filteredResult = new Map();
              if (null === track) return filteredResult;
              var trackStats = [];
              result.forEach(function(value) {
                if ("track" === value.type && value.trackIdentifier === track.id) trackStats.push(value);
              });
              trackStats.forEach(function(trackStat) {
                result.forEach(function(stats) {
                  if (stats.type === streamStatsType && stats.trackId === trackStat.id)
                    walkStats(result, stats, filteredResult);
                });
              });
              return filteredResult;
            }
            function shimMediaStream(window) {
              window.MediaStream = window.MediaStream || window.webkitMediaStream;
            }
            function shimOnTrack(window) {
              if (
                "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                window.RTCPeerConnection &&
                !("ontrack" in window.RTCPeerConnection.prototype)
              ) {
                Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
                  get: function get() {
                    return this._ontrack;
                  },
                  set: function set(f) {
                    if (this._ontrack) this.removeEventListener("track", this._ontrack);
                    this.addEventListener("track", (this._ontrack = f));
                  },
                  enumerable: true,
                  configurable: true
                });
                var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
                window.RTCPeerConnection.prototype.setRemoteDescription = function() {
                  var _this = this;
                  if (!this._ontrackpoly) {
                    this._ontrackpoly = function(e) {
                      e.stream.addEventListener("addtrack", function(te) {
                        var receiver = void 0;
                        if (window.RTCPeerConnection.prototype.getReceivers)
                          receiver = _this.getReceivers().find(function(r) {
                            return r.track && r.track.id === te.track.id;
                          });
                        else receiver = { track: te.track };
                        var event = new Event("track");
                        event.track = te.track;
                        event.receiver = receiver;
                        event.transceiver = { receiver: receiver };
                        event.streams = [e.stream];
                        _this.dispatchEvent(event);
                      });
                      e.stream.getTracks().forEach(function(track) {
                        var receiver = void 0;
                        if (window.RTCPeerConnection.prototype.getReceivers)
                          receiver = _this.getReceivers().find(function(r) {
                            return r.track && r.track.id === track.id;
                          });
                        else receiver = { track: track };
                        var event = new Event("track");
                        event.track = track;
                        event.receiver = receiver;
                        event.transceiver = { receiver: receiver };
                        event.streams = [e.stream];
                        _this.dispatchEvent(event);
                      });
                    };
                    this.addEventListener("addstream", this._ontrackpoly);
                  }
                  return origSetRemoteDescription.apply(this, arguments);
                };
              } else
                utils.wrapPeerConnectionEvent(window, "track", function(e) {
                  if (!e.transceiver) Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } });
                  return e;
                });
            }
            function shimGetSendersWithDtmf(window) {
              if (
                "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                window.RTCPeerConnection &&
                !("getSenders" in window.RTCPeerConnection.prototype) &&
                "createDTMFSender" in window.RTCPeerConnection.prototype
              ) {
                var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
                  return {
                    track: track,
                    get dtmf() {
                      if (void 0 === this._dtmf)
                        if ("audio" === track.kind) this._dtmf = pc.createDTMFSender(track);
                        else this._dtmf = null;
                      return this._dtmf;
                    },
                    _pc: pc
                  };
                };
                if (!window.RTCPeerConnection.prototype.getSenders) {
                  window.RTCPeerConnection.prototype.getSenders = function() {
                    this._senders = this._senders || [];
                    return this._senders.slice();
                  };
                  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                  window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                    var sender = origAddTrack.apply(this, arguments);
                    if (!sender) {
                      sender = shimSenderWithDtmf(this, track);
                      this._senders.push(sender);
                    }
                    return sender;
                  };
                  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
                  window.RTCPeerConnection.prototype.removeTrack = function(sender) {
                    origRemoveTrack.apply(this, arguments);
                    var idx = this._senders.indexOf(sender);
                    if (-1 !== idx) this._senders.splice(idx, 1);
                  };
                }
                var origAddStream = window.RTCPeerConnection.prototype.addStream;
                window.RTCPeerConnection.prototype.addStream = function(stream) {
                  var _this2 = this;
                  this._senders = this._senders || [];
                  origAddStream.apply(this, [stream]);
                  stream.getTracks().forEach(function(track) {
                    _this2._senders.push(shimSenderWithDtmf(_this2, track));
                  });
                };
                var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                window.RTCPeerConnection.prototype.removeStream = function(stream) {
                  var _this3 = this;
                  this._senders = this._senders || [];
                  origRemoveStream.apply(this, [stream]);
                  stream.getTracks().forEach(function(track) {
                    var sender = _this3._senders.find(function(s) {
                      return s.track === track;
                    });
                    if (sender) _this3._senders.splice(_this3._senders.indexOf(sender), 1);
                  });
                };
              } else if (
                "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                window.RTCPeerConnection &&
                "getSenders" in window.RTCPeerConnection.prototype &&
                "createDTMFSender" in window.RTCPeerConnection.prototype &&
                window.RTCRtpSender &&
                !("dtmf" in window.RTCRtpSender.prototype)
              ) {
                var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                window.RTCPeerConnection.prototype.getSenders = function() {
                  var _this4 = this;
                  var senders = origGetSenders.apply(this, []);
                  senders.forEach(function(sender) {
                    return (sender._pc = _this4);
                  });
                  return senders;
                };
                Object.defineProperty(window.RTCRtpSender.prototype, "dtmf", {
                  get: function get() {
                    if (void 0 === this._dtmf)
                      if ("audio" === this.track.kind) this._dtmf = this._pc.createDTMFSender(this.track);
                      else this._dtmf = null;
                    return this._dtmf;
                  }
                });
              }
            }
            function shimSenderReceiverGetStats(window) {
              if (
                !(
                  "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                  window.RTCPeerConnection &&
                  window.RTCRtpSender &&
                  window.RTCRtpReceiver
                )
              )
                return;
              if (!("getStats" in window.RTCRtpSender.prototype)) {
                var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                if (origGetSenders)
                  window.RTCPeerConnection.prototype.getSenders = function() {
                    var _this5 = this;
                    var senders = origGetSenders.apply(this, []);
                    senders.forEach(function(sender) {
                      return (sender._pc = _this5);
                    });
                    return senders;
                  };
                var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                if (origAddTrack)
                  window.RTCPeerConnection.prototype.addTrack = function() {
                    var sender = origAddTrack.apply(this, arguments);
                    sender._pc = this;
                    return sender;
                  };
                window.RTCRtpSender.prototype.getStats = function() {
                  var sender = this;
                  return this._pc.getStats().then(function(result) {
                    return filterStats(result, sender.track, true);
                  });
                };
              }
              if (!("getStats" in window.RTCRtpReceiver.prototype)) {
                var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
                if (origGetReceivers)
                  window.RTCPeerConnection.prototype.getReceivers = function() {
                    var _this6 = this;
                    var receivers = origGetReceivers.apply(this, []);
                    receivers.forEach(function(receiver) {
                      return (receiver._pc = _this6);
                    });
                    return receivers;
                  };
                utils.wrapPeerConnectionEvent(window, "track", function(e) {
                  e.receiver._pc = e.srcElement;
                  return e;
                });
                window.RTCRtpReceiver.prototype.getStats = function() {
                  var receiver = this;
                  return this._pc.getStats().then(function(result) {
                    return filterStats(result, receiver.track, false);
                  });
                };
              }
              if (!("getStats" in window.RTCRtpSender.prototype && "getStats" in window.RTCRtpReceiver.prototype))
                return;
              var origGetStats = window.RTCPeerConnection.prototype.getStats;
              window.RTCPeerConnection.prototype.getStats = function() {
                if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
                  var track = arguments[0];
                  var sender = void 0;
                  var receiver = void 0;
                  var err = void 0;
                  this.getSenders().forEach(function(s) {
                    if (s.track === track)
                      if (sender) err = true;
                      else sender = s;
                  });
                  this.getReceivers().forEach(function(r) {
                    if (r.track === track)
                      if (receiver) err = true;
                      else receiver = r;
                    return r.track === track;
                  });
                  if (err || (sender && receiver))
                    return Promise.reject(
                      new DOMException(
                        "There are more than one sender or receiver for the track.",
                        "InvalidAccessError"
                      )
                    );
                  else if (sender) return sender.getStats();
                  else if (receiver) return receiver.getStats();
                  return Promise.reject(
                    new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")
                  );
                }
                return origGetStats.apply(this, arguments);
              };
            }
            function shimAddTrackRemoveTrackWithNative(window) {
              window.RTCPeerConnection.prototype.getLocalStreams = function() {
                var _this7 = this;
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
                  return _this7._shimmedLocalStreams[streamId][0];
                });
              };
              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
              window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                if (!stream) return origAddTrack.apply(this, arguments);
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                var sender = origAddTrack.apply(this, arguments);
                if (!this._shimmedLocalStreams[stream.id]) this._shimmedLocalStreams[stream.id] = [stream, sender];
                else if (-1 === this._shimmedLocalStreams[stream.id].indexOf(sender))
                  this._shimmedLocalStreams[stream.id].push(sender);
                return sender;
              };
              var origAddStream = window.RTCPeerConnection.prototype.addStream;
              window.RTCPeerConnection.prototype.addStream = function(stream) {
                var _this8 = this;
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                stream.getTracks().forEach(function(track) {
                  var alreadyExists = _this8.getSenders().find(function(s) {
                    return s.track === track;
                  });
                  if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
                });
                var existingSenders = this.getSenders();
                origAddStream.apply(this, arguments);
                var newSenders = this.getSenders().filter(function(newSender) {
                  return -1 === existingSenders.indexOf(newSender);
                });
                this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
              };
              var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
              window.RTCPeerConnection.prototype.removeStream = function(stream) {
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                delete this._shimmedLocalStreams[stream.id];
                return origRemoveStream.apply(this, arguments);
              };
              var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
              window.RTCPeerConnection.prototype.removeTrack = function(sender) {
                var _this9 = this;
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                if (sender)
                  Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
                    var idx = _this9._shimmedLocalStreams[streamId].indexOf(sender);
                    if (-1 !== idx) _this9._shimmedLocalStreams[streamId].splice(idx, 1);
                    if (1 === _this9._shimmedLocalStreams[streamId].length)
                      delete _this9._shimmedLocalStreams[streamId];
                  });
                return origRemoveTrack.apply(this, arguments);
              };
            }
            function shimAddTrackRemoveTrack(window) {
              if (!window.RTCPeerConnection) return;
              var browserDetails = utils.detectBrowser(window);
              if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65)
                return shimAddTrackRemoveTrackWithNative(window);
              var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
              window.RTCPeerConnection.prototype.getLocalStreams = function() {
                var _this10 = this;
                var nativeStreams = origGetLocalStreams.apply(this);
                this._reverseStreams = this._reverseStreams || {};
                return nativeStreams.map(function(stream) {
                  return _this10._reverseStreams[stream.id];
                });
              };
              var origAddStream = window.RTCPeerConnection.prototype.addStream;
              window.RTCPeerConnection.prototype.addStream = function(stream) {
                var _this11 = this;
                this._streams = this._streams || {};
                this._reverseStreams = this._reverseStreams || {};
                stream.getTracks().forEach(function(track) {
                  var alreadyExists = _this11.getSenders().find(function(s) {
                    return s.track === track;
                  });
                  if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
                });
                if (!this._reverseStreams[stream.id]) {
                  var newStream = new window.MediaStream(stream.getTracks());
                  this._streams[stream.id] = newStream;
                  this._reverseStreams[newStream.id] = stream;
                  stream = newStream;
                }
                origAddStream.apply(this, [stream]);
              };
              var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
              window.RTCPeerConnection.prototype.removeStream = function(stream) {
                this._streams = this._streams || {};
                this._reverseStreams = this._reverseStreams || {};
                origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
                delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
                delete this._streams[stream.id];
              };
              window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                var _this12 = this;
                if ("closed" === this.signalingState)
                  throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                var streams = [].slice.call(arguments, 1);
                if (
                  1 !== streams.length ||
                  !streams[0].getTracks().find(function(t) {
                    return t === track;
                  })
                )
                  throw new DOMException(
                    "The adapter.js addTrack polyfill only supports a single " +
                      " stream which is associated with the specified track.",
                    "NotSupportedError"
                  );
                var alreadyExists = this.getSenders().find(function(s) {
                  return s.track === track;
                });
                if (alreadyExists) throw new DOMException("Track already exists.", "InvalidAccessError");
                this._streams = this._streams || {};
                this._reverseStreams = this._reverseStreams || {};
                var oldStream = this._streams[stream.id];
                if (oldStream) {
                  oldStream.addTrack(track);
                  Promise.resolve().then(function() {
                    _this12.dispatchEvent(new Event("negotiationneeded"));
                  });
                } else {
                  var newStream = new window.MediaStream([track]);
                  this._streams[stream.id] = newStream;
                  this._reverseStreams[newStream.id] = stream;
                  this.addStream(newStream);
                }
                return this.getSenders().find(function(s) {
                  return s.track === track;
                });
              };
              function replaceInternalStreamId(pc, description) {
                var sdp = description.sdp;
                Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
                  var externalStream = pc._reverseStreams[internalId];
                  var internalStream = pc._streams[externalStream.id];
                  sdp = sdp.replace(new RegExp(internalStream.id, "g"), externalStream.id);
                });
                return new RTCSessionDescription({ type: description.type, sdp: sdp });
              }
              function replaceExternalStreamId(pc, description) {
                var sdp = description.sdp;
                Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
                  var externalStream = pc._reverseStreams[internalId];
                  var internalStream = pc._streams[externalStream.id];
                  sdp = sdp.replace(new RegExp(externalStream.id, "g"), internalStream.id);
                });
                return new RTCSessionDescription({ type: description.type, sdp: sdp });
              }
              ["createOffer", "createAnswer"].forEach(function(method) {
                var nativeMethod = window.RTCPeerConnection.prototype[method];
                window.RTCPeerConnection.prototype[method] = function() {
                  var _this13 = this;
                  var args = arguments;
                  var isLegacyCall = arguments.length && "function" === typeof arguments[0];
                  if (isLegacyCall)
                    return nativeMethod.apply(this, [
                      function(description) {
                        var desc = replaceInternalStreamId(_this13, description);
                        args[0].apply(null, [desc]);
                      },
                      function(err) {
                        if (args[1]) args[1].apply(null, err);
                      },
                      arguments[2]
                    ]);
                  return nativeMethod.apply(this, arguments).then(function(description) {
                    return replaceInternalStreamId(_this13, description);
                  });
                };
              });
              var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
              window.RTCPeerConnection.prototype.setLocalDescription = function() {
                if (!arguments.length || !arguments[0].type) return origSetLocalDescription.apply(this, arguments);
                arguments[0] = replaceExternalStreamId(this, arguments[0]);
                return origSetLocalDescription.apply(this, arguments);
              };
              var origLocalDescription = Object.getOwnPropertyDescriptor(
                window.RTCPeerConnection.prototype,
                "localDescription"
              );
              Object.defineProperty(window.RTCPeerConnection.prototype, "localDescription", {
                get: function get() {
                  var description = origLocalDescription.get.apply(this);
                  if ("" === description.type) return description;
                  return replaceInternalStreamId(this, description);
                }
              });
              window.RTCPeerConnection.prototype.removeTrack = function(sender) {
                var _this14 = this;
                if ("closed" === this.signalingState)
                  throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                if (!sender._pc)
                  throw new DOMException(
                    "Argument 1 of RTCPeerConnection.removeTrack " + "does not implement interface RTCRtpSender.",
                    "TypeError"
                  );
                var isLocal = sender._pc === this;
                if (!isLocal)
                  throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                this._streams = this._streams || {};
                var stream = void 0;
                Object.keys(this._streams).forEach(function(streamid) {
                  var hasTrack = _this14._streams[streamid].getTracks().find(function(track) {
                    return sender.track === track;
                  });
                  if (hasTrack) stream = _this14._streams[streamid];
                });
                if (stream) {
                  if (1 === stream.getTracks().length) this.removeStream(this._reverseStreams[stream.id]);
                  else stream.removeTrack(sender.track);
                  this.dispatchEvent(new Event("negotiationneeded"));
                }
              };
            }
            function shimPeerConnection(window) {
              if (!window.RTCPeerConnection && window.webkitRTCPeerConnection)
                window.RTCPeerConnection = window.webkitRTCPeerConnection;
              if (!window.RTCPeerConnection) return;
              var origGetStats = window.RTCPeerConnection.prototype.getStats;
              window.RTCPeerConnection.prototype.getStats = function(selector, successCallback, errorCallback) {
                var _this15 = this;
                var args = arguments;
                if (arguments.length > 0 && "function" === typeof selector) return origGetStats.apply(this, arguments);
                if (0 === origGetStats.length && (0 === arguments.length || "function" !== typeof arguments[0]))
                  return origGetStats.apply(this, []);
                var fixChromeStats_ = function fixChromeStats_(response) {
                  var standardReport = {};
                  var reports = response.result();
                  reports.forEach(function(report) {
                    var standardStats = {
                      id: report.id,
                      timestamp: report.timestamp,
                      type:
                        { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[report.type] ||
                        report.type
                    };
                    report.names().forEach(function(name) {
                      standardStats[name] = report.stat(name);
                    });
                    standardReport[standardStats.id] = standardStats;
                  });
                  return standardReport;
                };
                var makeMapStats = function makeMapStats(stats) {
                  return new Map(
                    Object.keys(stats).map(function(key) {
                      return [key, stats[key]];
                    })
                  );
                };
                if (arguments.length >= 2) {
                  var successCallbackWrapper_ = function successCallbackWrapper_(response) {
                    args[1](makeMapStats(fixChromeStats_(response)));
                  };
                  return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
                }
                return new Promise(function(resolve, reject) {
                  origGetStats.apply(_this15, [
                    function(response) {
                      resolve(makeMapStats(fixChromeStats_(response)));
                    },
                    reject
                  ]);
                }).then(successCallback, errorCallback);
              };
              ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
                var nativeMethod = window.RTCPeerConnection.prototype[method];
                window.RTCPeerConnection.prototype[method] = function() {
                  arguments[0] = new ("addIceCandidate" === method
                    ? window.RTCIceCandidate
                    : window.RTCSessionDescription)(arguments[0]);
                  return nativeMethod.apply(this, arguments);
                };
              });
              var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
              window.RTCPeerConnection.prototype.addIceCandidate = function() {
                if (!arguments[0]) {
                  if (arguments[1]) arguments[1].apply(null);
                  return Promise.resolve();
                }
                return nativeAddIceCandidate.apply(this, arguments);
              };
            }
            function fixNegotiationNeeded(window) {
              utils.wrapPeerConnectionEvent(window, "negotiationneeded", function(e) {
                var pc = e.target;
                if ("stable" !== pc.signalingState) return;
                return e;
              });
            }
          },
          { "../utils.js": 15, "./getdisplaymedia": 4, "./getusermedia": 5 }
        ],
        4: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = shimGetDisplayMedia;
            function shimGetDisplayMedia(window, getSourceId) {
              if (window.navigator.mediaDevices && "getDisplayMedia" in window.navigator.mediaDevices) return;
              if (!window.navigator.mediaDevices) return;
              if ("function" !== typeof getSourceId) {
                console.error("shimGetDisplayMedia: getSourceId argument is not " + "a function");
                return;
              }
              window.navigator.mediaDevices.getDisplayMedia = function(constraints) {
                return getSourceId(constraints).then(function(sourceId) {
                  var widthSpecified = constraints.video && constraints.video.width;
                  var heightSpecified = constraints.video && constraints.video.height;
                  var frameRateSpecified = constraints.video && constraints.video.frameRate;
                  constraints.video = {
                    mandatory: {
                      chromeMediaSource: "desktop",
                      chromeMediaSourceId: sourceId,
                      maxFrameRate: frameRateSpecified || 3
                    }
                  };
                  if (widthSpecified) constraints.video.mandatory.maxWidth = widthSpecified;
                  if (heightSpecified) constraints.video.mandatory.maxHeight = heightSpecified;
                  return window.navigator.mediaDevices.getUserMedia(constraints);
                });
              };
            }
          },
          {}
        ],
        5: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            exports.shimGetUserMedia = shimGetUserMedia;
            var _utils = require("../utils.js");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            var logging = utils.log;
            function shimGetUserMedia(window) {
              var navigator = window && window.navigator;
              if (!navigator.mediaDevices) return;
              var browserDetails = utils.detectBrowser(window);
              var constraintsToChrome_ = function constraintsToChrome_(c) {
                if ("object" !== ("undefined" === typeof c ? "undefined" : _typeof(c)) || c.mandatory || c.optional)
                  return c;
                var cc = {};
                Object.keys(c).forEach(function(key) {
                  if ("require" === key || "advanced" === key || "mediaSource" === key) return;
                  var r = "object" === _typeof(c[key]) ? c[key] : { ideal: c[key] };
                  if (void 0 !== r.exact && "number" === typeof r.exact) r.min = r.max = r.exact;
                  var oldname_ = function oldname_(prefix, name) {
                    if (prefix) return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                    return "deviceId" === name ? "sourceId" : name;
                  };
                  if (void 0 !== r.ideal) {
                    cc.optional = cc.optional || [];
                    var oc = {};
                    if ("number" === typeof r.ideal) {
                      oc[oldname_("min", key)] = r.ideal;
                      cc.optional.push(oc);
                      oc = {};
                      oc[oldname_("max", key)] = r.ideal;
                      cc.optional.push(oc);
                    } else {
                      oc[oldname_("", key)] = r.ideal;
                      cc.optional.push(oc);
                    }
                  }
                  if (void 0 !== r.exact && "number" !== typeof r.exact) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname_("", key)] = r.exact;
                  } else
                    ["min", "max"].forEach(function(mix) {
                      if (void 0 !== r[mix]) {
                        cc.mandatory = cc.mandatory || {};
                        cc.mandatory[oldname_(mix, key)] = r[mix];
                      }
                    });
                });
                if (c.advanced) cc.optional = (cc.optional || []).concat(c.advanced);
                return cc;
              };
              var shimConstraints_ = function shimConstraints_(constraints, func) {
                if (browserDetails.version >= 61) return func(constraints);
                constraints = JSON.parse(JSON.stringify(constraints));
                if (constraints && "object" === _typeof(constraints.audio)) {
                  var remap = function remap(obj, a, b) {
                    if (a in obj && !(b in obj)) {
                      obj[b] = obj[a];
                      delete obj[a];
                    }
                  };
                  constraints = JSON.parse(JSON.stringify(constraints));
                  remap(constraints.audio, "autoGainControl", "googAutoGainControl");
                  remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
                  constraints.audio = constraintsToChrome_(constraints.audio);
                }
                if (constraints && "object" === _typeof(constraints.video)) {
                  var face = constraints.video.facingMode;
                  face =
                    face &&
                    ("object" === ("undefined" === typeof face ? "undefined" : _typeof(face)) ? face : { ideal: face });
                  var getSupportedFacingModeLies = browserDetails.version < 66;
                  if (
                    face &&
                    ("user" === face.exact ||
                      "environment" === face.exact ||
                      "user" === face.ideal ||
                      "environment" === face.ideal) &&
                    !(
                      navigator.mediaDevices.getSupportedConstraints &&
                      navigator.mediaDevices.getSupportedConstraints().facingMode &&
                      !getSupportedFacingModeLies
                    )
                  ) {
                    delete constraints.video.facingMode;
                    var matches = void 0;
                    if ("environment" === face.exact || "environment" === face.ideal) matches = ["back", "rear"];
                    else if ("user" === face.exact || "user" === face.ideal) matches = ["front"];
                    if (matches)
                      return navigator.mediaDevices.enumerateDevices().then(function(devices) {
                        devices = devices.filter(function(d) {
                          return "videoinput" === d.kind;
                        });
                        var dev = devices.find(function(d) {
                          return matches.some(function(match) {
                            return d.label.toLowerCase().includes(match);
                          });
                        });
                        if (!dev && devices.length && matches.includes("back")) dev = devices[devices.length - 1];
                        if (dev)
                          constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
                        constraints.video = constraintsToChrome_(constraints.video);
                        logging("chrome: " + JSON.stringify(constraints));
                        return func(constraints);
                      });
                  }
                  constraints.video = constraintsToChrome_(constraints.video);
                }
                logging("chrome: " + JSON.stringify(constraints));
                return func(constraints);
              };
              var shimError_ = function shimError_(e) {
                if (browserDetails.version >= 64) return e;
                return {
                  name:
                    {
                      PermissionDeniedError: "NotAllowedError",
                      PermissionDismissedError: "NotAllowedError",
                      InvalidStateError: "NotAllowedError",
                      DevicesNotFoundError: "NotFoundError",
                      ConstraintNotSatisfiedError: "OverconstrainedError",
                      TrackStartError: "NotReadableError",
                      MediaDeviceFailedDueToShutdown: "NotAllowedError",
                      MediaDeviceKillSwitchOn: "NotAllowedError",
                      TabCaptureError: "AbortError",
                      ScreenCaptureError: "AbortError",
                      DeviceCaptureError: "AbortError"
                    }[e.name] || e.name,
                  message: e.message,
                  constraint: e.constraint || e.constraintName,
                  toString: function toString() {
                    return this.name + (this.message && ": ") + this.message;
                  }
                };
              };
              var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
                shimConstraints_(constraints, function(c) {
                  navigator.webkitGetUserMedia(c, onSuccess, function(e) {
                    if (onError) onError(shimError_(e));
                  });
                });
              };
              navigator.getUserMedia = getUserMedia_.bind(navigator);
              var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
              navigator.mediaDevices.getUserMedia = function(cs) {
                return shimConstraints_(cs, function(c) {
                  return origGetUserMedia(c).then(
                    function(stream) {
                      if (
                        (c.audio && !stream.getAudioTracks().length) ||
                        (c.video && !stream.getVideoTracks().length)
                      ) {
                        stream.getTracks().forEach(function(track) {
                          track.stop();
                        });
                        throw new DOMException("", "NotFoundError");
                      }
                      return stream;
                    },
                    function(e) {
                      return Promise.reject(shimError_(e));
                    }
                  );
                });
              };
            }
          },
          { "../utils.js": 15 }
        ],
        6: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            exports.shimRTCIceCandidate = shimRTCIceCandidate;
            exports.shimMaxMessageSize = shimMaxMessageSize;
            exports.shimSendThrowTypeError = shimSendThrowTypeError;
            exports.shimConnectionState = shimConnectionState;
            exports.removeAllowExtmapMixed = removeAllowExtmapMixed;
            var _sdp = require("sdp");
            var _sdp2 = _interopRequireDefault(_sdp);
            var _utils = require("./utils");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function shimRTCIceCandidate(window) {
              if (
                !window.RTCIceCandidate ||
                (window.RTCIceCandidate && "foundation" in window.RTCIceCandidate.prototype)
              )
                return;
              var NativeRTCIceCandidate = window.RTCIceCandidate;
              window.RTCIceCandidate = function(args) {
                if (
                  "object" === ("undefined" === typeof args ? "undefined" : _typeof(args)) &&
                  args.candidate &&
                  0 === args.candidate.indexOf("a=")
                ) {
                  args = JSON.parse(JSON.stringify(args));
                  args.candidate = args.candidate.substr(2);
                }
                if (args.candidate && args.candidate.length) {
                  var nativeCandidate = new NativeRTCIceCandidate(args);
                  var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
                  var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);
                  augmentedCandidate.toJSON = function() {
                    return {
                      candidate: augmentedCandidate.candidate,
                      sdpMid: augmentedCandidate.sdpMid,
                      sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                      usernameFragment: augmentedCandidate.usernameFragment
                    };
                  };
                  return augmentedCandidate;
                }
                return new NativeRTCIceCandidate(args);
              };
              window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
              utils.wrapPeerConnectionEvent(window, "icecandidate", function(e) {
                if (e.candidate)
                  Object.defineProperty(e, "candidate", {
                    value: new window.RTCIceCandidate(e.candidate),
                    writable: "false"
                  });
                return e;
              });
            }
            function shimMaxMessageSize(window) {
              if (window.RTCSctpTransport || !window.RTCPeerConnection) return;
              var browserDetails = utils.detectBrowser(window);
              if (!("sctp" in window.RTCPeerConnection.prototype))
                Object.defineProperty(window.RTCPeerConnection.prototype, "sctp", {
                  get: function get() {
                    return "undefined" === typeof this._sctp ? null : this._sctp;
                  }
                });
              var sctpInDescription = function sctpInDescription(description) {
                var sections = _sdp2.default.splitSections(description.sdp);
                sections.shift();
                return sections.some(function(mediaSection) {
                  var mLine = _sdp2.default.parseMLine(mediaSection);
                  return mLine && "application" === mLine.kind && -1 !== mLine.protocol.indexOf("SCTP");
                });
              };
              var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
                var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                if (null === match || match.length < 2) return -1;
                var version = parseInt(match[1], 10);
                return version !== version ? -1 : version;
              };
              var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
                var canSendMaxMessageSize = 65536;
                if ("firefox" === browserDetails.browser)
                  if (browserDetails.version < 57)
                    if (-1 === remoteIsFirefox) canSendMaxMessageSize = 16384;
                    else canSendMaxMessageSize = 2147483637;
                  else if (browserDetails.version < 60)
                    canSendMaxMessageSize = 57 === browserDetails.version ? 65535 : 65536;
                  else canSendMaxMessageSize = 2147483637;
                return canSendMaxMessageSize;
              };
              var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
                var maxMessageSize = 65536;
                if ("firefox" === browserDetails.browser && 57 === browserDetails.version) maxMessageSize = 65535;
                var match = _sdp2.default.matchPrefix(description.sdp, "a=max-message-size:");
                if (match.length > 0) maxMessageSize = parseInt(match[0].substr(19), 10);
                else if ("firefox" === browserDetails.browser && -1 !== remoteIsFirefox) maxMessageSize = 2147483637;
                return maxMessageSize;
              };
              var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
              window.RTCPeerConnection.prototype.setRemoteDescription = function() {
                this._sctp = null;
                if (sctpInDescription(arguments[0])) {
                  var isFirefox = getRemoteFirefoxVersion(arguments[0]);
                  var canSendMMS = getCanSendMaxMessageSize(isFirefox);
                  var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
                  var maxMessageSize = void 0;
                  if (0 === canSendMMS && 0 === remoteMMS) maxMessageSize = Number.POSITIVE_INFINITY;
                  else if (0 === canSendMMS || 0 === remoteMMS) maxMessageSize = Math.max(canSendMMS, remoteMMS);
                  else maxMessageSize = Math.min(canSendMMS, remoteMMS);
                  var sctp = {};
                  Object.defineProperty(sctp, "maxMessageSize", {
                    get: function get() {
                      return maxMessageSize;
                    }
                  });
                  this._sctp = sctp;
                }
                return origSetRemoteDescription.apply(this, arguments);
              };
            }
            function shimSendThrowTypeError(window) {
              if (!(window.RTCPeerConnection && "createDataChannel" in window.RTCPeerConnection.prototype)) return;
              function wrapDcSend(dc, pc) {
                var origDataChannelSend = dc.send;
                dc.send = function() {
                  var data = arguments[0];
                  var length = data.length || data.size || data.byteLength;
                  if ("open" === dc.readyState && pc.sctp && length > pc.sctp.maxMessageSize)
                    throw new TypeError(
                      "Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)"
                    );
                  return origDataChannelSend.apply(dc, arguments);
                };
              }
              var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
              window.RTCPeerConnection.prototype.createDataChannel = function() {
                var dataChannel = origCreateDataChannel.apply(this, arguments);
                wrapDcSend(dataChannel, this);
                return dataChannel;
              };
              utils.wrapPeerConnectionEvent(window, "datachannel", function(e) {
                wrapDcSend(e.channel, e.target);
                return e;
              });
            }
            function shimConnectionState(window) {
              if (!window.RTCPeerConnection || "connectionState" in window.RTCPeerConnection.prototype) return;
              var proto = window.RTCPeerConnection.prototype;
              Object.defineProperty(proto, "connectionState", {
                get: function get() {
                  return (
                    { completed: "connected", checking: "connecting" }[this.iceConnectionState] ||
                    this.iceConnectionState
                  );
                },
                enumerable: true,
                configurable: true
              });
              Object.defineProperty(proto, "onconnectionstatechange", {
                get: function get() {
                  return this._onconnectionstatechange || null;
                },
                set: function set(cb) {
                  if (this._onconnectionstatechange) {
                    this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
                    delete this._onconnectionstatechange;
                  }
                  if (cb) this.addEventListener("connectionstatechange", (this._onconnectionstatechange = cb));
                },
                enumerable: true,
                configurable: true
              });
              ["setLocalDescription", "setRemoteDescription"].forEach(function(method) {
                var origMethod = proto[method];
                proto[method] = function() {
                  if (!this._connectionstatechangepoly) {
                    this._connectionstatechangepoly = function(e) {
                      var pc = e.target;
                      if (pc._lastConnectionState !== pc.connectionState) {
                        pc._lastConnectionState = pc.connectionState;
                        var newEvent = new Event("connectionstatechange", e);
                        pc.dispatchEvent(newEvent);
                      }
                      return e;
                    };
                    this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
                  }
                  return origMethod.apply(this, arguments);
                };
              });
            }
            function removeAllowExtmapMixed(window) {
              if (!window.RTCPeerConnection) return;
              var browserDetails = utils.detectBrowser(window);
              if ("chrome" === browserDetails.browser && browserDetails.version >= 71) return;
              var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
              window.RTCPeerConnection.prototype.setRemoteDescription = function(desc) {
                if (desc && desc.sdp && -1 !== desc.sdp.indexOf("\na=extmap-allow-mixed"))
                  desc.sdp = desc.sdp
                    .split("\n")
                    .filter(function(line) {
                      return "a=extmap-allow-mixed" !== line.trim();
                    })
                    .join("\n");
                return nativeSRD.apply(this, arguments);
              };
            }
          },
          { "./utils": 15, sdp: 17 }
        ],
        7: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = exports.shimGetUserMedia = void 0;
            var _getusermedia = require("./getusermedia");
            Object.defineProperty(exports, "shimGetUserMedia", {
              enumerable: true,
              get: function get() {
                return _getusermedia.shimGetUserMedia;
              }
            });
            var _getdisplaymedia = require("./getdisplaymedia");
            Object.defineProperty(exports, "shimGetDisplayMedia", {
              enumerable: true,
              get: function get() {
                return _getdisplaymedia.shimGetDisplayMedia;
              }
            });
            exports.shimPeerConnection = shimPeerConnection;
            exports.shimReplaceTrack = shimReplaceTrack;
            var _utils = require("../utils");
            var utils = _interopRequireWildcard(_utils);
            var _filtericeservers = require("./filtericeservers");
            var _rtcpeerconnectionShim = require("rtcpeerconnection-shim");
            var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function shimPeerConnection(window) {
              var browserDetails = utils.detectBrowser(window);
              if (window.RTCIceGatherer) {
                if (!window.RTCIceCandidate)
                  window.RTCIceCandidate = function(args) {
                    return args;
                  };
                if (!window.RTCSessionDescription)
                  window.RTCSessionDescription = function(args) {
                    return args;
                  };
                if (browserDetails.version < 15025) {
                  var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, "enabled");
                  Object.defineProperty(window.MediaStreamTrack.prototype, "enabled", {
                    set: function set(value) {
                      origMSTEnabled.set.call(this, value);
                      var ev = new Event("enabled");
                      ev.enabled = value;
                      this.dispatchEvent(ev);
                    }
                  });
                }
              }
              if (window.RTCRtpSender && !("dtmf" in window.RTCRtpSender.prototype))
                Object.defineProperty(window.RTCRtpSender.prototype, "dtmf", {
                  get: function get() {
                    if (void 0 === this._dtmf)
                      if ("audio" === this.track.kind) this._dtmf = new window.RTCDtmfSender(this);
                      else if ("video" === this.track.kind) this._dtmf = null;
                    return this._dtmf;
                  }
                });
              if (window.RTCDtmfSender && !window.RTCDTMFSender) window.RTCDTMFSender = window.RTCDtmfSender;
              var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
              window.RTCPeerConnection = function(config) {
                if (config && config.iceServers) {
                  config.iceServers = (0, _filtericeservers.filterIceServers)(
                    config.iceServers,
                    browserDetails.version
                  );
                  utils.log("ICE servers after filtering:", config.iceServers);
                }
                return new RTCPeerConnectionShim(config);
              };
              window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
            }
            function shimReplaceTrack(window) {
              if (window.RTCRtpSender && !("replaceTrack" in window.RTCRtpSender.prototype))
                window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
            }
          },
          {
            "../utils": 15,
            "./filtericeservers": 8,
            "./getdisplaymedia": 9,
            "./getusermedia": 10,
            "rtcpeerconnection-shim": 16
          }
        ],
        8: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.filterIceServers = filterIceServers;
            var _utils = require("../utils");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function filterIceServers(iceServers, edgeVersion) {
              var hasTurn = false;
              iceServers = JSON.parse(JSON.stringify(iceServers));
              return iceServers.filter(function(server) {
                if (server && (server.urls || server.url)) {
                  var urls = server.urls || server.url;
                  if (server.url && !server.urls) utils.deprecated("RTCIceServer.url", "RTCIceServer.urls");
                  var isString = "string" === typeof urls;
                  if (isString) urls = [urls];
                  urls = urls.filter(function(url) {
                    if (0 === url.indexOf("stun:")) return false;
                    var validTurn =
                      url.startsWith("turn") && !url.startsWith("turn:[") && url.includes("transport=udp");
                    if (validTurn && !hasTurn) {
                      hasTurn = true;
                      return true;
                    }
                    return validTurn && !hasTurn;
                  });
                  delete server.url;
                  server.urls = isString ? urls[0] : urls;
                  return !!urls.length;
                }
              });
            }
          },
          { "../utils": 15 }
        ],
        9: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = shimGetDisplayMedia;
            function shimGetDisplayMedia(window) {
              if (!("getDisplayMedia" in window.navigator)) return;
              if (!window.navigator.mediaDevices) return;
              if (window.navigator.mediaDevices && "getDisplayMedia" in window.navigator.mediaDevices) return;
              window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(
                window.navigator.mediaDevices
              );
            }
          },
          {}
        ],
        10: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetUserMedia = shimGetUserMedia;
            function shimGetUserMedia(window) {
              var navigator = window && window.navigator;
              var shimError_ = function shimError_(e) {
                return {
                  name: { PermissionDeniedError: "NotAllowedError" }[e.name] || e.name,
                  message: e.message,
                  constraint: e.constraint,
                  toString: function toString() {
                    return this.name;
                  }
                };
              };
              var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
              navigator.mediaDevices.getUserMedia = function(c) {
                return origGetUserMedia(c).catch(function(e) {
                  return Promise.reject(shimError_(e));
                });
              };
            }
          },
          {}
        ],
        11: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = exports.shimGetUserMedia = void 0;
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            var _getusermedia = require("./getusermedia");
            Object.defineProperty(exports, "shimGetUserMedia", {
              enumerable: true,
              get: function get() {
                return _getusermedia.shimGetUserMedia;
              }
            });
            var _getdisplaymedia = require("./getdisplaymedia");
            Object.defineProperty(exports, "shimGetDisplayMedia", {
              enumerable: true,
              get: function get() {
                return _getdisplaymedia.shimGetDisplayMedia;
              }
            });
            exports.shimOnTrack = shimOnTrack;
            exports.shimPeerConnection = shimPeerConnection;
            exports.shimSenderGetStats = shimSenderGetStats;
            exports.shimReceiverGetStats = shimReceiverGetStats;
            exports.shimRemoveStream = shimRemoveStream;
            exports.shimRTCDataChannel = shimRTCDataChannel;
            var _utils = require("../utils");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function shimOnTrack(window) {
              if (
                "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                window.RTCTrackEvent &&
                "receiver" in window.RTCTrackEvent.prototype &&
                !("transceiver" in window.RTCTrackEvent.prototype)
              )
                Object.defineProperty(window.RTCTrackEvent.prototype, "transceiver", {
                  get: function get() {
                    return { receiver: this.receiver };
                  }
                });
            }
            function shimPeerConnection(window) {
              var browserDetails = utils.detectBrowser(window);
              if (
                "object" !== ("undefined" === typeof window ? "undefined" : _typeof(window)) ||
                !(window.RTCPeerConnection || window.mozRTCPeerConnection)
              )
                return;
              if (!window.RTCPeerConnection && window.mozRTCPeerConnection)
                window.RTCPeerConnection = window.mozRTCPeerConnection;
              ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
                var nativeMethod = window.RTCPeerConnection.prototype[method];
                window.RTCPeerConnection.prototype[method] = function() {
                  arguments[0] = new ("addIceCandidate" === method
                    ? window.RTCIceCandidate
                    : window.RTCSessionDescription)(arguments[0]);
                  return nativeMethod.apply(this, arguments);
                };
              });
              var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
              window.RTCPeerConnection.prototype.addIceCandidate = function() {
                if (!arguments[0]) {
                  if (arguments[1]) arguments[1].apply(null);
                  return Promise.resolve();
                }
                return nativeAddIceCandidate.apply(this, arguments);
              };
              var modernStatsTypes = {
                inboundrtp: "inbound-rtp",
                outboundrtp: "outbound-rtp",
                candidatepair: "candidate-pair",
                localcandidate: "local-candidate",
                remotecandidate: "remote-candidate"
              };
              var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
              window.RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {
                return nativeGetStats
                  .apply(this, [selector || null])
                  .then(function(stats) {
                    if (browserDetails.version < 53 && !onSucc)
                      try {
                        stats.forEach(function(stat) {
                          stat.type = modernStatsTypes[stat.type] || stat.type;
                        });
                      } catch (e) {
                        if ("TypeError" !== e.name) throw e;
                        stats.forEach(function(stat, i) {
                          stats.set(i, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type }));
                        });
                      }
                    return stats;
                  })
                  .then(onSucc, onErr);
              };
            }
            function shimSenderGetStats(window) {
              if (
                !(
                  "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                  window.RTCPeerConnection &&
                  window.RTCRtpSender
                )
              )
                return;
              if (window.RTCRtpSender && "getStats" in window.RTCRtpSender.prototype) return;
              var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
              if (origGetSenders)
                window.RTCPeerConnection.prototype.getSenders = function() {
                  var _this = this;
                  var senders = origGetSenders.apply(this, []);
                  senders.forEach(function(sender) {
                    return (sender._pc = _this);
                  });
                  return senders;
                };
              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
              if (origAddTrack)
                window.RTCPeerConnection.prototype.addTrack = function() {
                  var sender = origAddTrack.apply(this, arguments);
                  sender._pc = this;
                  return sender;
                };
              window.RTCRtpSender.prototype.getStats = function() {
                return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
              };
            }
            function shimReceiverGetStats(window) {
              if (
                !(
                  "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                  window.RTCPeerConnection &&
                  window.RTCRtpSender
                )
              )
                return;
              if (window.RTCRtpSender && "getStats" in window.RTCRtpReceiver.prototype) return;
              var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
              if (origGetReceivers)
                window.RTCPeerConnection.prototype.getReceivers = function() {
                  var _this2 = this;
                  var receivers = origGetReceivers.apply(this, []);
                  receivers.forEach(function(receiver) {
                    return (receiver._pc = _this2);
                  });
                  return receivers;
                };
              utils.wrapPeerConnectionEvent(window, "track", function(e) {
                e.receiver._pc = e.srcElement;
                return e;
              });
              window.RTCRtpReceiver.prototype.getStats = function() {
                return this._pc.getStats(this.track);
              };
            }
            function shimRemoveStream(window) {
              if (!window.RTCPeerConnection || "removeStream" in window.RTCPeerConnection.prototype) return;
              window.RTCPeerConnection.prototype.removeStream = function(stream) {
                var _this3 = this;
                utils.deprecated("removeStream", "removeTrack");
                this.getSenders().forEach(function(sender) {
                  if (sender.track && stream.getTracks().includes(sender.track)) _this3.removeTrack(sender);
                });
              };
            }
            function shimRTCDataChannel(window) {
              if (window.DataChannel && !window.RTCDataChannel) window.RTCDataChannel = window.DataChannel;
            }
          },
          { "../utils": 15, "./getdisplaymedia": 12, "./getusermedia": 13 }
        ],
        12: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.shimGetDisplayMedia = shimGetDisplayMedia;
            function shimGetDisplayMedia(window, preferredMediaSource) {
              if (window.navigator.mediaDevices && "getDisplayMedia" in window.navigator.mediaDevices) return;
              if (!window.navigator.mediaDevices) return;
              window.navigator.mediaDevices.getDisplayMedia = function(constraints) {
                if (!(constraints && constraints.video)) {
                  var err = new DOMException("getDisplayMedia without video " + "constraints is undefined");
                  err.name = "NotFoundError";
                  err.code = 8;
                  return Promise.reject(err);
                }
                if (true === constraints.video) constraints.video = { mediaSource: preferredMediaSource };
                else constraints.video.mediaSource = preferredMediaSource;
                return window.navigator.mediaDevices.getUserMedia(constraints);
              };
            }
          },
          {}
        ],
        13: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            exports.shimGetUserMedia = shimGetUserMedia;
            var _utils = require("../utils");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function shimGetUserMedia(window) {
              var browserDetails = utils.detectBrowser(window);
              var navigator = window && window.navigator;
              var MediaStreamTrack = window && window.MediaStreamTrack;
              navigator.getUserMedia = function(constraints, onSuccess, onError) {
                utils.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
                navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
              };
              if (
                !(browserDetails.version > 55 && "autoGainControl" in navigator.mediaDevices.getSupportedConstraints())
              ) {
                var remap = function remap(obj, a, b) {
                  if (a in obj && !(b in obj)) {
                    obj[b] = obj[a];
                    delete obj[a];
                  }
                };
                var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(c) {
                  if (
                    "object" === ("undefined" === typeof c ? "undefined" : _typeof(c)) &&
                    "object" === _typeof(c.audio)
                  ) {
                    c = JSON.parse(JSON.stringify(c));
                    remap(c.audio, "autoGainControl", "mozAutoGainControl");
                    remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
                  }
                  return nativeGetUserMedia(c);
                };
                if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
                  var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
                  MediaStreamTrack.prototype.getSettings = function() {
                    var obj = nativeGetSettings.apply(this, arguments);
                    remap(obj, "mozAutoGainControl", "autoGainControl");
                    remap(obj, "mozNoiseSuppression", "noiseSuppression");
                    return obj;
                  };
                }
                if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
                  var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
                  MediaStreamTrack.prototype.applyConstraints = function(c) {
                    if ("audio" === this.kind && "object" === ("undefined" === typeof c ? "undefined" : _typeof(c))) {
                      c = JSON.parse(JSON.stringify(c));
                      remap(c, "autoGainControl", "mozAutoGainControl");
                      remap(c, "noiseSuppression", "mozNoiseSuppression");
                    }
                    return nativeApplyConstraints.apply(this, [c]);
                  };
                }
              }
            }
          },
          { "../utils": 15 }
        ],
        14: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
            exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
            exports.shimCallbacksAPI = shimCallbacksAPI;
            exports.shimGetUserMedia = shimGetUserMedia;
            exports.shimConstraints = shimConstraints;
            exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
            exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
            exports.shimCreateOfferLegacy = shimCreateOfferLegacy;
            var _utils = require("../utils");
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) return obj;
              else {
                var newObj = {};
                if (null != obj)
                  for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                newObj.default = obj;
                return newObj;
              }
            }
            function shimLocalStreamsAPI(window) {
              if (
                "object" !== ("undefined" === typeof window ? "undefined" : _typeof(window)) ||
                !window.RTCPeerConnection
              )
                return;
              if (!("getLocalStreams" in window.RTCPeerConnection.prototype))
                window.RTCPeerConnection.prototype.getLocalStreams = function() {
                  if (!this._localStreams) this._localStreams = [];
                  return this._localStreams;
                };
              if (!("addStream" in window.RTCPeerConnection.prototype)) {
                var _addTrack = window.RTCPeerConnection.prototype.addTrack;
                window.RTCPeerConnection.prototype.addStream = function(stream) {
                  var _this = this;
                  if (!this._localStreams) this._localStreams = [];
                  if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
                  stream.getTracks().forEach(function(track) {
                    return _addTrack.call(_this, track, stream);
                  });
                };
                window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                  if (stream)
                    if (!this._localStreams) this._localStreams = [stream];
                    else if (!this._localStreams.includes(stream)) this._localStreams.push(stream);
                  return _addTrack.call(this, track, stream);
                };
              }
              if (!("removeStream" in window.RTCPeerConnection.prototype))
                window.RTCPeerConnection.prototype.removeStream = function(stream) {
                  var _this2 = this;
                  if (!this._localStreams) this._localStreams = [];
                  var index = this._localStreams.indexOf(stream);
                  if (-1 === index) return;
                  this._localStreams.splice(index, 1);
                  var tracks = stream.getTracks();
                  this.getSenders().forEach(function(sender) {
                    if (tracks.includes(sender.track)) _this2.removeTrack(sender);
                  });
                };
            }
            function shimRemoteStreamsAPI(window) {
              if (
                "object" !== ("undefined" === typeof window ? "undefined" : _typeof(window)) ||
                !window.RTCPeerConnection
              )
                return;
              if (!("getRemoteStreams" in window.RTCPeerConnection.prototype))
                window.RTCPeerConnection.prototype.getRemoteStreams = function() {
                  return this._remoteStreams ? this._remoteStreams : [];
                };
              if (!("onaddstream" in window.RTCPeerConnection.prototype)) {
                Object.defineProperty(window.RTCPeerConnection.prototype, "onaddstream", {
                  get: function get() {
                    return this._onaddstream;
                  },
                  set: function set(f) {
                    var _this3 = this;
                    if (this._onaddstream) {
                      this.removeEventListener("addstream", this._onaddstream);
                      this.removeEventListener("track", this._onaddstreampoly);
                    }
                    this.addEventListener("addstream", (this._onaddstream = f));
                    this.addEventListener(
                      "track",
                      (this._onaddstreampoly = function(e) {
                        e.streams.forEach(function(stream) {
                          if (!_this3._remoteStreams) _this3._remoteStreams = [];
                          if (_this3._remoteStreams.includes(stream)) return;
                          _this3._remoteStreams.push(stream);
                          var event = new Event("addstream");
                          event.stream = stream;
                          _this3.dispatchEvent(event);
                        });
                      })
                    );
                  }
                });
                var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
                window.RTCPeerConnection.prototype.setRemoteDescription = function() {
                  var pc = this;
                  if (!this._onaddstreampoly)
                    this.addEventListener(
                      "track",
                      (this._onaddstreampoly = function(e) {
                        e.streams.forEach(function(stream) {
                          if (!pc._remoteStreams) pc._remoteStreams = [];
                          if (pc._remoteStreams.indexOf(stream) >= 0) return;
                          pc._remoteStreams.push(stream);
                          var event = new Event("addstream");
                          event.stream = stream;
                          pc.dispatchEvent(event);
                        });
                      })
                    );
                  return origSetRemoteDescription.apply(pc, arguments);
                };
              }
            }
            function shimCallbacksAPI(window) {
              if (
                "object" !== ("undefined" === typeof window ? "undefined" : _typeof(window)) ||
                !window.RTCPeerConnection
              )
                return;
              var prototype = window.RTCPeerConnection.prototype;
              var createOffer = prototype.createOffer;
              var createAnswer = prototype.createAnswer;
              var setLocalDescription = prototype.setLocalDescription;
              var setRemoteDescription = prototype.setRemoteDescription;
              var addIceCandidate = prototype.addIceCandidate;
              prototype.createOffer = function(successCallback, failureCallback) {
                var options = arguments.length >= 2 ? arguments[2] : arguments[0];
                var promise = createOffer.apply(this, [options]);
                if (!failureCallback) return promise;
                promise.then(successCallback, failureCallback);
                return Promise.resolve();
              };
              prototype.createAnswer = function(successCallback, failureCallback) {
                var options = arguments.length >= 2 ? arguments[2] : arguments[0];
                var promise = createAnswer.apply(this, [options]);
                if (!failureCallback) return promise;
                promise.then(successCallback, failureCallback);
                return Promise.resolve();
              };
              var withCallback = function withCallback(description, successCallback, failureCallback) {
                var promise = setLocalDescription.apply(this, [description]);
                if (!failureCallback) return promise;
                promise.then(successCallback, failureCallback);
                return Promise.resolve();
              };
              prototype.setLocalDescription = withCallback;
              withCallback = function withCallback(description, successCallback, failureCallback) {
                var promise = setRemoteDescription.apply(this, [description]);
                if (!failureCallback) return promise;
                promise.then(successCallback, failureCallback);
                return Promise.resolve();
              };
              prototype.setRemoteDescription = withCallback;
              withCallback = function withCallback(candidate, successCallback, failureCallback) {
                var promise = addIceCandidate.apply(this, [candidate]);
                if (!failureCallback) return promise;
                promise.then(successCallback, failureCallback);
                return Promise.resolve();
              };
              prototype.addIceCandidate = withCallback;
            }
            function shimGetUserMedia(window) {
              var navigator = window && window.navigator;
              if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                var mediaDevices = navigator.mediaDevices;
                var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
                navigator.mediaDevices.getUserMedia = function(constraints) {
                  return _getUserMedia(shimConstraints(constraints));
                };
              }
              if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
                navigator.getUserMedia = function(constraints, cb, errcb) {
                  navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
                }.bind(navigator);
            }
            function shimConstraints(constraints) {
              if (constraints && void 0 !== constraints.video)
                return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
              return constraints;
            }
            function shimRTCIceServerUrls(window) {
              var OrigPeerConnection = window.RTCPeerConnection;
              window.RTCPeerConnection = function(pcConfig, pcConstraints) {
                if (pcConfig && pcConfig.iceServers) {
                  var newIceServers = [];
                  for (var i = 0; i < pcConfig.iceServers.length; i++) {
                    var server = pcConfig.iceServers[i];
                    if (!server.hasOwnProperty("urls") && server.hasOwnProperty("url")) {
                      utils.deprecated("RTCIceServer.url", "RTCIceServer.urls");
                      server = JSON.parse(JSON.stringify(server));
                      server.urls = server.url;
                      delete server.url;
                      newIceServers.push(server);
                    } else newIceServers.push(pcConfig.iceServers[i]);
                  }
                  pcConfig.iceServers = newIceServers;
                }
                return new OrigPeerConnection(pcConfig, pcConstraints);
              };
              window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
              if ("generateCertificate" in window.RTCPeerConnection)
                Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
                  get: function get() {
                    return OrigPeerConnection.generateCertificate;
                  }
                });
            }
            function shimTrackEventTransceiver(window) {
              if (
                "object" === ("undefined" === typeof window ? "undefined" : _typeof(window)) &&
                window.RTCPeerConnection &&
                "receiver" in window.RTCTrackEvent.prototype &&
                !window.RTCTransceiver
              )
                Object.defineProperty(window.RTCTrackEvent.prototype, "transceiver", {
                  get: function get() {
                    return { receiver: this.receiver };
                  }
                });
            }
            function shimCreateOfferLegacy(window) {
              var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
              window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
                if (offerOptions) {
                  if ("undefined" !== typeof offerOptions.offerToReceiveAudio)
                    offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
                  var audioTransceiver = this.getTransceivers().find(function(transceiver) {
                    return transceiver.sender.track && "audio" === transceiver.sender.track.kind;
                  });
                  if (false === offerOptions.offerToReceiveAudio && audioTransceiver) {
                    if ("sendrecv" === audioTransceiver.direction)
                      if (audioTransceiver.setDirection) audioTransceiver.setDirection("sendonly");
                      else audioTransceiver.direction = "sendonly";
                    else if ("recvonly" === audioTransceiver.direction)
                      if (audioTransceiver.setDirection) audioTransceiver.setDirection("inactive");
                      else audioTransceiver.direction = "inactive";
                  } else if (true === offerOptions.offerToReceiveAudio && !audioTransceiver)
                    this.addTransceiver("audio");
                  if ("undefined" !== typeof offerOptions.offerToReceiveVideo)
                    offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
                  var videoTransceiver = this.getTransceivers().find(function(transceiver) {
                    return transceiver.sender.track && "video" === transceiver.sender.track.kind;
                  });
                  if (false === offerOptions.offerToReceiveVideo && videoTransceiver) {
                    if ("sendrecv" === videoTransceiver.direction)
                      if (videoTransceiver.setDirection) videoTransceiver.setDirection("sendonly");
                      else videoTransceiver.direction = "sendonly";
                    else if ("recvonly" === videoTransceiver.direction)
                      if (videoTransceiver.setDirection) videoTransceiver.setDirection("inactive");
                      else videoTransceiver.direction = "inactive";
                  } else if (true === offerOptions.offerToReceiveVideo && !videoTransceiver)
                    this.addTransceiver("video");
                }
                return origCreateOffer.apply(this, arguments);
              };
            }
          },
          { "../utils": 15 }
        ],
        15: [
          function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            var _typeof =
              "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };
            exports.extractVersion = extractVersion;
            exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
            exports.disableLog = disableLog;
            exports.disableWarnings = disableWarnings;
            exports.log = log;
            exports.deprecated = deprecated;
            exports.detectBrowser = detectBrowser;
            exports.compactObject = compactObject;
            function _defineProperty(obj, key, value) {
              if (key in obj)
                Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
              else obj[key] = value;
              return obj;
            }
            var logDisabled_ = true;
            var deprecationWarnings_ = true;
            function extractVersion(uastring, expr, pos) {
              var match = uastring.match(expr);
              return match && match.length >= pos && parseInt(match[pos], 10);
            }
            function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
              if (!window.RTCPeerConnection) return;
              var proto = window.RTCPeerConnection.prototype;
              var nativeAddEventListener = proto.addEventListener;
              proto.addEventListener = function(nativeEventName, cb) {
                if (nativeEventName !== eventNameToWrap) return nativeAddEventListener.apply(this, arguments);
                var wrappedCallback = function wrappedCallback(e) {
                  var modifiedEvent = wrapper(e);
                  if (modifiedEvent) cb(modifiedEvent);
                };
                this._eventMap = this._eventMap || {};
                this._eventMap[cb] = wrappedCallback;
                return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
              };
              var nativeRemoveEventListener = proto.removeEventListener;
              proto.removeEventListener = function(nativeEventName, cb) {
                if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb])
                  return nativeRemoveEventListener.apply(this, arguments);
                var unwrappedCb = this._eventMap[cb];
                delete this._eventMap[cb];
                return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
              };
              Object.defineProperty(proto, "on" + eventNameToWrap, {
                get: function get() {
                  return this["_on" + eventNameToWrap];
                },
                set: function set(cb) {
                  if (this["_on" + eventNameToWrap]) {
                    this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
                    delete this["_on" + eventNameToWrap];
                  }
                  if (cb) this.addEventListener(eventNameToWrap, (this["_on" + eventNameToWrap] = cb));
                },
                enumerable: true,
                configurable: true
              });
            }
            function disableLog(bool) {
              if ("boolean" !== typeof bool)
                return new Error(
                  "Argument type: " +
                    ("undefined" === typeof bool ? "undefined" : _typeof(bool)) +
                    ". Please use a boolean."
                );
              logDisabled_ = bool;
              return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
            }
            function disableWarnings(bool) {
              if ("boolean" !== typeof bool)
                return new Error(
                  "Argument type: " +
                    ("undefined" === typeof bool ? "undefined" : _typeof(bool)) +
                    ". Please use a boolean."
                );
              deprecationWarnings_ = !bool;
              return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
            }
            function log() {
              if ("object" === ("undefined" === typeof window ? "undefined" : _typeof(window))) {
                if (logDisabled_) return;
                if ("undefined" !== typeof console && "function" === typeof console.log)
                  console.log.apply(console, arguments);
              }
            }
            function deprecated(oldMethod, newMethod) {
              if (!deprecationWarnings_) return;
              console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
            }
            function detectBrowser(window) {
              var navigator = window.navigator;
              var result = { browser: null, version: null };
              if ("undefined" === typeof window || !window.navigator) {
                result.browser = "Not a browser.";
                return result;
              }
              if (navigator.mozGetUserMedia) {
                result.browser = "firefox";
                result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
              } else if (navigator.webkitGetUserMedia) {
                result.browser = "chrome";
                result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
              } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
                result.browser = "edge";
                result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
              } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
                result.browser = "safari";
                result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
              } else {
                result.browser = "Not a supported browser.";
                return result;
              }
              return result;
            }
            function compactObject(data) {
              if ("object" !== ("undefined" === typeof data ? "undefined" : _typeof(data))) return data;
              return Object.keys(data).reduce(function(accumulator, key) {
                var isObject = "object" === _typeof(data[key]);
                var value = isObject ? compactObject(data[key]) : data[key];
                var isEmptyObject = isObject && !Object.keys(value).length;
                if (void 0 === value || isEmptyObject) return accumulator;
                return Object.assign(accumulator, _defineProperty({}, key, value));
              }, {});
            }
          },
          {}
        ],
        16: [
          function(require, module, exports) {
            var SDPUtils = require("sdp");
            function fixStatsType(stat) {
              return (
                {
                  inboundrtp: "inbound-rtp",
                  outboundrtp: "outbound-rtp",
                  candidatepair: "candidate-pair",
                  localcandidate: "local-candidate",
                  remotecandidate: "remote-candidate"
                }[stat.type] || stat.type
              );
            }
            function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
              var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
              sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());
              sdp += SDPUtils.writeDtlsParameters(
                transceiver.dtlsTransport.getLocalParameters(),
                "offer" === type ? "actpass" : dtlsRole || "active"
              );
              sdp += "a=mid:" + transceiver.mid + "\r\n";
              if (transceiver.rtpSender && transceiver.rtpReceiver) sdp += "a=sendrecv\r\n";
              else if (transceiver.rtpSender) sdp += "a=sendonly\r\n";
              else if (transceiver.rtpReceiver) sdp += "a=recvonly\r\n";
              else sdp += "a=inactive\r\n";
              if (transceiver.rtpSender) {
                var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;
                transceiver.rtpSender._initialTrackId = trackId;
                var msid = "msid:" + (stream ? stream.id : "-") + " " + trackId + "\r\n";
                sdp += "a=" + msid;
                sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " " + msid;
                if (transceiver.sendEncodingParameters[0].rtx) {
                  sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " " + msid;
                  sdp +=
                    "a=ssrc-group:FID " +
                    transceiver.sendEncodingParameters[0].ssrc +
                    " " +
                    transceiver.sendEncodingParameters[0].rtx.ssrc +
                    "\r\n";
                }
              }
              sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " cname:" + SDPUtils.localCName + "\r\n";
              if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx)
                sdp +=
                  "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " cname:" + SDPUtils.localCName + "\r\n";
              return sdp;
            }
            function filterIceServers(iceServers, edgeVersion) {
              var hasTurn = false;
              iceServers = JSON.parse(JSON.stringify(iceServers));
              return iceServers.filter(function(server) {
                if (server && (server.urls || server.url)) {
                  var urls = server.urls || server.url;
                  if (server.url && !server.urls) console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                  var isString = "string" === typeof urls;
                  if (isString) urls = [urls];
                  urls = urls.filter(function(url) {
                    var validTurn =
                      0 === url.indexOf("turn:") &&
                      -1 !== url.indexOf("transport=udp") &&
                      -1 === url.indexOf("turn:[") &&
                      !hasTurn;
                    if (validTurn) {
                      hasTurn = true;
                      return true;
                    }
                    return 0 === url.indexOf("stun:") && edgeVersion >= 14393 && -1 === url.indexOf("?transport=udp");
                  });
                  delete server.url;
                  server.urls = isString ? urls[0] : urls;
                  return !!urls.length;
                }
              });
            }
            function getCommonCapabilities(localCapabilities, remoteCapabilities) {
              var commonCapabilities = { codecs: [], headerExtensions: [], fecMechanisms: [] };
              var findCodecByPayloadType = function(pt, codecs) {
                pt = parseInt(pt, 10);
                for (var i = 0; i < codecs.length; i++)
                  if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) return codecs[i];
              };
              var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
                var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
                var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
                return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
              };
              localCapabilities.codecs.forEach(function(lCodec) {
                for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
                  var rCodec = remoteCapabilities.codecs[i];
                  if (
                    lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                    lCodec.clockRate === rCodec.clockRate
                  ) {
                    if ("rtx" === lCodec.name.toLowerCase() && lCodec.parameters && rCodec.parameters.apt)
                      if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs))
                        continue;
                    rCodec = JSON.parse(JSON.stringify(rCodec));
                    rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels);
                    commonCapabilities.codecs.push(rCodec);
                    rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                      for (var j = 0; j < lCodec.rtcpFeedback.length; j++)
                        if (
                          lCodec.rtcpFeedback[j].type === fb.type &&
                          lCodec.rtcpFeedback[j].parameter === fb.parameter
                        )
                          return true;
                      return false;
                    });
                    break;
                  }
                }
              });
              localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
                for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
                  var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                  if (lHeaderExtension.uri === rHeaderExtension.uri) {
                    commonCapabilities.headerExtensions.push(rHeaderExtension);
                    break;
                  }
                }
              });
              return commonCapabilities;
            }
            function isActionAllowedInSignalingState(action, type, signalingState) {
              return (
                -1 !==
                {
                  offer: {
                    setLocalDescription: ["stable", "have-local-offer"],
                    setRemoteDescription: ["stable", "have-remote-offer"]
                  },
                  answer: {
                    setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
                    setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
                  }
                }[type][action].indexOf(signalingState)
              );
            }
            function maybeAddCandidate(iceTransport, candidate) {
              var alreadyAdded = iceTransport.getRemoteCandidates().find(function(remoteCandidate) {
                return (
                  candidate.foundation === remoteCandidate.foundation &&
                  candidate.ip === remoteCandidate.ip &&
                  candidate.port === remoteCandidate.port &&
                  candidate.priority === remoteCandidate.priority &&
                  candidate.protocol === remoteCandidate.protocol &&
                  candidate.type === remoteCandidate.type
                );
              });
              if (!alreadyAdded) iceTransport.addRemoteCandidate(candidate);
              return !alreadyAdded;
            }
            function makeError(name, description) {
              var e = new Error(description);
              e.name = name;
              e.code = {
                NotSupportedError: 9,
                InvalidStateError: 11,
                InvalidAccessError: 15,
                TypeError: void 0,
                OperationError: void 0
              }[name];
              return e;
            }
            module.exports = function(window, edgeVersion) {
              function addTrackToStreamAndFireEvent(track, stream) {
                stream.addTrack(track);
                stream.dispatchEvent(new window.MediaStreamTrackEvent("addtrack", { track: track }));
              }
              function removeTrackFromStreamAndFireEvent(track, stream) {
                stream.removeTrack(track);
                stream.dispatchEvent(new window.MediaStreamTrackEvent("removetrack", { track: track }));
              }
              function fireAddTrack(pc, track, receiver, streams) {
                var trackEvent = new Event("track");
                trackEvent.track = track;
                trackEvent.receiver = receiver;
                trackEvent.transceiver = { receiver: receiver };
                trackEvent.streams = streams;
                window.setTimeout(function() {
                  pc._dispatchEvent("track", trackEvent);
                });
              }
              var RTCPeerConnection = function(config) {
                var pc = this;
                var _eventTarget = document.createDocumentFragment();
                ["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(method) {
                  pc[method] = _eventTarget[method].bind(_eventTarget);
                });
                this.canTrickleIceCandidates = null;
                this.needNegotiation = false;
                this.localStreams = [];
                this.remoteStreams = [];
                this._localDescription = null;
                this._remoteDescription = null;
                this.signalingState = "stable";
                this.iceConnectionState = "new";
                this.connectionState = "new";
                this.iceGatheringState = "new";
                config = JSON.parse(JSON.stringify(config || {}));
                this.usingBundle = "max-bundle" === config.bundlePolicy;
                if ("negotiate" === config.rtcpMuxPolicy)
                  throw makeError("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
                else if (!config.rtcpMuxPolicy) config.rtcpMuxPolicy = "require";
                switch (config.iceTransportPolicy) {
                  case "all":
                  case "relay":
                    break;
                  default:
                    config.iceTransportPolicy = "all";
                }
                switch (config.bundlePolicy) {
                  case "balanced":
                  case "max-compat":
                  case "max-bundle":
                    break;
                  default:
                    config.bundlePolicy = "balanced";
                }
                config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);
                this._iceGatherers = [];
                if (config.iceCandidatePoolSize)
                  for (var i = config.iceCandidatePoolSize; i > 0; i--)
                    this._iceGatherers.push(
                      new window.RTCIceGatherer({
                        iceServers: config.iceServers,
                        gatherPolicy: config.iceTransportPolicy
                      })
                    );
                else config.iceCandidatePoolSize = 0;
                this._config = config;
                this.transceivers = [];
                this._sdpSessionId = SDPUtils.generateSessionId();
                this._sdpSessionVersion = 0;
                this._dtlsRole = void 0;
                this._isClosed = false;
              };
              Object.defineProperty(RTCPeerConnection.prototype, "localDescription", {
                configurable: true,
                get: function() {
                  return this._localDescription;
                }
              });
              Object.defineProperty(RTCPeerConnection.prototype, "remoteDescription", {
                configurable: true,
                get: function() {
                  return this._remoteDescription;
                }
              });
              RTCPeerConnection.prototype.onicecandidate = null;
              RTCPeerConnection.prototype.onaddstream = null;
              RTCPeerConnection.prototype.ontrack = null;
              RTCPeerConnection.prototype.onremovestream = null;
              RTCPeerConnection.prototype.onsignalingstatechange = null;
              RTCPeerConnection.prototype.oniceconnectionstatechange = null;
              RTCPeerConnection.prototype.onconnectionstatechange = null;
              RTCPeerConnection.prototype.onicegatheringstatechange = null;
              RTCPeerConnection.prototype.onnegotiationneeded = null;
              RTCPeerConnection.prototype.ondatachannel = null;
              RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
                if (this._isClosed) return;
                this.dispatchEvent(event);
                if ("function" === typeof this["on" + name]) this["on" + name](event);
              };
              RTCPeerConnection.prototype._emitGatheringStateChange = function() {
                var event = new Event("icegatheringstatechange");
                this._dispatchEvent("icegatheringstatechange", event);
              };
              RTCPeerConnection.prototype.getConfiguration = function() {
                return this._config;
              };
              RTCPeerConnection.prototype.getLocalStreams = function() {
                return this.localStreams;
              };
              RTCPeerConnection.prototype.getRemoteStreams = function() {
                return this.remoteStreams;
              };
              RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
                var hasBundleTransport = this.transceivers.length > 0;
                var transceiver = {
                  track: null,
                  iceGatherer: null,
                  iceTransport: null,
                  dtlsTransport: null,
                  localCapabilities: null,
                  remoteCapabilities: null,
                  rtpSender: null,
                  rtpReceiver: null,
                  kind: kind,
                  mid: null,
                  sendEncodingParameters: null,
                  recvEncodingParameters: null,
                  stream: null,
                  associatedRemoteMediaStreams: [],
                  wantReceive: true
                };
                if (this.usingBundle && hasBundleTransport) {
                  transceiver.iceTransport = this.transceivers[0].iceTransport;
                  transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
                } else {
                  var transports = this._createIceAndDtlsTransports();
                  transceiver.iceTransport = transports.iceTransport;
                  transceiver.dtlsTransport = transports.dtlsTransport;
                }
                if (!doNotAdd) this.transceivers.push(transceiver);
                return transceiver;
              };
              RTCPeerConnection.prototype.addTrack = function(track, stream) {
                if (this._isClosed)
                  throw makeError("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
                var alreadyExists = this.transceivers.find(function(s) {
                  return s.track === track;
                });
                if (alreadyExists) throw makeError("InvalidAccessError", "Track already exists.");
                var transceiver;
                for (var i = 0; i < this.transceivers.length; i++)
                  if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind)
                    transceiver = this.transceivers[i];
                if (!transceiver) transceiver = this._createTransceiver(track.kind);
                this._maybeFireNegotiationNeeded();
                if (-1 === this.localStreams.indexOf(stream)) this.localStreams.push(stream);
                transceiver.track = track;
                transceiver.stream = stream;
                transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);
                return transceiver.rtpSender;
              };
              RTCPeerConnection.prototype.addStream = function(stream) {
                var pc = this;
                if (edgeVersion >= 15025)
                  stream.getTracks().forEach(function(track) {
                    pc.addTrack(track, stream);
                  });
                else {
                  var clonedStream = stream.clone();
                  stream.getTracks().forEach(function(track, idx) {
                    var clonedTrack = clonedStream.getTracks()[idx];
                    track.addEventListener("enabled", function(event) {
                      clonedTrack.enabled = event.enabled;
                    });
                  });
                  clonedStream.getTracks().forEach(function(track) {
                    pc.addTrack(track, clonedStream);
                  });
                }
              };
              RTCPeerConnection.prototype.removeTrack = function(sender) {
                if (this._isClosed)
                  throw makeError("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
                if (!(sender instanceof window.RTCRtpSender))
                  throw new TypeError(
                    "Argument 1 of RTCPeerConnection.removeTrack " + "does not implement interface RTCRtpSender."
                  );
                var transceiver = this.transceivers.find(function(t) {
                  return t.rtpSender === sender;
                });
                if (!transceiver) throw makeError("InvalidAccessError", "Sender was not created by this connection.");
                var stream = transceiver.stream;
                transceiver.rtpSender.stop();
                transceiver.rtpSender = null;
                transceiver.track = null;
                transceiver.stream = null;
                var localStreams = this.transceivers.map(function(t) {
                  return t.stream;
                });
                if (-1 === localStreams.indexOf(stream) && this.localStreams.indexOf(stream) > -1)
                  this.localStreams.splice(this.localStreams.indexOf(stream), 1);
                this._maybeFireNegotiationNeeded();
              };
              RTCPeerConnection.prototype.removeStream = function(stream) {
                var pc = this;
                stream.getTracks().forEach(function(track) {
                  var sender = pc.getSenders().find(function(s) {
                    return s.track === track;
                  });
                  if (sender) pc.removeTrack(sender);
                });
              };
              RTCPeerConnection.prototype.getSenders = function() {
                return this.transceivers
                  .filter(function(transceiver) {
                    return !!transceiver.rtpSender;
                  })
                  .map(function(transceiver) {
                    return transceiver.rtpSender;
                  });
              };
              RTCPeerConnection.prototype.getReceivers = function() {
                return this.transceivers
                  .filter(function(transceiver) {
                    return !!transceiver.rtpReceiver;
                  })
                  .map(function(transceiver) {
                    return transceiver.rtpReceiver;
                  });
              };
              RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex, usingBundle) {
                var pc = this;
                if (usingBundle && sdpMLineIndex > 0) return this.transceivers[0].iceGatherer;
                else if (this._iceGatherers.length) return this._iceGatherers.shift();
                var iceGatherer = new window.RTCIceGatherer({
                  iceServers: this._config.iceServers,
                  gatherPolicy: this._config.iceTransportPolicy
                });
                Object.defineProperty(iceGatherer, "state", { value: "new", writable: true });
                this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
                this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
                  var end = !event.candidate || 0 === Object.keys(event.candidate).length;
                  iceGatherer.state = end ? "completed" : "gathering";
                  if (null !== pc.transceivers[sdpMLineIndex].bufferedCandidateEvents)
                    pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
                };
                iceGatherer.addEventListener("localcandidate", this.transceivers[sdpMLineIndex].bufferCandidates);
                return iceGatherer;
              };
              RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
                var pc = this;
                var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
                if (iceGatherer.onlocalcandidate) return;
                var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
                this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
                iceGatherer.removeEventListener("localcandidate", this.transceivers[sdpMLineIndex].bufferCandidates);
                iceGatherer.onlocalcandidate = function(evt) {
                  if (pc.usingBundle && sdpMLineIndex > 0) return;
                  var event = new Event("icecandidate");
                  event.candidate = { sdpMid: mid, sdpMLineIndex: sdpMLineIndex };
                  var cand = evt.candidate;
                  var end = !cand || 0 === Object.keys(cand).length;
                  if (end) {
                    if ("new" === iceGatherer.state || "gathering" === iceGatherer.state)
                      iceGatherer.state = "completed";
                  } else {
                    if ("new" === iceGatherer.state) iceGatherer.state = "gathering";
                    cand.component = 1;
                    cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;
                    var serializedCandidate = SDPUtils.writeCandidate(cand);
                    event.candidate = Object.assign(event.candidate, SDPUtils.parseCandidate(serializedCandidate));
                    event.candidate.candidate = serializedCandidate;
                    event.candidate.toJSON = function() {
                      return {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment
                      };
                    };
                  }
                  var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
                  if (!end) sections[event.candidate.sdpMLineIndex] += "a=" + event.candidate.candidate + "\r\n";
                  else sections[event.candidate.sdpMLineIndex] += "a=end-of-candidates\r\n";
                  pc._localDescription.sdp = SDPUtils.getDescription(pc._localDescription.sdp) + sections.join("");
                  var complete = pc.transceivers.every(function(transceiver) {
                    return transceiver.iceGatherer && "completed" === transceiver.iceGatherer.state;
                  });
                  if ("gathering" !== pc.iceGatheringState) {
                    pc.iceGatheringState = "gathering";
                    pc._emitGatheringStateChange();
                  }
                  if (!end) pc._dispatchEvent("icecandidate", event);
                  if (complete) {
                    pc._dispatchEvent("icecandidate", new Event("icecandidate"));
                    pc.iceGatheringState = "complete";
                    pc._emitGatheringStateChange();
                  }
                };
                window.setTimeout(function() {
                  bufferedCandidateEvents.forEach(function(e) {
                    iceGatherer.onlocalcandidate(e);
                  });
                }, 0);
              };
              RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
                var pc = this;
                var iceTransport = new window.RTCIceTransport(null);
                iceTransport.onicestatechange = function() {
                  pc._updateIceConnectionState();
                  pc._updateConnectionState();
                };
                var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
                dtlsTransport.ondtlsstatechange = function() {
                  pc._updateConnectionState();
                };
                dtlsTransport.onerror = function() {
                  Object.defineProperty(dtlsTransport, "state", { value: "failed", writable: true });
                  pc._updateConnectionState();
                };
                return { iceTransport: iceTransport, dtlsTransport: dtlsTransport };
              };
              RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(sdpMLineIndex) {
                var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
                if (iceGatherer) {
                  delete iceGatherer.onlocalcandidate;
                  delete this.transceivers[sdpMLineIndex].iceGatherer;
                }
                var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
                if (iceTransport) {
                  delete iceTransport.onicestatechange;
                  delete this.transceivers[sdpMLineIndex].iceTransport;
                }
                var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
                if (dtlsTransport) {
                  delete dtlsTransport.ondtlsstatechange;
                  delete dtlsTransport.onerror;
                  delete this.transceivers[sdpMLineIndex].dtlsTransport;
                }
              };
              RTCPeerConnection.prototype._transceive = function(transceiver, send, recv) {
                var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
                if (send && transceiver.rtpSender) {
                  params.encodings = transceiver.sendEncodingParameters;
                  params.rtcp = { cname: SDPUtils.localCName, compound: transceiver.rtcpParameters.compound };
                  if (transceiver.recvEncodingParameters.length)
                    params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
                  transceiver.rtpSender.send(params);
                }
                if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
                  if ("video" === transceiver.kind && transceiver.recvEncodingParameters && edgeVersion < 15019)
                    transceiver.recvEncodingParameters.forEach(function(p) {
                      delete p.rtx;
                    });
                  if (transceiver.recvEncodingParameters.length) params.encodings = transceiver.recvEncodingParameters;
                  else params.encodings = [{}];
                  params.rtcp = { compound: transceiver.rtcpParameters.compound };
                  if (transceiver.rtcpParameters.cname) params.rtcp.cname = transceiver.rtcpParameters.cname;
                  if (transceiver.sendEncodingParameters.length)
                    params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
                  transceiver.rtpReceiver.receive(params);
                }
              };
              RTCPeerConnection.prototype.setLocalDescription = function(description) {
                var pc = this;
                if (-1 === ["offer", "answer"].indexOf(description.type))
                  return Promise.reject(makeError("TypeError", 'Unsupported type "' + description.type + '"'));
                if (
                  !isActionAllowedInSignalingState("setLocalDescription", description.type, pc.signalingState) ||
                  pc._isClosed
                )
                  return Promise.reject(
                    makeError(
                      "InvalidStateError",
                      "Can not set local " + description.type + " in state " + pc.signalingState
                    )
                  );
                var sections;
                var sessionpart;
                if ("offer" === description.type) {
                  sections = SDPUtils.splitSections(description.sdp);
                  sessionpart = sections.shift();
                  sections.forEach(function(mediaSection, sdpMLineIndex) {
                    var caps = SDPUtils.parseRtpParameters(mediaSection);
                    pc.transceivers[sdpMLineIndex].localCapabilities = caps;
                  });
                  pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                    pc._gather(transceiver.mid, sdpMLineIndex);
                  });
                } else if ("answer" === description.type) {
                  sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
                  sessionpart = sections.shift();
                  var isIceLite = SDPUtils.matchPrefix(sessionpart, "a=ice-lite").length > 0;
                  sections.forEach(function(mediaSection, sdpMLineIndex) {
                    var transceiver = pc.transceivers[sdpMLineIndex];
                    var iceGatherer = transceiver.iceGatherer;
                    var iceTransport = transceiver.iceTransport;
                    var dtlsTransport = transceiver.dtlsTransport;
                    var localCapabilities = transceiver.localCapabilities;
                    var remoteCapabilities = transceiver.remoteCapabilities;
                    var rejected =
                      SDPUtils.isRejected(mediaSection) &&
                      0 === SDPUtils.matchPrefix(mediaSection, "a=bundle-only").length;
                    if (!rejected && !transceiver.rejected) {
                      var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                      var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                      if (isIceLite) remoteDtlsParameters.role = "server";
                      if (!pc.usingBundle || 0 === sdpMLineIndex) {
                        pc._gather(transceiver.mid, sdpMLineIndex);
                        if ("new" === iceTransport.state)
                          iceTransport.start(
                            iceGatherer,
                            remoteIceParameters,
                            isIceLite ? "controlling" : "controlled"
                          );
                        if ("new" === dtlsTransport.state) dtlsTransport.start(remoteDtlsParameters);
                      }
                      var params = getCommonCapabilities(localCapabilities, remoteCapabilities);
                      pc._transceive(transceiver, params.codecs.length > 0, false);
                    }
                  });
                }
                pc._localDescription = { type: description.type, sdp: description.sdp };
                if ("offer" === description.type) pc._updateSignalingState("have-local-offer");
                else pc._updateSignalingState("stable");
                return Promise.resolve();
              };
              RTCPeerConnection.prototype.setRemoteDescription = function(description) {
                var pc = this;
                if (-1 === ["offer", "answer"].indexOf(description.type))
                  return Promise.reject(makeError("TypeError", 'Unsupported type "' + description.type + '"'));
                if (
                  !isActionAllowedInSignalingState("setRemoteDescription", description.type, pc.signalingState) ||
                  pc._isClosed
                )
                  return Promise.reject(
                    makeError(
                      "InvalidStateError",
                      "Can not set remote " + description.type + " in state " + pc.signalingState
                    )
                  );
                var streams = {};
                pc.remoteStreams.forEach(function(stream) {
                  streams[stream.id] = stream;
                });
                var receiverList = [];
                var sections = SDPUtils.splitSections(description.sdp);
                var sessionpart = sections.shift();
                var isIceLite = SDPUtils.matchPrefix(sessionpart, "a=ice-lite").length > 0;
                var usingBundle = SDPUtils.matchPrefix(sessionpart, "a=group:BUNDLE ").length > 0;
                pc.usingBundle = usingBundle;
                var iceOptions = SDPUtils.matchPrefix(sessionpart, "a=ice-options:")[0];
                if (iceOptions)
                  pc.canTrickleIceCandidates =
                    iceOptions
                      .substr(14)
                      .split(" ")
                      .indexOf("trickle") >= 0;
                else pc.canTrickleIceCandidates = false;
                sections.forEach(function(mediaSection, sdpMLineIndex) {
                  var lines = SDPUtils.splitLines(mediaSection);
                  var kind = SDPUtils.getKind(mediaSection);
                  var rejected =
                    SDPUtils.isRejected(mediaSection) &&
                    0 === SDPUtils.matchPrefix(mediaSection, "a=bundle-only").length;
                  var protocol = lines[0].substr(2).split(" ")[2];
                  var direction = SDPUtils.getDirection(mediaSection, sessionpart);
                  var remoteMsid = SDPUtils.parseMsid(mediaSection);
                  var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();
                  if (
                    rejected ||
                    ("application" === kind && ("DTLS/SCTP" === protocol || "UDP/DTLS/SCTP" === protocol))
                  ) {
                    pc.transceivers[sdpMLineIndex] = { mid: mid, kind: kind, protocol: protocol, rejected: true };
                    return;
                  }
                  if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected)
                    pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
                  var transceiver;
                  var iceGatherer;
                  var iceTransport;
                  var dtlsTransport;
                  var rtpReceiver;
                  var sendEncodingParameters;
                  var recvEncodingParameters;
                  var localCapabilities;
                  var track;
                  var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
                  var remoteIceParameters;
                  var remoteDtlsParameters;
                  if (!rejected) {
                    remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                    remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                    remoteDtlsParameters.role = "client";
                  }
                  recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);
                  var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);
                  var isComplete = SDPUtils.matchPrefix(mediaSection, "a=end-of-candidates", sessionpart).length > 0;
                  var cands = SDPUtils.matchPrefix(mediaSection, "a=candidate:")
                    .map(function(cand) {
                      return SDPUtils.parseCandidate(cand);
                    })
                    .filter(function(cand) {
                      return 1 === cand.component;
                    });
                  if (
                    ("offer" === description.type || "answer" === description.type) &&
                    !rejected &&
                    usingBundle &&
                    sdpMLineIndex > 0 &&
                    pc.transceivers[sdpMLineIndex]
                  ) {
                    pc._disposeIceAndDtlsTransports(sdpMLineIndex);
                    pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
                    pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
                    pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;
                    if (pc.transceivers[sdpMLineIndex].rtpSender)
                      pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
                    if (pc.transceivers[sdpMLineIndex].rtpReceiver)
                      pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
                  }
                  if ("offer" === description.type && !rejected) {
                    transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
                    transceiver.mid = mid;
                    if (!transceiver.iceGatherer)
                      transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);
                    if (cands.length && "new" === transceiver.iceTransport.state)
                      if (isComplete && (!usingBundle || 0 === sdpMLineIndex))
                        transceiver.iceTransport.setRemoteCandidates(cands);
                      else
                        cands.forEach(function(candidate) {
                          maybeAddCandidate(transceiver.iceTransport, candidate);
                        });
                    localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);
                    if (edgeVersion < 15019)
                      localCapabilities.codecs = localCapabilities.codecs.filter(function(codec) {
                        return "rtx" !== codec.name;
                      });
                    sendEncodingParameters = transceiver.sendEncodingParameters || [
                      { ssrc: 1001 * (2 * sdpMLineIndex + 2) }
                    ];
                    var isNewTrack = false;
                    if ("sendrecv" === direction || "sendonly" === direction) {
                      isNewTrack = !transceiver.rtpReceiver;
                      rtpReceiver =
                        transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
                      if (isNewTrack) {
                        var stream;
                        track = rtpReceiver.track;
                        if (remoteMsid && "-" === remoteMsid.stream);
                        else if (remoteMsid) {
                          if (!streams[remoteMsid.stream]) {
                            streams[remoteMsid.stream] = new window.MediaStream();
                            Object.defineProperty(streams[remoteMsid.stream], "id", {
                              get: function() {
                                return remoteMsid.stream;
                              }
                            });
                          }
                          Object.defineProperty(track, "id", {
                            get: function() {
                              return remoteMsid.track;
                            }
                          });
                          stream = streams[remoteMsid.stream];
                        } else {
                          if (!streams.default) streams.default = new window.MediaStream();
                          stream = streams.default;
                        }
                        if (stream) {
                          addTrackToStreamAndFireEvent(track, stream);
                          transceiver.associatedRemoteMediaStreams.push(stream);
                        }
                        receiverList.push([track, rtpReceiver, stream]);
                      }
                    } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                      transceiver.associatedRemoteMediaStreams.forEach(function(s) {
                        var nativeTrack = s.getTracks().find(function(t) {
                          return t.id === transceiver.rtpReceiver.track.id;
                        });
                        if (nativeTrack) removeTrackFromStreamAndFireEvent(nativeTrack, s);
                      });
                      transceiver.associatedRemoteMediaStreams = [];
                    }
                    transceiver.localCapabilities = localCapabilities;
                    transceiver.remoteCapabilities = remoteCapabilities;
                    transceiver.rtpReceiver = rtpReceiver;
                    transceiver.rtcpParameters = rtcpParameters;
                    transceiver.sendEncodingParameters = sendEncodingParameters;
                    transceiver.recvEncodingParameters = recvEncodingParameters;
                    pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);
                  } else if ("answer" === description.type && !rejected) {
                    transceiver = pc.transceivers[sdpMLineIndex];
                    iceGatherer = transceiver.iceGatherer;
                    iceTransport = transceiver.iceTransport;
                    dtlsTransport = transceiver.dtlsTransport;
                    rtpReceiver = transceiver.rtpReceiver;
                    sendEncodingParameters = transceiver.sendEncodingParameters;
                    localCapabilities = transceiver.localCapabilities;
                    pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
                    pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
                    pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;
                    if (cands.length && "new" === iceTransport.state)
                      if ((isIceLite || isComplete) && (!usingBundle || 0 === sdpMLineIndex))
                        iceTransport.setRemoteCandidates(cands);
                      else
                        cands.forEach(function(candidate) {
                          maybeAddCandidate(transceiver.iceTransport, candidate);
                        });
                    if (!usingBundle || 0 === sdpMLineIndex) {
                      if ("new" === iceTransport.state)
                        iceTransport.start(iceGatherer, remoteIceParameters, "controlling");
                      if ("new" === dtlsTransport.state) dtlsTransport.start(remoteDtlsParameters);
                    }
                    var commonCapabilities = getCommonCapabilities(
                      transceiver.localCapabilities,
                      transceiver.remoteCapabilities
                    );
                    var hasRtx = commonCapabilities.codecs.filter(function(c) {
                      return "rtx" === c.name.toLowerCase();
                    }).length;
                    if (!hasRtx && transceiver.sendEncodingParameters[0].rtx)
                      delete transceiver.sendEncodingParameters[0].rtx;
                    pc._transceive(
                      transceiver,
                      "sendrecv" === direction || "recvonly" === direction,
                      "sendrecv" === direction || "sendonly" === direction
                    );
                    if (rtpReceiver && ("sendrecv" === direction || "sendonly" === direction)) {
                      track = rtpReceiver.track;
                      if (remoteMsid) {
                        if (!streams[remoteMsid.stream]) streams[remoteMsid.stream] = new window.MediaStream();
                        addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                        receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                      } else {
                        if (!streams.default) streams.default = new window.MediaStream();
                        addTrackToStreamAndFireEvent(track, streams.default);
                        receiverList.push([track, rtpReceiver, streams.default]);
                      }
                    } else delete transceiver.rtpReceiver;
                  }
                });
                if (void 0 === pc._dtlsRole) pc._dtlsRole = "offer" === description.type ? "active" : "passive";
                pc._remoteDescription = { type: description.type, sdp: description.sdp };
                if ("offer" === description.type) pc._updateSignalingState("have-remote-offer");
                else pc._updateSignalingState("stable");
                Object.keys(streams).forEach(function(sid) {
                  var stream = streams[sid];
                  if (stream.getTracks().length) {
                    if (-1 === pc.remoteStreams.indexOf(stream)) {
                      pc.remoteStreams.push(stream);
                      var event = new Event("addstream");
                      event.stream = stream;
                      window.setTimeout(function() {
                        pc._dispatchEvent("addstream", event);
                      });
                    }
                    receiverList.forEach(function(item) {
                      var track = item[0];
                      var receiver = item[1];
                      if (stream.id !== item[2].id) return;
                      fireAddTrack(pc, track, receiver, [stream]);
                    });
                  }
                });
                receiverList.forEach(function(item) {
                  if (item[2]) return;
                  fireAddTrack(pc, item[0], item[1], []);
                });
                window.setTimeout(function() {
                  if (!(pc && pc.transceivers)) return;
                  pc.transceivers.forEach(function(transceiver) {
                    if (
                      transceiver.iceTransport &&
                      "new" === transceiver.iceTransport.state &&
                      transceiver.iceTransport.getRemoteCandidates().length > 0
                    ) {
                      console.warn(
                        "Timeout for addRemoteCandidate. Consider sending " + "an end-of-candidates notification"
                      );
                      transceiver.iceTransport.addRemoteCandidate({});
                    }
                  });
                }, 4e3);
                return Promise.resolve();
              };
              RTCPeerConnection.prototype.close = function() {
                this.transceivers.forEach(function(transceiver) {
                  if (transceiver.iceTransport) transceiver.iceTransport.stop();
                  if (transceiver.dtlsTransport) transceiver.dtlsTransport.stop();
                  if (transceiver.rtpSender) transceiver.rtpSender.stop();
                  if (transceiver.rtpReceiver) transceiver.rtpReceiver.stop();
                });
                this._isClosed = true;
                this._updateSignalingState("closed");
              };
              RTCPeerConnection.prototype._updateSignalingState = function(newState) {
                this.signalingState = newState;
                var event = new Event("signalingstatechange");
                this._dispatchEvent("signalingstatechange", event);
              };
              RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
                var pc = this;
                if ("stable" !== this.signalingState || true === this.needNegotiation) return;
                this.needNegotiation = true;
                window.setTimeout(function() {
                  if (pc.needNegotiation) {
                    pc.needNegotiation = false;
                    var event = new Event("negotiationneeded");
                    pc._dispatchEvent("negotiationneeded", event);
                  }
                }, 0);
              };
              RTCPeerConnection.prototype._updateIceConnectionState = function() {
                var newState;
                var states = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
                this.transceivers.forEach(function(transceiver) {
                  if (transceiver.iceTransport && !transceiver.rejected) states[transceiver.iceTransport.state]++;
                });
                newState = "new";
                if (states.failed > 0) newState = "failed";
                else if (states.checking > 0) newState = "checking";
                else if (states.disconnected > 0) newState = "disconnected";
                else if (states.new > 0) newState = "new";
                else if (states.connected > 0) newState = "connected";
                else if (states.completed > 0) newState = "completed";
                if (newState !== this.iceConnectionState) {
                  this.iceConnectionState = newState;
                  var event = new Event("iceconnectionstatechange");
                  this._dispatchEvent("iceconnectionstatechange", event);
                }
              };
              RTCPeerConnection.prototype._updateConnectionState = function() {
                var newState;
                var states = {
                  new: 0,
                  closed: 0,
                  connecting: 0,
                  connected: 0,
                  completed: 0,
                  disconnected: 0,
                  failed: 0
                };
                this.transceivers.forEach(function(transceiver) {
                  if (transceiver.iceTransport && transceiver.dtlsTransport && !transceiver.rejected) {
                    states[transceiver.iceTransport.state]++;
                    states[transceiver.dtlsTransport.state]++;
                  }
                });
                states.connected += states.completed;
                newState = "new";
                if (states.failed > 0) newState = "failed";
                else if (states.connecting > 0) newState = "connecting";
                else if (states.disconnected > 0) newState = "disconnected";
                else if (states.new > 0) newState = "new";
                else if (states.connected > 0) newState = "connected";
                if (newState !== this.connectionState) {
                  this.connectionState = newState;
                  var event = new Event("connectionstatechange");
                  this._dispatchEvent("connectionstatechange", event);
                }
              };
              RTCPeerConnection.prototype.createOffer = function() {
                var pc = this;
                if (pc._isClosed)
                  return Promise.reject(makeError("InvalidStateError", "Can not call createOffer after close"));
                var numAudioTracks = pc.transceivers.filter(function(t) {
                  return "audio" === t.kind;
                }).length;
                var numVideoTracks = pc.transceivers.filter(function(t) {
                  return "video" === t.kind;
                }).length;
                var offerOptions = arguments[0];
                if (offerOptions) {
                  if (offerOptions.mandatory || offerOptions.optional)
                    throw new TypeError("Legacy mandatory/optional constraints not supported.");
                  if (void 0 !== offerOptions.offerToReceiveAudio)
                    if (true === offerOptions.offerToReceiveAudio) numAudioTracks = 1;
                    else if (false === offerOptions.offerToReceiveAudio) numAudioTracks = 0;
                    else numAudioTracks = offerOptions.offerToReceiveAudio;
                  if (void 0 !== offerOptions.offerToReceiveVideo)
                    if (true === offerOptions.offerToReceiveVideo) numVideoTracks = 1;
                    else if (false === offerOptions.offerToReceiveVideo) numVideoTracks = 0;
                    else numVideoTracks = offerOptions.offerToReceiveVideo;
                }
                pc.transceivers.forEach(function(transceiver) {
                  if ("audio" === transceiver.kind) {
                    numAudioTracks--;
                    if (numAudioTracks < 0) transceiver.wantReceive = false;
                  } else if ("video" === transceiver.kind) {
                    numVideoTracks--;
                    if (numVideoTracks < 0) transceiver.wantReceive = false;
                  }
                });
                while (numAudioTracks > 0 || numVideoTracks > 0) {
                  if (numAudioTracks > 0) {
                    pc._createTransceiver("audio");
                    numAudioTracks--;
                  }
                  if (numVideoTracks > 0) {
                    pc._createTransceiver("video");
                    numVideoTracks--;
                  }
                }
                var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
                pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                  var track = transceiver.track;
                  var kind = transceiver.kind;
                  var mid = transceiver.mid || SDPUtils.generateIdentifier();
                  transceiver.mid = mid;
                  if (!transceiver.iceGatherer)
                    transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);
                  var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
                  if (edgeVersion < 15019)
                    localCapabilities.codecs = localCapabilities.codecs.filter(function(codec) {
                      return "rtx" !== codec.name;
                    });
                  localCapabilities.codecs.forEach(function(codec) {
                    if ("H264" === codec.name && void 0 === codec.parameters["level-asymmetry-allowed"])
                      codec.parameters["level-asymmetry-allowed"] = "1";
                    if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs)
                      transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
                        if (
                          codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                          codec.clockRate === remoteCodec.clockRate
                        )
                          codec.preferredPayloadType = remoteCodec.payloadType;
                      });
                  });
                  localCapabilities.headerExtensions.forEach(function(hdrExt) {
                    var remoteExtensions =
                      (transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions) || [];
                    remoteExtensions.forEach(function(rHdrExt) {
                      if (hdrExt.uri === rHdrExt.uri) hdrExt.id = rHdrExt.id;
                    });
                  });
                  var sendEncodingParameters = transceiver.sendEncodingParameters || [
                    { ssrc: 1001 * (2 * sdpMLineIndex + 1) }
                  ];
                  if (track)
                    if (edgeVersion >= 15019 && "video" === kind && !sendEncodingParameters[0].rtx)
                      sendEncodingParameters[0].rtx = { ssrc: sendEncodingParameters[0].ssrc + 1 };
                  if (transceiver.wantReceive)
                    transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
                  transceiver.localCapabilities = localCapabilities;
                  transceiver.sendEncodingParameters = sendEncodingParameters;
                });
                if ("max-compat" !== pc._config.bundlePolicy)
                  sdp +=
                    "a=group:BUNDLE " +
                    pc.transceivers
                      .map(function(t) {
                        return t.mid;
                      })
                      .join(" ") +
                    "\r\n";
                sdp += "a=ice-options:trickle\r\n";
                pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                  sdp += writeMediaSection(
                    transceiver,
                    transceiver.localCapabilities,
                    "offer",
                    transceiver.stream,
                    pc._dtlsRole
                  );
                  sdp += "a=rtcp-rsize\r\n";
                  if (
                    transceiver.iceGatherer &&
                    "new" !== pc.iceGatheringState &&
                    (0 === sdpMLineIndex || !pc.usingBundle)
                  ) {
                    transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
                      cand.component = 1;
                      sdp += "a=" + SDPUtils.writeCandidate(cand) + "\r\n";
                    });
                    if ("completed" === transceiver.iceGatherer.state) sdp += "a=end-of-candidates\r\n";
                  }
                });
                var desc = new window.RTCSessionDescription({ type: "offer", sdp: sdp });
                return Promise.resolve(desc);
              };
              RTCPeerConnection.prototype.createAnswer = function() {
                var pc = this;
                if (pc._isClosed)
                  return Promise.reject(makeError("InvalidStateError", "Can not call createAnswer after close"));
                if (!("have-remote-offer" === pc.signalingState || "have-local-pranswer" === pc.signalingState))
                  return Promise.reject(
                    makeError("InvalidStateError", "Can not call createAnswer in signalingState " + pc.signalingState)
                  );
                var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
                if (pc.usingBundle)
                  sdp +=
                    "a=group:BUNDLE " +
                    pc.transceivers
                      .map(function(t) {
                        return t.mid;
                      })
                      .join(" ") +
                    "\r\n";
                sdp += "a=ice-options:trickle\r\n";
                var mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;
                pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                  if (sdpMLineIndex + 1 > mediaSectionsInOffer) return;
                  if (transceiver.rejected) {
                    if ("application" === transceiver.kind)
                      if ("DTLS/SCTP" === transceiver.protocol) sdp += "m=application 0 DTLS/SCTP 5000\r\n";
                      else sdp += "m=application 0 " + transceiver.protocol + " webrtc-datachannel\r\n";
                    else if ("audio" === transceiver.kind)
                      sdp += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\n" + "a=rtpmap:0 PCMU/8000\r\n";
                    else if ("video" === transceiver.kind)
                      sdp += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\n" + "a=rtpmap:120 VP8/90000\r\n";
                    sdp += "c=IN IP4 0.0.0.0\r\n" + "a=inactive\r\n" + "a=mid:" + transceiver.mid + "\r\n";
                    return;
                  }
                  if (transceiver.stream) {
                    var localTrack;
                    if ("audio" === transceiver.kind) localTrack = transceiver.stream.getAudioTracks()[0];
                    else if ("video" === transceiver.kind) localTrack = transceiver.stream.getVideoTracks()[0];
                    if (localTrack)
                      if (
                        edgeVersion >= 15019 &&
                        "video" === transceiver.kind &&
                        !transceiver.sendEncodingParameters[0].rtx
                      )
                        transceiver.sendEncodingParameters[0].rtx = {
                          ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                        };
                  }
                  var commonCapabilities = getCommonCapabilities(
                    transceiver.localCapabilities,
                    transceiver.remoteCapabilities
                  );
                  var hasRtx = commonCapabilities.codecs.filter(function(c) {
                    return "rtx" === c.name.toLowerCase();
                  }).length;
                  if (!hasRtx && transceiver.sendEncodingParameters[0].rtx)
                    delete transceiver.sendEncodingParameters[0].rtx;
                  sdp += writeMediaSection(transceiver, commonCapabilities, "answer", transceiver.stream, pc._dtlsRole);
                  if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) sdp += "a=rtcp-rsize\r\n";
                });
                var desc = new window.RTCSessionDescription({ type: "answer", sdp: sdp });
                return Promise.resolve(desc);
              };
              RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
                var pc = this;
                var sections;
                if (candidate && !(void 0 !== candidate.sdpMLineIndex || candidate.sdpMid))
                  return Promise.reject(new TypeError("sdpMLineIndex or sdpMid required"));
                return new Promise(function(resolve, reject) {
                  if (!pc._remoteDescription)
                    return reject(
                      makeError("InvalidStateError", "Can not add ICE candidate without a remote description")
                    );
                  else if (!candidate || "" === candidate.candidate)
                    for (var j = 0; j < pc.transceivers.length; j++) {
                      if (pc.transceivers[j].rejected) continue;
                      pc.transceivers[j].iceTransport.addRemoteCandidate({});
                      sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                      sections[j] += "a=end-of-candidates\r\n";
                      pc._remoteDescription.sdp =
                        SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join("");
                      if (pc.usingBundle) break;
                    }
                  else {
                    var sdpMLineIndex = candidate.sdpMLineIndex;
                    if (candidate.sdpMid)
                      for (var i = 0; i < pc.transceivers.length; i++)
                        if (pc.transceivers[i].mid === candidate.sdpMid) {
                          sdpMLineIndex = i;
                          break;
                        }
                    var transceiver = pc.transceivers[sdpMLineIndex];
                    if (transceiver) {
                      if (transceiver.rejected) return resolve();
                      var cand =
                        Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};
                      if ("tcp" === cand.protocol && (0 === cand.port || 9 === cand.port)) return resolve();
                      if (cand.component && 1 !== cand.component) return resolve();
                      if (
                        0 === sdpMLineIndex ||
                        (sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport)
                      )
                        if (!maybeAddCandidate(transceiver.iceTransport, cand))
                          return reject(makeError("OperationError", "Can not add ICE candidate"));
                      var candidateString = candidate.candidate.trim();
                      if (0 === candidateString.indexOf("a=")) candidateString = candidateString.substr(2);
                      sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                      sections[sdpMLineIndex] += "a=" + (cand.type ? candidateString : "end-of-candidates") + "\r\n";
                      pc._remoteDescription.sdp =
                        SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join("");
                    } else return reject(makeError("OperationError", "Can not add ICE candidate"));
                  }
                  resolve();
                });
              };
              RTCPeerConnection.prototype.getStats = function(selector) {
                if (selector && selector instanceof window.MediaStreamTrack) {
                  var senderOrReceiver = null;
                  this.transceivers.forEach(function(transceiver) {
                    if (transceiver.rtpSender && transceiver.rtpSender.track === selector)
                      senderOrReceiver = transceiver.rtpSender;
                    else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector)
                      senderOrReceiver = transceiver.rtpReceiver;
                  });
                  if (!senderOrReceiver) throw makeError("InvalidAccessError", "Invalid selector.");
                  return senderOrReceiver.getStats();
                }
                var promises = [];
                this.transceivers.forEach(function(transceiver) {
                  ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(
                    method
                  ) {
                    if (transceiver[method]) promises.push(transceiver[method].getStats());
                  });
                });
                return Promise.all(promises).then(function(allStats) {
                  var results = new Map();
                  allStats.forEach(function(stats) {
                    stats.forEach(function(stat) {
                      results.set(stat.id, stat);
                    });
                  });
                  return results;
                });
              };
              var ortcObjects = [
                "RTCRtpSender",
                "RTCRtpReceiver",
                "RTCIceGatherer",
                "RTCIceTransport",
                "RTCDtlsTransport"
              ];
              ortcObjects.forEach(function(ortcObjectName) {
                var obj = window[ortcObjectName];
                if (obj && obj.prototype && obj.prototype.getStats) {
                  var nativeGetstats = obj.prototype.getStats;
                  obj.prototype.getStats = function() {
                    return nativeGetstats.apply(this).then(function(nativeStats) {
                      var mapStats = new Map();
                      Object.keys(nativeStats).forEach(function(id) {
                        nativeStats[id].type = fixStatsType(nativeStats[id]);
                        mapStats.set(id, nativeStats[id]);
                      });
                      return mapStats;
                    });
                  };
                }
              });
              var methods = ["createOffer", "createAnswer"];
              methods.forEach(function(method) {
                var nativeMethod = RTCPeerConnection.prototype[method];
                RTCPeerConnection.prototype[method] = function() {
                  var args = arguments;
                  if ("function" === typeof args[0] || "function" === typeof args[1])
                    return nativeMethod.apply(this, [arguments[2]]).then(
                      function(description) {
                        if ("function" === typeof args[0]) args[0].apply(null, [description]);
                      },
                      function(error) {
                        if ("function" === typeof args[1]) args[1].apply(null, [error]);
                      }
                    );
                  return nativeMethod.apply(this, arguments);
                };
              });
              methods = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"];
              methods.forEach(function(method) {
                var nativeMethod = RTCPeerConnection.prototype[method];
                RTCPeerConnection.prototype[method] = function() {
                  var args = arguments;
                  if ("function" === typeof args[1] || "function" === typeof args[2])
                    return nativeMethod.apply(this, arguments).then(
                      function() {
                        if ("function" === typeof args[1]) args[1].apply(null);
                      },
                      function(error) {
                        if ("function" === typeof args[2]) args[2].apply(null, [error]);
                      }
                    );
                  return nativeMethod.apply(this, arguments);
                };
              });
              ["getStats"].forEach(function(method) {
                var nativeMethod = RTCPeerConnection.prototype[method];
                RTCPeerConnection.prototype[method] = function() {
                  var args = arguments;
                  if ("function" === typeof args[1])
                    return nativeMethod.apply(this, arguments).then(function() {
                      if ("function" === typeof args[1]) args[1].apply(null);
                    });
                  return nativeMethod.apply(this, arguments);
                };
              });
              return RTCPeerConnection;
            };
          },
          { sdp: 17 }
        ],
        17: [
          function(require, module, exports) {
            var SDPUtils = {};
            SDPUtils.generateIdentifier = function() {
              return Math.random()
                .toString(36)
                .substr(2, 10);
            };
            SDPUtils.localCName = SDPUtils.generateIdentifier();
            SDPUtils.splitLines = function(blob) {
              return blob
                .trim()
                .split("\n")
                .map(function(line) {
                  return line.trim();
                });
            };
            SDPUtils.splitSections = function(blob) {
              var parts = blob.split("\nm=");
              return parts.map(function(part, index) {
                return (index > 0 ? "m=" + part : part).trim() + "\r\n";
              });
            };
            SDPUtils.getDescription = function(blob) {
              var sections = SDPUtils.splitSections(blob);
              return sections && sections[0];
            };
            SDPUtils.getMediaSections = function(blob) {
              var sections = SDPUtils.splitSections(blob);
              sections.shift();
              return sections;
            };
            SDPUtils.matchPrefix = function(blob, prefix) {
              return SDPUtils.splitLines(blob).filter(function(line) {
                return 0 === line.indexOf(prefix);
              });
            };
            SDPUtils.parseCandidate = function(line) {
              var parts;
              if (0 === line.indexOf("a=candidate:")) parts = line.substring(12).split(" ");
              else parts = line.substring(10).split(" ");
              var candidate = {
                foundation: parts[0],
                component: parseInt(parts[1], 10),
                protocol: parts[2].toLowerCase(),
                priority: parseInt(parts[3], 10),
                ip: parts[4],
                address: parts[4],
                port: parseInt(parts[5], 10),
                type: parts[7]
              };
              for (var i = 8; i < parts.length; i += 2)
                switch (parts[i]) {
                  case "raddr":
                    candidate.relatedAddress = parts[i + 1];
                    break;
                  case "rport":
                    candidate.relatedPort = parseInt(parts[i + 1], 10);
                    break;
                  case "tcptype":
                    candidate.tcpType = parts[i + 1];
                    break;
                  case "ufrag":
                    candidate.ufrag = parts[i + 1];
                    candidate.usernameFragment = parts[i + 1];
                    break;
                  default:
                    candidate[parts[i]] = parts[i + 1];
                }
              return candidate;
            };
            SDPUtils.writeCandidate = function(candidate) {
              var sdp = [];
              sdp.push(candidate.foundation);
              sdp.push(candidate.component);
              sdp.push(candidate.protocol.toUpperCase());
              sdp.push(candidate.priority);
              sdp.push(candidate.address || candidate.ip);
              sdp.push(candidate.port);
              var type = candidate.type;
              sdp.push("typ");
              sdp.push(type);
              if ("host" !== type && candidate.relatedAddress && candidate.relatedPort) {
                sdp.push("raddr");
                sdp.push(candidate.relatedAddress);
                sdp.push("rport");
                sdp.push(candidate.relatedPort);
              }
              if (candidate.tcpType && "tcp" === candidate.protocol.toLowerCase()) {
                sdp.push("tcptype");
                sdp.push(candidate.tcpType);
              }
              if (candidate.usernameFragment || candidate.ufrag) {
                sdp.push("ufrag");
                sdp.push(candidate.usernameFragment || candidate.ufrag);
              }
              return "candidate:" + sdp.join(" ");
            };
            SDPUtils.parseIceOptions = function(line) {
              return line.substr(14).split(" ");
            };
            SDPUtils.parseRtpMap = function(line) {
              var parts = line.substr(9).split(" ");
              var parsed = { payloadType: parseInt(parts.shift(), 10) };
              parts = parts[0].split("/");
              parsed.name = parts[0];
              parsed.clockRate = parseInt(parts[1], 10);
              parsed.channels = 3 === parts.length ? parseInt(parts[2], 10) : 1;
              parsed.numChannels = parsed.channels;
              return parsed;
            };
            SDPUtils.writeRtpMap = function(codec) {
              var pt = codec.payloadType;
              if (void 0 !== codec.preferredPayloadType) pt = codec.preferredPayloadType;
              var channels = codec.channels || codec.numChannels || 1;
              return (
                "a=rtpmap:" +
                pt +
                " " +
                codec.name +
                "/" +
                codec.clockRate +
                (1 !== channels ? "/" + channels : "") +
                "\r\n"
              );
            };
            SDPUtils.parseExtmap = function(line) {
              var parts = line.substr(9).split(" ");
              return {
                id: parseInt(parts[0], 10),
                direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
                uri: parts[1]
              };
            };
            SDPUtils.writeExtmap = function(headerExtension) {
              return (
                "a=extmap:" +
                (headerExtension.id || headerExtension.preferredId) +
                (headerExtension.direction && "sendrecv" !== headerExtension.direction
                  ? "/" + headerExtension.direction
                  : "") +
                " " +
                headerExtension.uri +
                "\r\n"
              );
            };
            SDPUtils.parseFmtp = function(line) {
              var parsed = {};
              var kv;
              var parts = line.substr(line.indexOf(" ") + 1).split(";");
              for (var j = 0; j < parts.length; j++) {
                kv = parts[j].trim().split("=");
                parsed[kv[0].trim()] = kv[1];
              }
              return parsed;
            };
            SDPUtils.writeFmtp = function(codec) {
              var line = "";
              var pt = codec.payloadType;
              if (void 0 !== codec.preferredPayloadType) pt = codec.preferredPayloadType;
              if (codec.parameters && Object.keys(codec.parameters).length) {
                var params = [];
                Object.keys(codec.parameters).forEach(function(param) {
                  if (codec.parameters[param]) params.push(param + "=" + codec.parameters[param]);
                  else params.push(param);
                });
                line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
              }
              return line;
            };
            SDPUtils.parseRtcpFb = function(line) {
              var parts = line.substr(line.indexOf(" ") + 1).split(" ");
              return { type: parts.shift(), parameter: parts.join(" ") };
            };
            SDPUtils.writeRtcpFb = function(codec) {
              var lines = "";
              var pt = codec.payloadType;
              if (void 0 !== codec.preferredPayloadType) pt = codec.preferredPayloadType;
              if (codec.rtcpFeedback && codec.rtcpFeedback.length)
                codec.rtcpFeedback.forEach(function(fb) {
                  lines +=
                    "a=rtcp-fb:" +
                    pt +
                    " " +
                    fb.type +
                    (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") +
                    "\r\n";
                });
              return lines;
            };
            SDPUtils.parseSsrcMedia = function(line) {
              var sp = line.indexOf(" ");
              var parts = { ssrc: parseInt(line.substr(7, sp - 7), 10) };
              var colon = line.indexOf(":", sp);
              if (colon > -1) {
                parts.attribute = line.substr(sp + 1, colon - sp - 1);
                parts.value = line.substr(colon + 1);
              } else parts.attribute = line.substr(sp + 1);
              return parts;
            };
            SDPUtils.parseSsrcGroup = function(line) {
              var parts = line.substr(13).split(" ");
              return {
                semantics: parts.shift(),
                ssrcs: parts.map(function(ssrc) {
                  return parseInt(ssrc, 10);
                })
              };
            };
            SDPUtils.getMid = function(mediaSection) {
              var mid = SDPUtils.matchPrefix(mediaSection, "a=mid:")[0];
              if (mid) return mid.substr(6);
            };
            SDPUtils.parseFingerprint = function(line) {
              var parts = line.substr(14).split(" ");
              return { algorithm: parts[0].toLowerCase(), value: parts[1] };
            };
            SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
              var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
              return { role: "auto", fingerprints: lines.map(SDPUtils.parseFingerprint) };
            };
            SDPUtils.writeDtlsParameters = function(params, setupType) {
              var sdp = "a=setup:" + setupType + "\r\n";
              params.fingerprints.forEach(function(fp) {
                sdp += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
              });
              return sdp;
            };
            SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
              var lines = SDPUtils.splitLines(mediaSection);
              lines = lines.concat(SDPUtils.splitLines(sessionpart));
              var iceParameters = {
                usernameFragment: lines
                  .filter(function(line) {
                    return 0 === line.indexOf("a=ice-ufrag:");
                  })[0]
                  .substr(12),
                password: lines
                  .filter(function(line) {
                    return 0 === line.indexOf("a=ice-pwd:");
                  })[0]
                  .substr(10)
              };
              return iceParameters;
            };
            SDPUtils.writeIceParameters = function(params) {
              return "a=ice-ufrag:" + params.usernameFragment + "\r\n" + "a=ice-pwd:" + params.password + "\r\n";
            };
            SDPUtils.parseRtpParameters = function(mediaSection) {
              var description = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] };
              var lines = SDPUtils.splitLines(mediaSection);
              var mline = lines[0].split(" ");
              for (var i = 3; i < mline.length; i++) {
                var pt = mline[i];
                var rtpmapline = SDPUtils.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
                if (rtpmapline) {
                  var codec = SDPUtils.parseRtpMap(rtpmapline);
                  var fmtps = SDPUtils.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
                  codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
                  codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(
                    SDPUtils.parseRtcpFb
                  );
                  description.codecs.push(codec);
                  switch (codec.name.toUpperCase()) {
                    case "RED":
                    case "ULPFEC":
                      description.fecMechanisms.push(codec.name.toUpperCase());
                  }
                }
              }
              SDPUtils.matchPrefix(mediaSection, "a=extmap:").forEach(function(line) {
                description.headerExtensions.push(SDPUtils.parseExtmap(line));
              });
              return description;
            };
            SDPUtils.writeRtpDescription = function(kind, caps) {
              var sdp = "";
              sdp += "m=" + kind + " ";
              sdp += caps.codecs.length > 0 ? "9" : "0";
              sdp += " UDP/TLS/RTP/SAVPF ";
              sdp +=
                caps.codecs
                  .map(function(codec) {
                    if (void 0 !== codec.preferredPayloadType) return codec.preferredPayloadType;
                    return codec.payloadType;
                  })
                  .join(" ") + "\r\n";
              sdp += "c=IN IP4 0.0.0.0\r\n";
              sdp += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
              caps.codecs.forEach(function(codec) {
                sdp += SDPUtils.writeRtpMap(codec);
                sdp += SDPUtils.writeFmtp(codec);
                sdp += SDPUtils.writeRtcpFb(codec);
              });
              var maxptime = 0;
              caps.codecs.forEach(function(codec) {
                if (codec.maxptime > maxptime) maxptime = codec.maxptime;
              });
              if (maxptime > 0) sdp += "a=maxptime:" + maxptime + "\r\n";
              sdp += "a=rtcp-mux\r\n";
              if (caps.headerExtensions)
                caps.headerExtensions.forEach(function(extension) {
                  sdp += SDPUtils.writeExtmap(extension);
                });
              return sdp;
            };
            SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
              var encodingParameters = [];
              var description = SDPUtils.parseRtpParameters(mediaSection);
              var hasRed = -1 !== description.fecMechanisms.indexOf("RED");
              var hasUlpfec = -1 !== description.fecMechanisms.indexOf("ULPFEC");
              var ssrcs = SDPUtils.matchPrefix(mediaSection, "a=ssrc:")
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(parts) {
                  return "cname" === parts.attribute;
                });
              var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
              var secondarySsrc;
              var flows = SDPUtils.matchPrefix(mediaSection, "a=ssrc-group:FID").map(function(line) {
                var parts = line.substr(17).split(" ");
                return parts.map(function(part) {
                  return parseInt(part, 10);
                });
              });
              if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) secondarySsrc = flows[0][1];
              description.codecs.forEach(function(codec) {
                if ("RTX" === codec.name.toUpperCase() && codec.parameters.apt) {
                  var encParam = { ssrc: primarySsrc, codecPayloadType: parseInt(codec.parameters.apt, 10) };
                  if (primarySsrc && secondarySsrc) encParam.rtx = { ssrc: secondarySsrc };
                  encodingParameters.push(encParam);
                  if (hasRed) {
                    encParam = JSON.parse(JSON.stringify(encParam));
                    encParam.fec = { ssrc: primarySsrc, mechanism: hasUlpfec ? "red+ulpfec" : "red" };
                    encodingParameters.push(encParam);
                  }
                }
              });
              if (0 === encodingParameters.length && primarySsrc) encodingParameters.push({ ssrc: primarySsrc });
              var bandwidth = SDPUtils.matchPrefix(mediaSection, "b=");
              if (bandwidth.length) {
                if (0 === bandwidth[0].indexOf("b=TIAS:")) bandwidth = parseInt(bandwidth[0].substr(7), 10);
                else if (0 === bandwidth[0].indexOf("b=AS:"))
                  bandwidth = 1e3 * parseInt(bandwidth[0].substr(5), 10) * 0.95 - 50 * 40 * 8;
                else bandwidth = void 0;
                encodingParameters.forEach(function(params) {
                  params.maxBitrate = bandwidth;
                });
              }
              return encodingParameters;
            };
            SDPUtils.parseRtcpParameters = function(mediaSection) {
              var rtcpParameters = {};
              var remoteSsrc = SDPUtils.matchPrefix(mediaSection, "a=ssrc:")
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(obj) {
                  return "cname" === obj.attribute;
                })[0];
              if (remoteSsrc) {
                rtcpParameters.cname = remoteSsrc.value;
                rtcpParameters.ssrc = remoteSsrc.ssrc;
              }
              var rsize = SDPUtils.matchPrefix(mediaSection, "a=rtcp-rsize");
              rtcpParameters.reducedSize = rsize.length > 0;
              rtcpParameters.compound = 0 === rsize.length;
              var mux = SDPUtils.matchPrefix(mediaSection, "a=rtcp-mux");
              rtcpParameters.mux = mux.length > 0;
              return rtcpParameters;
            };
            SDPUtils.parseMsid = function(mediaSection) {
              var parts;
              var spec = SDPUtils.matchPrefix(mediaSection, "a=msid:");
              if (1 === spec.length) {
                parts = spec[0].substr(7).split(" ");
                return { stream: parts[0], track: parts[1] };
              }
              var planB = SDPUtils.matchPrefix(mediaSection, "a=ssrc:")
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(msidParts) {
                  return "msid" === msidParts.attribute;
                });
              if (planB.length > 0) {
                parts = planB[0].value.split(" ");
                return { stream: parts[0], track: parts[1] };
              }
            };
            SDPUtils.generateSessionId = function() {
              return Math.random()
                .toString()
                .substr(2, 21);
            };
            SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
              var sessionId;
              var version = void 0 !== sessVer ? sessVer : 2;
              if (sessId) sessionId = sessId;
              else sessionId = SDPUtils.generateSessionId();
              var user = sessUser || "thisisadapterortc";
              return (
                "v=0\r\n" +
                "o=" +
                user +
                " " +
                sessionId +
                " " +
                version +
                " IN IP4 127.0.0.1\r\n" +
                "s=-\r\n" +
                "t=0 0\r\n"
              );
            };
            SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
              var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
              sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());
              sdp += SDPUtils.writeDtlsParameters(
                transceiver.dtlsTransport.getLocalParameters(),
                "offer" === type ? "actpass" : "active"
              );
              sdp += "a=mid:" + transceiver.mid + "\r\n";
              if (transceiver.direction) sdp += "a=" + transceiver.direction + "\r\n";
              else if (transceiver.rtpSender && transceiver.rtpReceiver) sdp += "a=sendrecv\r\n";
              else if (transceiver.rtpSender) sdp += "a=sendonly\r\n";
              else if (transceiver.rtpReceiver) sdp += "a=recvonly\r\n";
              else sdp += "a=inactive\r\n";
              if (transceiver.rtpSender) {
                var msid = "msid:" + stream.id + " " + transceiver.rtpSender.track.id + "\r\n";
                sdp += "a=" + msid;
                sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " " + msid;
                if (transceiver.sendEncodingParameters[0].rtx) {
                  sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " " + msid;
                  sdp +=
                    "a=ssrc-group:FID " +
                    transceiver.sendEncodingParameters[0].ssrc +
                    " " +
                    transceiver.sendEncodingParameters[0].rtx.ssrc +
                    "\r\n";
                }
              }
              sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " cname:" + SDPUtils.localCName + "\r\n";
              if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx)
                sdp +=
                  "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " cname:" + SDPUtils.localCName + "\r\n";
              return sdp;
            };
            SDPUtils.getDirection = function(mediaSection, sessionpart) {
              var lines = SDPUtils.splitLines(mediaSection);
              for (var i = 0; i < lines.length; i++)
                switch (lines[i]) {
                  case "a=sendrecv":
                  case "a=sendonly":
                  case "a=recvonly":
                  case "a=inactive":
                    return lines[i].substr(2);
                }
              if (sessionpart) return SDPUtils.getDirection(sessionpart);
              return "sendrecv";
            };
            SDPUtils.getKind = function(mediaSection) {
              var lines = SDPUtils.splitLines(mediaSection);
              var mline = lines[0].split(" ");
              return mline[0].substr(2);
            };
            SDPUtils.isRejected = function(mediaSection) {
              return "0" === mediaSection.split(" ", 2)[1];
            };
            SDPUtils.parseMLine = function(mediaSection) {
              var lines = SDPUtils.splitLines(mediaSection);
              var parts = lines[0].substr(2).split(" ");
              return {
                kind: parts[0],
                port: parseInt(parts[1], 10),
                protocol: parts[2],
                fmt: parts.slice(3).join(" ")
              };
            };
            SDPUtils.parseOLine = function(mediaSection) {
              var line = SDPUtils.matchPrefix(mediaSection, "o=")[0];
              var parts = line.substr(2).split(" ");
              return {
                username: parts[0],
                sessionId: parts[1],
                sessionVersion: parseInt(parts[2], 10),
                netType: parts[3],
                addressType: parts[4],
                address: parts[5]
              };
            };
            SDPUtils.isValidSDP = function(blob) {
              if ("string" !== typeof blob || 0 === blob.length) return false;
              var lines = SDPUtils.splitLines(blob);
              for (var i = 0; i < lines.length; i++)
                if (lines[i].length < 2 || "=" !== lines[i].charAt(1)) return false;
              return true;
            };
            if ("object" === typeof module) module.exports = SDPUtils;
          },
          {}
        ]
      },
      {},
      [1]
    );
  });
  unwrapExports(adapter_no_global);
  _fixReWks("match", 1, function(defined, MATCH, $match) {
    return [
      function match(regexp) {
        var O = defined(this);
        var fn = void 0 == regexp ? void 0 : regexp[MATCH];
        return void 0 !== fn ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      $match
    ];
  });
  var dP$2 = _objectDp.f;
  var FProto = Function.prototype;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME$1 = "name";
  NAME$1 in FProto ||
    (_descriptors &&
      dP$2(FProto, NAME$1, {
        configurable: true,
        get: function() {
          try {
            return ("" + this).match(nameRE)[1];
          } catch (e) {
            return "";
          }
        }
      }));
  var f$3 = _wks$1;
  var _wksExt = { f: f$3 };
  var iterator = _wksExt.f("iterator");
  var iterator$1 = iterator;
  var _meta = createCommonjsModule(function(module) {
    var META = _uid$1("meta");
    var setDesc = _objectDp$1.f;
    var id = 0;
    var isExtensible =
      Object.isExtensible ||
      function() {
        return true;
      };
    var FREEZE = !_fails$1(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var setMeta = function(it) {
      setDesc(it, META, { value: { i: "O" + ++id, w: {} } });
    };
    var fastKey = function(it, create) {
      if (!_isObject$1(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
      if (!_has$1(it, META)) {
        if (!isExtensible(it)) return "F";
        if (!create) return "E";
        setMeta(it);
      }
      return it[META].i;
    };
    var getWeak = function(it, create) {
      if (!_has$1(it, META)) {
        if (!isExtensible(it)) return true;
        if (!create) return false;
        setMeta(it);
      }
      return it[META].w;
    };
    var onFreeze = function(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !_has$1(it, META)) setMeta(it);
      return it;
    };
    var meta = (module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze });
  });
  _meta.KEY;
  _meta.NEED;
  _meta.fastKey;
  _meta.getWeak;
  _meta.onFreeze;
  var defineProperty = _objectDp$1.f;
  var _wksDefine = function(name) {
    var $Symbol = _core$1.Symbol || (_core$1.Symbol = {});
    if ("_" != name.charAt(0) && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
  };
  var f$4 = Object.getOwnPropertySymbols;
  var _objectGops = { f: f$4 };
  var f$5 = {}.propertyIsEnumerable;
  var _objectPie = { f: f$5 };
  var _enumKeys = function(it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, (key = symbols[i++]))) result.push(key);
    }
    return result;
  };
  var _isArray =
    Array.isArray ||
    function isArray(arg) {
      return "Array" == _cof$1(arg);
    };
  var hiddenKeys = _enumBugKeys.concat("length", "prototype");
  var f$6 =
    Object.getOwnPropertyNames ||
    function getOwnPropertyNames(O) {
      return _objectKeysInternal(O, hiddenKeys);
    };
  var _objectGopn = { f: f$6 };
  var gOPN = _objectGopn.f;
  var toString$2 = {}.toString;
  var windowNames =
    "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  var f$7 = function getOwnPropertyNames(it) {
    return windowNames && "[object Window]" == toString$2.call(it) ? getWindowNames(it) : gOPN(_toIobject(it));
  };
  var _objectGopnExt = { f: f$7 };
  var gOPD = Object.getOwnPropertyDescriptor;
  var f$8 = _descriptors$1
    ? gOPD
    : function getOwnPropertyDescriptor(O, P) {
        O = _toIobject(O);
        P = _toPrimitive$1(P, true);
        if (_ie8DomDefine$1)
          try {
            return gOPD(O, P);
          } catch (e) {}
        if (_has$1(O, P)) return _propertyDesc$1(!_objectPie.f.call(O, P), O[P]);
      };
  var _objectGopd = { f: f$8 };
  var META = _meta.KEY;
  var gOPD$1 = _objectGopd.f;
  var dP$3 = _objectDp$1.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global$1.Symbol;
  var $JSON = _global$1.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE$2 = "prototype";
  var HIDDEN = _wks$1("_hidden");
  var TO_PRIMITIVE = _wks$1("toPrimitive");
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared$1("symbol-registry");
  var AllSymbols = _shared$1("symbols");
  var OPSymbols = _shared$1("op-symbols");
  var ObjectProto$1 = Object[PROTOTYPE$2];
  var USE_NATIVE$1 = "function" == typeof $Symbol;
  var QObject = _global$1.QObject;
  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;
  var setSymbolDesc =
    _descriptors$1 &&
    _fails$1(function() {
      return (
        7 !=
        _objectCreate(
          dP$3({}, "a", {
            get: function() {
              return dP$3(this, "a", { value: 7 }).a;
            }
          })
        ).a
      );
    })
      ? function(it, key, D) {
          var protoDesc = gOPD$1(ObjectProto$1, key);
          if (protoDesc) delete ObjectProto$1[key];
          dP$3(it, key, D);
          if (protoDesc && it !== ObjectProto$1) dP$3(ObjectProto$1, key, protoDesc);
        }
      : dP$3;
  var wrap = function(tag) {
    var sym = (AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]));
    sym._k = tag;
    return sym;
  };
  var isSymbol =
    USE_NATIVE$1 && "symbol" == typeof $Symbol.iterator
      ? function(it) {
          return "symbol" == typeof it;
        }
      : function(it) {
          return it instanceof $Symbol;
        };
  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
    _anObject$1(it);
    key = _toPrimitive$1(key, true);
    _anObject$1(D);
    if (_has$1(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has$1(it, HIDDEN)) dP$3(it, HIDDEN, _propertyDesc$1(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has$1(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, { enumerable: _propertyDesc$1(0, false) });
      }
      return setSymbolDesc(it, key, D);
    }
    return dP$3(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    _anObject$1(it);
    var keys = _enumKeys((P = _toIobject(P)));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, (key = keys[i++]), P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return void 0 === P ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, (key = _toPrimitive$1(key, true)));
    if (this === ObjectProto$1 && _has$1(AllSymbols, key) && !_has$1(OPSymbols, key)) return false;
    return E || !_has$1(this, key) || !_has$1(AllSymbols, key) || (_has$1(this, HIDDEN) && this[HIDDEN][key])
      ? E
      : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive$1(key, true);
    if (it === ObjectProto$1 && _has$1(AllSymbols, key) && !_has$1(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has$1(AllSymbols, key) && !(_has$1(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i)
      if (!_has$1(AllSymbols, (key = names[i++])) && key != HIDDEN && key != META) result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto$1;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i)
      if (_has$1(AllSymbols, (key = names[i++])) && (IS_OP ? _has$1(ObjectProto$1, key) : true))
        result.push(AllSymbols[key]);
    return result;
  };
  if (!USE_NATIVE$1) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
      var tag = _uid$1(arguments.length > 0 ? arguments[0] : void 0);
      var $set = function(value) {
        if (this === ObjectProto$1) $set.call(OPSymbols, value);
        if (_has$1(this, HIDDEN) && _has$1(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc$1(1, value));
      };
      if (_descriptors$1 && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    _redefine$1($Symbol[PROTOTYPE$2], "toString", function toString() {
      return this._k;
    });
    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp$1.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;
    if (_descriptors$1 && !_library) _redefine$1(ObjectProto$1, "propertyIsEnumerable", $propertyIsEnumerable, true);
    _wksExt.f = function(name) {
      return wrap(_wks$1(name));
    };
  }
  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Symbol: $Symbol });
  for (
    var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(
        ","
      ),
      j = 0;
    es6Symbols.length > j;

  )
    _wks$1(es6Symbols[j++]);
  for (var wellKnownSymbols = _objectKeys(_wks$1.store), k = 0; wellKnownSymbols.length > k; )
    _wksDefine(wellKnownSymbols[k++]);
  _export(_export.S + _export.F * !USE_NATIVE$1, "Symbol", {
    for: function(key) {
      return _has$1(SymbolRegistry, (key += "")) ? SymbolRegistry[key] : (SymbolRegistry[key] = $Symbol(key));
    },
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  });
  _export(_export.S + _export.F * !USE_NATIVE$1, "Object", {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON &&
    _export(
      _export.S +
        _export.F *
          (!USE_NATIVE$1 ||
            _fails$1(function() {
              var S = $Symbol();
              return "[null]" != _stringify([S]) || "{}" != _stringify({ a: S }) || "{}" != _stringify(Object(S));
            })),
      "JSON",
      {
        stringify: function stringify(it) {
          var args = [it];
          var i = 1;
          var replacer, $replacer;
          while (arguments.length > i) args.push(arguments[i++]);
          $replacer = replacer = args[1];
          if ((!_isObject$1(replacer) && void 0 === it) || isSymbol(it)) return;
          if (!_isArray(replacer))
            replacer = function(key, value) {
              if ("function" == typeof $replacer) value = $replacer.call(this, key, value);
              if (!isSymbol(value)) return value;
            };
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        }
      }
    );
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide$1($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
  _setToStringTag($Symbol, "Symbol");
  _setToStringTag(Math, "Math", true);
  _setToStringTag(_global$1.JSON, "JSON", true);
  _wksDefine("asyncIterator");
  _wksDefine("observable");
  var symbol = _core$1.Symbol;
  var symbol$1 = symbol;
  var _typeof_1 = createCommonjsModule(function(module) {
    function _typeof2(obj) {
      if ("function" === typeof symbol$1 && "symbol" === typeof iterator$1)
        _typeof2 = function _typeof2(obj) {
          return typeof obj;
        };
      else
        _typeof2 = function _typeof2(obj) {
          return obj && "function" === typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype
            ? "symbol"
            : typeof obj;
        };
      return _typeof2(obj);
    }
    function _typeof(obj) {
      if ("function" === typeof symbol$1 && "symbol" === _typeof2(iterator$1))
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      else
        module.exports = _typeof = function _typeof(obj) {
          return obj && "function" === typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype
            ? "symbol"
            : _typeof2(obj);
        };
      return _typeof(obj);
    }
    module.exports = _typeof;
  });
  var uaParser = createCommonjsModule(function(module, exports) {
    (function(window, undefined$1) {
      var LIBVERSION = "0.7.19",
        EMPTY = "",
        UNKNOWN = "?",
        FUNC_TYPE = "function",
        UNDEF_TYPE = "undefined",
        OBJ_TYPE = "object",
        STR_TYPE = "string",
        MAJOR = "major",
        MODEL = "model",
        NAME = "name",
        TYPE = "type",
        VENDOR = "vendor",
        VERSION = "version",
        ARCHITECTURE = "architecture",
        CONSOLE = "console",
        MOBILE = "mobile",
        TABLET = "tablet",
        SMARTTV = "smarttv",
        WEARABLE = "wearable",
        EMBEDDED = "embedded";
      var util = {
        extend: function(regexes, extensions) {
          var margedRegexes = {};
          for (var i in regexes)
            if (extensions[i] && extensions[i].length % 2 === 0) margedRegexes[i] = extensions[i].concat(regexes[i]);
            else margedRegexes[i] = regexes[i];
          return margedRegexes;
        },
        has: function(str1, str2) {
          if ("string" === typeof str1) return -1 !== str2.toLowerCase().indexOf(str1.toLowerCase());
          else return false;
        },
        lowerize: function(str) {
          return str.toLowerCase();
        },
        major: function(version) {
          return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, "").split(".")[0] : undefined$1;
        },
        trim: function(str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        }
      };
      var mapper = {
        rgx: function(ua, arrays) {
          var j,
            k,
            p,
            q,
            matches,
            match,
            i = 0;
          while (i < arrays.length && !matches) {
            var regex = arrays[i],
              props = arrays[i + 1];
            j = k = 0;
            while (j < regex.length && !matches) {
              matches = regex[j++].exec(ua);
              if (!!matches)
                for (p = 0; p < props.length; p++) {
                  match = matches[++k];
                  q = props[p];
                  if (typeof q === OBJ_TYPE && q.length > 0) {
                    if (2 == q.length)
                      if (typeof q[1] == FUNC_TYPE) this[q[0]] = q[1].call(this, match);
                      else this[q[0]] = q[1];
                    else if (3 == q.length)
                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test))
                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                      else this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                    else if (4 == q.length) this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                  } else this[q] = match ? match : undefined$1;
                }
            }
            i += 2;
          }
        },
        str: function(str, map) {
          for (var i in map)
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
              for (var j = 0; j < map[i].length; j++)
                if (util.has(map[i][j], str)) return i === UNKNOWN ? undefined$1 : i;
            } else if (util.has(map[i], str)) return i === UNKNOWN ? undefined$1 : i;
          return str;
        }
      };
      var maps = {
        browser: {
          oldsafari: {
            version: {
              "1.0": "/8",
              1.2: "/1",
              1.3: "/3",
              "2.0": "/412",
              "2.0.2": "/416",
              "2.0.3": "/417",
              "2.0.4": "/419",
              "?": "/"
            }
          }
        },
        device: {
          amazon: { model: { "Fire Phone": ["SD", "KF"] } },
          sprint: { model: { "Evo Shift 4G": "7373KT" }, vendor: { HTC: "APA", Sprint: "Sprint" } }
        },
        os: {
          windows: {
            version: {
              ME: "4.90",
              "NT 3.11": "NT3.51",
              "NT 4.0": "NT4.0",
              2000: "NT 5.0",
              XP: ["NT 5.1", "NT 5.2"],
              Vista: "NT 6.0",
              7: "NT 6.1",
              8: "NT 6.2",
              8.1: "NT 6.3",
              10: ["NT 6.4", "NT 10.0"],
              RT: "ARM"
            }
          }
        }
      };
      var regexes = {
        browser: [
          [
            /(opera\smini)\/([\w\.-]+)/i,
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,
            /(opera).+version\/([\w\.]+)/i,
            /(opera)[\/\s]+([\w\.]+)/i
          ],
          [NAME, VERSION],
          [/(opios)[\/\s]+([\w\.]+)/i],
          [[NAME, "Opera Mini"], VERSION],
          [/\s(opr)\/([\w\.]+)/i],
          [[NAME, "Opera"], VERSION],
          [
            /(kindle)\/([\w\.]+)/i,
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
            /(?:ms|\()(ie)\s([\w\.]+)/i,
            /(rekonq)\/([\w\.]*)/i,
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i
          ],
          [NAME, VERSION],
          [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],
          [[NAME, "IE"], VERSION],
          [/(edge|edgios|edga)\/((\d+)?[\w\.]+)/i],
          [[NAME, "Edge"], VERSION],
          [/(yabrowser)\/([\w\.]+)/i],
          [[NAME, "Yandex"], VERSION],
          [/(puffin)\/([\w\.]+)/i],
          [[NAME, "Puffin"], VERSION],
          [/(focus)\/([\w\.]+)/i],
          [[NAME, "Firefox Focus"], VERSION],
          [/(opt)\/([\w\.]+)/i],
          [[NAME, "Opera Touch"], VERSION],
          [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],
          [[NAME, "UCBrowser"], VERSION],
          [/(comodo_dragon)\/([\w\.]+)/i],
          [[NAME, /_/g, " "], VERSION],
          [/(micromessenger)\/([\w\.]+)/i],
          [[NAME, "WeChat"], VERSION],
          [/(brave)\/([\w\.]+)/i],
          [[NAME, "Brave"], VERSION],
          [/(qqbrowserlite)\/([\w\.]+)/i],
          [NAME, VERSION],
          [/(QQ)\/([\d\.]+)/i],
          [NAME, VERSION],
          [/m?(qqbrowser)[\/\s]?([\w\.]+)/i],
          [NAME, VERSION],
          [/(BIDUBrowser)[\/\s]?([\w\.]+)/i],
          [NAME, VERSION],
          [/(2345Explorer)[\/\s]?([\w\.]+)/i],
          [NAME, VERSION],
          [/(MetaSr)[\/\s]?([\w\.]+)/i],
          [NAME],
          [/(LBBROWSER)/i],
          [NAME],
          [/xiaomi\/miuibrowser\/([\w\.]+)/i],
          [VERSION, [NAME, "MIUI Browser"]],
          [/;fbav\/([\w\.]+);/i],
          [VERSION, [NAME, "Facebook"]],
          [/safari\s(line)\/([\w\.]+)/i, /android.+(line)\/([\w\.]+)\/iab/i],
          [NAME, VERSION],
          [/headlesschrome(?:\/([\w\.]+)|\s)/i],
          [VERSION, [NAME, "Chrome Headless"]],
          [/\swv\).+(chrome)\/([\w\.]+)/i],
          [[NAME, /(.+)/, "$1 WebView"], VERSION],
          [/((?:oculus|samsung)browser)\/([\w\.]+)/i],
          [[NAME, /(.+(?:g|us))(.+)/, "$1 $2"], VERSION],
          [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],
          [VERSION, [NAME, "Android Browser"]],
          [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],
          [NAME, VERSION],
          [/(dolfin)\/([\w\.]+)/i],
          [[NAME, "Dolphin"], VERSION],
          [/((?:android.+)crmo|crios)\/([\w\.]+)/i],
          [[NAME, "Chrome"], VERSION],
          [/(coast)\/([\w\.]+)/i],
          [[NAME, "Opera Coast"], VERSION],
          [/fxios\/([\w\.-]+)/i],
          [VERSION, [NAME, "Firefox"]],
          [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],
          [VERSION, [NAME, "Mobile Safari"]],
          [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],
          [VERSION, NAME],
          [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
          [[NAME, "GSA"], VERSION],
          [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
          [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]],
          [/(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i],
          [NAME, VERSION],
          [/(navigator|netscape)\/([\w\.-]+)/i],
          [[NAME, "Netscape"], VERSION],
          [
            /(swiftfox)/i,
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
            /(links)\s\(([\w\.]+)/i,
            /(gobrowser)\/?([\w\.]*)/i,
            /(ice\s?browser)\/v?([\w\._]+)/i,
            /(mosaic)[\/\s]([\w\.]+)/i
          ],
          [NAME, VERSION]
        ],
        cpu: [
          [/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],
          [[ARCHITECTURE, "amd64"]],
          [/(ia32(?=;))/i],
          [[ARCHITECTURE, util.lowerize]],
          [/((?:i[346]|x)86)[;\)]/i],
          [[ARCHITECTURE, "ia32"]],
          [/windows\s(ce|mobile);\sppc;/i],
          [[ARCHITECTURE, "arm"]],
          [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],
          [[ARCHITECTURE, /ower/, "", util.lowerize]],
          [/(sun4\w)[;\)]/i],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
          ],
          [[ARCHITECTURE, util.lowerize]]
        ],
        device: [
          [/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [/applecoremedia\/[\w\.]+ \((ipad)/],
          [MODEL, [VENDOR, "Apple"], [TYPE, TABLET]],
          [/(apple\s{0,1}tv)/i],
          [[MODEL, "Apple TV"], [VENDOR, "Apple"]],
          [
            /(archos)\s(gamepad2?)/i,
            /(hp).+(touchpad)/i,
            /(hp).+(tablet)/i,
            /(kindle)\/([\w\.]+)/i,
            /\s(nook)[\w\s]+build\/(\w+)/i,
            /(dell)\s(strea[kpr\s\d]*[\dko])/i
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [/(kf[A-z]+)\sbuild\/.+silk\//i],
          [MODEL, [VENDOR, "Amazon"], [TYPE, TABLET]],
          [/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],
          [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, "Amazon"], [TYPE, MOBILE]],
          [/android.+aft([bms])\sbuild/i],
          [MODEL, [VENDOR, "Amazon"], [TYPE, SMARTTV]],
          [/\((ip[honed|\s\w*]+);.+(apple)/i],
          [MODEL, VENDOR, [TYPE, MOBILE]],
          [/\((ip[honed|\s\w*]+);/i],
          [MODEL, [VENDOR, "Apple"], [TYPE, MOBILE]],
          [
            /(blackberry)[\s-]?(\w+)/i,
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
            /(hp)\s([\w\s]+\w)/i,
            /(asus)-?(\w+)/i
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [/\(bb10;\s(\w+)/i],
          [MODEL, [VENDOR, "BlackBerry"], [TYPE, MOBILE]],
          [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],
          [MODEL, [VENDOR, "Asus"], [TYPE, TABLET]],
          [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i],
          [[VENDOR, "Sony"], [MODEL, "Xperia Tablet"], [TYPE, TABLET]],
          [/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],
          [MODEL, [VENDOR, "Sony"], [TYPE, MOBILE]],
          [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [/android.+;\s(shield)\sbuild/i],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [/(playstation\s[34portablevi]+)/i],
          [MODEL, [VENDOR, "Sony"], [TYPE, CONSOLE]],
          [/(sprint\s(\w+))/i],
          [
            [VENDOR, mapper.str, maps.device.sprint.vendor],
            [MODEL, mapper.str, maps.device.sprint.model],
            [TYPE, MOBILE]
          ],
          [/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,
            /(zte)-(\w*)/i,
            /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [/(nexus\s9)/i],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i],
          [MODEL, [VENDOR, "Huawei"], [TYPE, MOBILE]],
          [/(microsoft);\s(lumia[\s\w]+)/i],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [/[\s\(;](xbox(?:\sone)?)[\s\);]/i],
          [MODEL, [VENDOR, "Microsoft"], [TYPE, CONSOLE]],
          [/(kin\.[onetw]{3})/i],
          [[MODEL, /\./g, " "], [VENDOR, "Microsoft"], [TYPE, MOBILE]],
          [
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w*)/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
          ],
          [MODEL, [VENDOR, "Motorola"], [TYPE, MOBILE]],
          [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],
          [MODEL, [VENDOR, "Motorola"], [TYPE, TABLET]],
          [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],
          [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]],
          [/hbbtv.+maple;(\d+)/i],
          [[MODEL, /^/, "SmartTV"], [VENDOR, "Samsung"], [TYPE, SMARTTV]],
          [/\(dtv[\);].+(aquos)/i],
          [MODEL, [VENDOR, "Sharp"], [TYPE, SMARTTV]],
          [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i],
          [[VENDOR, "Samsung"], MODEL, [TYPE, TABLET]],
          [/smart-tv.+(samsung)/i],
          [VENDOR, [TYPE, SMARTTV], MODEL],
          [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i],
          [[VENDOR, "Samsung"], MODEL, [TYPE, MOBILE]],
          [/sie-(\w*)/i],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i],
          [[VENDOR, "Nokia"], MODEL, [TYPE, MOBILE]],
          [/android\s3\.[\s\w;-]{10}(a\d{3})/i],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [/android.+([vl]k\-?\d{3})\s+build/i],
          [MODEL, [VENDOR, "LG"], [TYPE, TABLET]],
          [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],
          [[VENDOR, "LG"], MODEL, [TYPE, TABLET]],
          [/(lg) netcast\.tv/i],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i],
          [MODEL, [VENDOR, "LG"], [TYPE, MOBILE]],
          [/android.+(ideatab[a-z0-9\-\s]+)/i],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [/linux;.+((jolla));/i],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [/((pebble))app\/[\d\.]+\s/i],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [/crkey/i],
          [[MODEL, "Chromecast"], [VENDOR, "Google"]],
          [/android.+;\s(glass)\s\d/i],
          [MODEL, [VENDOR, "Google"], [TYPE, WEARABLE]],
          [/android.+;\s(pixel c)[\s)]/i],
          [MODEL, [VENDOR, "Google"], [TYPE, TABLET]],
          [/android.+;\s(pixel( [23])?( xl)?)\s/i],
          [MODEL, [VENDOR, "Google"], [TYPE, MOBILE]],
          [
            /android.+;\s(\w+)\s+build\/hm\1/i,
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,
            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,
            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Xiaomi"], [TYPE, MOBILE]],
          [/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],
          [[MODEL, /_/g, " "], [VENDOR, "Xiaomi"], [TYPE, TABLET]],
          [/android.+;\s(m[1-5]\snote)\sbuild/i],
          [MODEL, [VENDOR, "Meizu"], [TYPE, TABLET]],
          [/(mz)-([\w-]{2,})/i],
          [[VENDOR, "Meizu"], MODEL, [TYPE, MOBILE]],
          [/android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})\s+build/i],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],
          [[VENDOR, "Barnes & Noble"], MODEL, [TYPE, TABLET]],
          [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [/android.+;\s(k88)\sbuild/i],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [/android.+[;\/]\s*(zur\d{3})\s+build/i],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [/(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [/android.+;\s(PH-1)\s/i],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [/android.+[;\/]\s*TU_(1491)\s+build/i],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [/android.+(KS(.+))\s+build/i],
          [MODEL, [VENDOR, "Amazon"], [TYPE, TABLET]],
          [/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i],
          [[TYPE, util.lowerize], VENDOR, MODEL],
          [/(android[\w\.\s\-]{0,9});.+build/i],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [/windows.+\sedge\/([\w\.]+)/i],
          [VERSION, [NAME, "EdgeHTML"]],
          [
            /(presto)\/([\w\.]+)/i,
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,
            /(icab)[\/\s]([23]\.[\d\.]+)/i
          ],
          [NAME, VERSION],
          [/rv\:([\w\.]{1,9}).+(gecko)/i],
          [VERSION, NAME]
        ],
        os: [
          [/microsoft\s(windows)\s(vista|xp)/i],
          [NAME, VERSION],
          [
            /(windows)\snt\s6\.2;\s(arm)/i,
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
          ],
          [NAME, [VERSION, mapper.str, maps.os.windows.version]],
          [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],
          [[NAME, "Windows"], [VERSION, mapper.str, maps.os.windows.version]],
          [/\((bb)(10);/i],
          [[NAME, "BlackBerry"], VERSION],
          [
            /(blackberry)\w*\/?([\w\.]*)/i,
            /(tizen)[\/\s]([\w\.]+)/i,
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,
            /linux;.+(sailfish);/i
          ],
          [NAME, VERSION],
          [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],
          [[NAME, "Symbian"], VERSION],
          [/\((series40);/i],
          [NAME],
          [/mozilla.+\(mobile;.+gecko.+firefox/i],
          [[NAME, "Firefox OS"], VERSION],
          [
            /(nintendo|playstation)\s([wids34portablevu]+)/i,
            /(mint)[\/\s\(]?(\w*)/i,
            /(mageia|vectorlinux)[;\s]/i,
            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,
            /(hurd|linux)\s?([\w\.]*)/i,
            /(gnu)\s?([\w\.]*)/i
          ],
          [NAME, VERSION],
          [/(cros)\s[\w]+\s([\w\.]+\w)/i],
          [[NAME, "Chromium OS"], VERSION],
          [/(sunos)\s?([\w\.\d]*)/i],
          [[NAME, "Solaris"], VERSION],
          [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],
          [NAME, VERSION],
          [/(haiku)\s(\w+)/i],
          [NAME, VERSION],
          [/cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i],
          [[NAME, "Mac OS"], [VERSION, /_/g, "."]],
          [
            /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,
            /(unix)\s?([\w\.]*)/i
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser = function(uastring, extensions) {
        if ("object" === typeof uastring) {
          extensions = uastring;
          uastring = undefined$1;
        }
        if (!(this instanceof UAParser)) return new UAParser(uastring, extensions).getResult();
        var ua =
          uastring || (window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
        this.getBrowser = function() {
          var browser = { name: undefined$1, version: undefined$1 };
          mapper.rgx.call(browser, ua, rgxmap.browser);
          browser.major = util.major(browser.version);
          return browser;
        };
        this.getCPU = function() {
          var cpu = { architecture: undefined$1 };
          mapper.rgx.call(cpu, ua, rgxmap.cpu);
          return cpu;
        };
        this.getDevice = function() {
          var device = { vendor: undefined$1, model: undefined$1, type: undefined$1 };
          mapper.rgx.call(device, ua, rgxmap.device);
          return device;
        };
        this.getEngine = function() {
          var engine = { name: undefined$1, version: undefined$1 };
          mapper.rgx.call(engine, ua, rgxmap.engine);
          return engine;
        };
        this.getOS = function() {
          var os = { name: undefined$1, version: undefined$1 };
          mapper.rgx.call(os, ua, rgxmap.os);
          return os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return ua;
        };
        this.setUA = function(uastring) {
          ua = uastring;
          return this;
        };
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = { NAME: NAME, MAJOR: MAJOR, VERSION: VERSION };
      UAParser.CPU = { ARCHITECTURE: ARCHITECTURE };
      UAParser.DEVICE = {
        MODEL: MODEL,
        VENDOR: VENDOR,
        TYPE: TYPE,
        CONSOLE: CONSOLE,
        MOBILE: MOBILE,
        SMARTTV: SMARTTV,
        TABLET: TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
      };
      UAParser.ENGINE = { NAME: NAME, VERSION: VERSION };
      UAParser.OS = { NAME: NAME, VERSION: VERSION };
      if (module.exports) exports = module.exports = UAParser;
      exports.UAParser = UAParser;
      var $ = window && (window.jQuery || window.Zepto);
      if (typeof $ !== UNDEF_TYPE && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(uastring) {
          parser.setUA(uastring);
          var result = parser.getResult();
          for (var prop in result) $.ua[prop] = result[prop];
        };
      }
    })("object" === typeof window ? window : commonjsGlobal$1);
  });
  var uaParser_1 = uaParser.UAParser;
  (function(BrowserCompatibility) {
    (function(Feature) {
      Feature["BLOB"] = "blob";
      Feature["MEDIA_DEVICES"] = "mediaDevices";
      Feature["OFFSCREEN_CANVAS"] = "offscreenCanvas";
      Feature["URL_OBJECT"] = "urlObject";
      Feature["WEB_WORKERS"] = "webWorkers";
      Feature["WEB_ASSEMBLY"] = "webAssembly";
      Feature["WEB_ASSEMBLY_ERROR_FREE"] = "webAssemblyErrorFree";
      Feature["WEBGL"] = "webgl";
    })(BrowserCompatibility.Feature || (BrowserCompatibility.Feature = {}));
  })(exports.BrowserCompatibility || (exports.BrowserCompatibility = {}));
  (function(BrowserHelper) {
    BrowserHelper.userAgentInfo = new uaParser_1(navigator.userAgent);
    function checkBrowserCompatibility() {
      var fullSupport = true;
      var scannerSupport = true;
      var missingFeatures = [];
      if (null == navigator.mediaDevices || "function" !== typeof navigator.mediaDevices.getUserMedia) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.MEDIA_DEVICES);
        fullSupport = false;
      }
      if (!window.hasOwnProperty("Worker") || "function" !== typeof window.Worker) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.WEB_WORKERS);
        fullSupport = scannerSupport = false;
      }
      if (!window.hasOwnProperty("WebAssembly") || "object" !== _typeof_1(window.WebAssembly)) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.WEB_ASSEMBLY);
        fullSupport = scannerSupport = false;
      }
      if (!window.hasOwnProperty("Blob") || "function" !== typeof window.Blob) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.BLOB);
        fullSupport = scannerSupport = false;
      }
      if (
        !window.hasOwnProperty("URL") ||
        ("function" !== typeof window.URL && "object" !== _typeof_1(window.URL)) ||
        "function" !== typeof window.URL.createObjectURL
      ) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.URL_OBJECT);
        fullSupport = scannerSupport = false;
      }
      if (!window.hasOwnProperty("OffscreenCanvas") || "function" !== typeof window.OffscreenCanvas)
        missingFeatures.push(exports.BrowserCompatibility.Feature.OFFSCREEN_CANVAS);
      try {
        var canvas = document.createElement("canvas");
        if (
          !window.hasOwnProperty("WebGLRenderingContext") ||
          (null == canvas.getContext("webgl") && null == canvas.getContext("experimental-webgl"))
        )
          throw new Error();
      } catch (e) {
        missingFeatures.push(exports.BrowserCompatibility.Feature.WEBGL);
      }
      var os = BrowserHelper.userAgentInfo.getOS();
      if ("iOS" === os.name && null != os.version)
        if (-1 !== ["11.2.2", "11.2.5", "11.2.6"].indexOf(os.version)) {
          missingFeatures.push(exports.BrowserCompatibility.Feature.WEB_ASSEMBLY_ERROR_FREE);
          fullSupport = scannerSupport = false;
        }
      return { fullSupport: fullSupport, scannerSupport: scannerSupport, missingFeatures: missingFeatures };
    }
    BrowserHelper.checkBrowserCompatibility = checkBrowserCompatibility;
    function getCookieValue(key) {
      var cookieMatch = document.cookie.match("(^|;)\\s*".concat(key, "\\s*=\\s*([^;]+)"));
      if (null == cookieMatch) return "";
      else {
        var cookieValue = cookieMatch.pop();
        return null == cookieValue ? "" : cookieValue;
      }
    }
    function setCookieValue(key, value, expirationDays) {
      var date = new Date();
      date.setTime(date.getTime() + 24 * expirationDays * 60 * 60 * 1e3);
      document.cookie = ""
        .concat(key, "=")
        .concat(value, ";expires=")
        .concat(date.toUTCString());
    }
    function getDeviceId() {
      var cookieKey = "scandit-device-id";
      var storedDeviceId = getCookieValue(cookieKey);
      if ("" !== storedDeviceId) return storedDeviceId;
      var hexCharacters = "0123456789abcdef";
      var randomDeviceId = "";
      for (var i = 0; i < 40; ++i) randomDeviceId += hexCharacters.charAt(Math.floor(16 * Math.random()));
      setCookieValue(cookieKey, randomDeviceId, 3650);
      return randomDeviceId;
    }
    BrowserHelper.getDeviceId = getDeviceId;
  })(exports.BrowserHelper || (exports.BrowserHelper = {}));
  var check = function(O, proto) {
    _anObject$1(O);
    if (!_isObject$1(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!");
  };
  var _setProto = {
    set:
      Object.setPrototypeOf ||
      ("__proto__" in {}
        ? (function(test, buggy, set) {
            try {
              set = _ctx(Function.call, _objectGopd.f(Object.prototype, "__proto__").set, 2);
              set(test, []);
              buggy = !(test instanceof Array);
            } catch (e) {
              buggy = true;
            }
            return function setPrototypeOf(O, proto) {
              check(O, proto);
              if (buggy) O.__proto__ = proto;
              else set(O, proto);
              return O;
            };
          })({}, false)
        : void 0),
    check: check
  };
  _export(_export.S, "Object", { setPrototypeOf: _setProto.set });
  var setPrototypeOf = _core$1.Object.setPrototypeOf;
  var setPrototypeOf$1 = setPrototypeOf;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
  }
  var classCallCheck = _classCallCheck;
  function _assertThisInitialized(self) {
    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
  }
  var assertThisInitialized = _assertThisInitialized;
  function _possibleConstructorReturn(self, call) {
    if (call && ("object" === _typeof_1(call) || "function" === typeof call)) return call;
    return assertThisInitialized(self);
  }
  var possibleConstructorReturn = _possibleConstructorReturn;
  var _objectSap = function(KEY, exec) {
    var fn = (_core$1.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(
      _export.S +
        _export.F *
          _fails$1(function() {
            fn(1);
          }),
      "Object",
      exp
    );
  };
  _objectSap("getPrototypeOf", function() {
    return function getPrototypeOf(it) {
      return _objectGpo(_toObject(it));
    };
  });
  var getPrototypeOf = _core$1.Object.getPrototypeOf;
  var getPrototypeOf$1 = getPrototypeOf;
  var getPrototypeOf$2 = createCommonjsModule(function(module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = setPrototypeOf$1
        ? getPrototypeOf$1
        : function _getPrototypeOf(o) {
            return o.__proto__ || getPrototypeOf$1(o);
          };
      return _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf;
  });
  _export(_export.S, "Object", { create: _objectCreate });
  var $Object = _core$1.Object;
  var create = function create(P, D) {
    return $Object.create(P, D);
  };
  var create$1 = create;
  var setPrototypeOf$2 = createCommonjsModule(function(module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf =
        setPrototypeOf$1 ||
        function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf;
  });
  function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass)
      throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = create$1(superClass && superClass.prototype, {
      constructor: { value: subClass, writable: true, configurable: true }
    });
    if (superClass) setPrototypeOf$2(subClass, superClass);
  }
  var inherits = _inherits;
  var _validateCollection = function(it, TYPE) {
    if (!_isObject$1(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
    return it;
  };
  var dP$4 = _objectDp$1.f;
  var fastKey = _meta.fastKey;
  var SIZE = _descriptors$1 ? "_s" : "size";
  var getEntry = function(that, key) {
    var index = fastKey(key);
    var entry;
    if ("F" !== index) return that._i[index];
    for (entry = that._f; entry; entry = entry.n) if (entry.k == key) return entry;
  };
  var _collectionStrong = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        _anInstance(that, C, NAME, "_i");
        that._t = NAME;
        that._i = _objectCreate(null);
        that._f = void 0;
        that._l = void 0;
        that[SIZE] = 0;
        if (void 0 != iterable) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = void 0;
            delete data[entry.i];
          }
          that._f = that._l = void 0;
          that[SIZE] = 0;
        },
        delete: function(key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
          var entry;
          while ((entry = entry ? entry.n : this._f)) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors$1)
        dP$4(C.prototype, "size", {
          get: function() {
            return _validateCollection(this, NAME)[SIZE];
          }
        });
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      if (entry) entry.v = value;
      else {
        that._l = entry = {
          i: (index = fastKey(key, true)),
          k: key,
          v: value,
          p: (prev = that._l),
          n: void 0,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if ("F" !== index) that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      _iterDefine(
        C,
        NAME,
        function(iterated, kind) {
          this._t = _validateCollection(iterated, NAME);
          this._k = kind;
          this._l = void 0;
        },
        function() {
          var that = this;
          var kind = that._k;
          var entry = that._l;
          while (entry && entry.r) entry = entry.p;
          if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
            that._t = void 0;
            return _iterStep(1);
          }
          if ("keys" == kind) return _iterStep(0, entry.k);
          if ("values" == kind) return _iterStep(0, entry.v);
          return _iterStep(0, [entry.k, entry.v]);
        },
        IS_MAP ? "entries" : "values",
        !IS_MAP,
        true
      );
      _setSpecies(NAME);
    }
  };
  var SPECIES$2 = _wks$1("species");
  var _arraySpeciesConstructor = function(original) {
    var C;
    if (_isArray(original)) {
      C = original.constructor;
      if ("function" == typeof C && (C === Array || _isArray(C.prototype))) C = void 0;
      if (_isObject$1(C)) {
        C = C[SPECIES$2];
        if (null === C) C = void 0;
      }
    }
    return void 0 === C ? Array : C;
  };
  var _arraySpeciesCreate = function(original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };
  var _arrayMethods = function(TYPE, $create) {
    var IS_MAP = 1 == TYPE;
    var IS_FILTER = 2 == TYPE;
    var IS_SOME = 3 == TYPE;
    var IS_EVERY = 4 == TYPE;
    var IS_FIND_INDEX = 6 == TYPE;
    var NO_HOLES = 5 == TYPE || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
      var val, res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE)
            if (IS_MAP) result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY) return false;
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  var dP$5 = _objectDp$1.f;
  var each = _arrayMethods(0);
  var _collection = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global$1[NAME];
    var C = Base;
    var ADDER = IS_MAP ? "set" : "add";
    var proto = C && C.prototype;
    var O = {};
    if (
      !_descriptors$1 ||
      "function" != typeof C ||
      !(
        IS_WEAK ||
        (proto.forEach &&
          !_fails$1(function() {
            new C().entries().next();
          }))
      )
    ) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      C = wrapper(function(target, iterable) {
        _anInstance(target, C, NAME, "_c");
        target._c = new Base();
        if (void 0 != iterable) _forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
        var IS_ADDER = "add" == KEY || "set" == KEY;
        if (KEY in proto && !(IS_WEAK && "clear" == KEY))
          _hide$1(C.prototype, KEY, function(a, b) {
            _anInstance(this, C, KEY);
            if (!IS_ADDER && IS_WEAK && !_isObject$1(a)) return "get" == KEY ? void 0 : false;
            var result = this._c[KEY](0 === a ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      IS_WEAK ||
        dP$5(C.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        });
    }
    _setToStringTag(C, NAME);
    O[NAME] = C;
    _export(_export.G + _export.W + _export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  var MAP = "Map";
  _collection(
    MAP,
    function(get) {
      return function Map() {
        return get(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    },
    {
      get: function get(key) {
        var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
        return entry && entry.v;
      },
      set: function set(key, value) {
        return _collectionStrong.def(_validateCollection(this, MAP), 0 === key ? 0 : key, value);
      }
    },
    _collectionStrong,
    true
  );
  var _arrayFromIterable = function(iter, ITERATOR) {
    var result = [];
    _forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };
  var _collectionToJson = function(NAME) {
    return function toJSON() {
      if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return _arrayFromIterable(this);
    };
  };
  _export(_export.P + _export.R, "Map", { toJSON: _collectionToJson("Map") });
  var _setCollectionOf = function(COLLECTION) {
    _export(_export.S, COLLECTION, {
      of: function of() {
        var length = arguments.length;
        var A = new Array(length);
        while (length--) A[length] = arguments[length];
        return new this(A);
      }
    });
  };
  _setCollectionOf("Map");
  var _setCollectionFrom = function(COLLECTION) {
    _export(_export.S, COLLECTION, {
      from: function from(source) {
        var mapFn = arguments[1];
        var mapping, A, n, cb;
        _aFunction(this);
        mapping = void 0 !== mapFn;
        if (mapping) _aFunction(mapFn);
        if (void 0 == source) return new this();
        A = [];
        if (mapping) {
          n = 0;
          cb = _ctx(mapFn, arguments[2], 2);
          _forOf(source, false, function(nextItem) {
            A.push(cb(nextItem, n++));
          });
        } else _forOf(source, false, A.push, A);
        return new this(A);
      }
    });
  };
  _setCollectionFrom("Map");
  var map = _core$1.Map;
  var map$1 = map;
  function _isNativeFunction(fn) {
    return -1 !== Function.toString.call(fn).indexOf("[native code]");
  }
  var isNativeFunction = _isNativeFunction;
  var arraySlice = [].slice;
  var factories = {};
  var construct = function(F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
      factories[len] = Function("F,a", "return new F(" + n.join(",") + ")");
    }
    return factories[len](F, args);
  };
  var _bind =
    Function.bind ||
    function bind(that) {
      var fn = _aFunction(this);
      var partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
      };
      if (_isObject$1(fn.prototype)) bound.prototype = fn.prototype;
      return bound;
    };
  var rConstruct = (_global$1.Reflect || {}).construct;
  var NEW_TARGET_BUG = _fails$1(function() {
    function F() {}
    return !(rConstruct(function() {}, [], F) instanceof F);
  });
  var ARGS_BUG = !_fails$1(function() {
    rConstruct(function() {});
  });
  _export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), "Reflect", {
    construct: function construct(Target, args) {
      _aFunction(Target);
      _anObject$1(args);
      var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
      if (Target == newTarget) {
        switch (args.length) {
          case 0:
            return new Target();
          case 1:
            return new Target(args[0]);
          case 2:
            return new Target(args[0], args[1]);
          case 3:
            return new Target(args[0], args[1], args[2]);
          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        }
        var $args = [null];
        $args.push.apply($args, args);
        return new (_bind.apply(Target, $args))();
      }
      var proto = newTarget.prototype;
      var instance = _objectCreate(_isObject$1(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return _isObject$1(result) ? result : instance;
    }
  });
  var construct$1 = _core$1.Reflect.construct;
  var construct$2 = construct$1;
  var construct$3 = createCommonjsModule(function(module) {
    function isNativeReflectConstruct() {
      if ("undefined" === typeof Reflect || !construct$2) return false;
      if (construct$2.sham) return false;
      if ("function" === typeof Proxy) return true;
      try {
        Date.prototype.toString.call(construct$2(Date, [], function() {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) module.exports = _construct = construct$2;
      else
        module.exports = _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) setPrototypeOf$2(instance, Class.prototype);
          return instance;
        };
      return _construct.apply(null, arguments);
    }
    module.exports = _construct;
  });
  var wrapNativeSuper = createCommonjsModule(function(module) {
    function _wrapNativeSuper(Class) {
      var _cache = "function" === typeof map$1 ? new map$1() : void 0;
      module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (null === Class || !isNativeFunction(Class)) return Class;
        if ("function" !== typeof Class) throw new TypeError("Super expression must either be null or a function");
        if ("undefined" !== typeof _cache) {
          if (_cache.has(Class)) return _cache.get(Class);
          _cache.set(Class, Wrapper);
        }
        function Wrapper() {
          return construct$3(Class, arguments, getPrototypeOf$2(this).constructor);
        }
        Wrapper.prototype = create$1(Class.prototype, {
          constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true }
        });
        return setPrototypeOf$2(Wrapper, Class);
      };
      return _wrapNativeSuper(Class);
    }
    module.exports = _wrapNativeSuper;
  });
  var CustomError = (function(_Error) {
    inherits(CustomError, _Error);
    function CustomError() {
      var _this;
      var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        _ref$name = _ref.name,
        name = void 0 === _ref$name ? "" : _ref$name,
        _ref$message = _ref.message,
        message = void 0 === _ref$message ? "" : _ref$message,
        data = _ref.data;
      classCallCheck(this, CustomError);
      _this = possibleConstructorReturn(this, getPrototypeOf$2(CustomError).call(this, message));
      setPrototypeOf$1(assertThisInitialized(assertThisInitialized(_this)), CustomError.prototype);
      _this.name = name;
      _this.data = data;
      return _this;
    }
    return CustomError;
  })(wrapNativeSuper(Error));
  ___$insertStyle(
    '.scandit.scandit-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;overflow:hidden}.scandit.scandit-barcode-picker{position:relative;width:100%;height:100%;background-color:#000}.scandit .scandit-video{width:100%;height:100%;position:relative;display:block}.scandit .scandit-video.mirrored{-webkit-transform:scaleX(-1);transform:scaleX(-1)}.scandit .scandit-logo{position:absolute;bottom:5%;right:5%;max-width:35%;max-height:12.5%;pointer-events:none;-webkit-transform:translateZ(0);transform:translateZ(0)}.scandit .scandit-laser{max-width:75%;max-height:10%}.scandit .scandit-laser,.scandit .scandit-viewfinder{z-index:10;position:absolute;margin:auto;left:0;right:0;top:0;bottom:0;-webkit-animation-duration:.25s;animation-duration:.25s;transition:opacity .25s ease;pointer-events:none;-webkit-transform:translateZ(0);transform:translateZ(0)}.scandit .scandit-viewfinder{box-sizing:border-box;width:90%;height:60%;border:2px solid #fff;border-radius:10px}.scandit .scandit-viewfinder.paused{opacity:.4}.scandit .scandit-camera-switcher,.scandit .scandit-torch-toggle{-webkit-tap-highlight-color:rgba(255,255,255,0);position:absolute;top:5%;max-width:15%;max-height:15%;z-index:10;cursor:pointer;-webkit-filter:drop-shadow(0 2px 0 grey);filter:drop-shadow(0 2px 0 #808080);-webkit-transform:translateZ(0);transform:translateZ(0)}.scandit .scandit-camera-switcher{left:5%}.scandit .scandit-torch-toggle{right:5%}.scandit .scandit-camera-upload{-webkit-tap-highlight-color:rgba(255,255,255,0);display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%;z-index:5}.scandit .scandit-camera-upload label{cursor:pointer;text-align:center;width:224px;height:224px;min-width:224px;min-height:224px;z-index:10;margin:4px;padding:20px;box-sizing:border-box;border-radius:50%;-webkit-filter:drop-shadow(0 0 .15rem #000);filter:drop-shadow(0 0 .15rem #000)}.scandit .scandit-camera-upload label input[type=file]{position:absolute;top:-9999px}.scandit .scandit-camera-upload label img{width:60%;height:60%}.scandit .scandit-camera-upload label div{font-family:sans-serif;color:#fff;font-size:16pt}.scandit .radial-progress{width:224px;height:224px;background-color:transparent;border:4px solid #fff;border-radius:50%;position:absolute;transition:opacity 1s ease,border-color .5s;-webkit-animation-duration:.25s;animation-duration:.25s;z-index:7;box-shadow:0 0 .3rem #000,inset 0 0 .3rem #000}.scandit .radial-progress[data-progress="0"]{border-color:hsla(0,0%,100%,.2)}.scandit .radial-progress[data-progress="5"]{border-color:hsla(0,0%,100%,.24)}.scandit .radial-progress[data-progress="10"]{border-color:hsla(0,0%,100%,.28)}.scandit .radial-progress[data-progress="15"]{border-color:hsla(0,0%,100%,.32)}.scandit .radial-progress[data-progress="20"]{border-color:hsla(0,0%,100%,.36)}.scandit .radial-progress[data-progress="25"]{border-color:hsla(0,0%,100%,.4)}.scandit .radial-progress[data-progress="30"]{border-color:hsla(0,0%,100%,.44)}.scandit .radial-progress[data-progress="35"]{border-color:hsla(0,0%,100%,.48)}.scandit .radial-progress[data-progress="40"]{border-color:hsla(0,0%,100%,.52)}.scandit .radial-progress[data-progress="45"]{border-color:hsla(0,0%,100%,.56)}.scandit .radial-progress[data-progress="50"]{border-color:hsla(0,0%,100%,.6)}.scandit .radial-progress[data-progress="55"]{border-color:hsla(0,0%,100%,.64)}.scandit .radial-progress[data-progress="60"]{border-color:hsla(0,0%,100%,.68)}.scandit .radial-progress[data-progress="65"]{border-color:hsla(0,0%,100%,.72)}.scandit .radial-progress[data-progress="70"]{border-color:hsla(0,0%,100%,.76)}.scandit .radial-progress[data-progress="75"]{border-color:hsla(0,0%,100%,.8)}.scandit .radial-progress[data-progress="80"]{border-color:hsla(0,0%,100%,.84)}.scandit .radial-progress[data-progress="85"]{border-color:hsla(0,0%,100%,.88)}.scandit .radial-progress[data-progress="90"]{border-color:hsla(0,0%,100%,.92)}.scandit .radial-progress[data-progress="95"]{border-color:hsla(0,0%,100%,.96)}.scandit .radial-progress[data-progress="100"]{border-color:#fff}.scandit .scandit-flash-color{-webkit-animation-name:scandit-flash-color;animation-name:scandit-flash-color}.scandit .scandit-flash-white{-webkit-animation-name:scandit-flash-white;animation-name:scandit-flash-white}.scandit .scandit-flash-white-inset{-webkit-animation-name:scandit-flash-white-inset;animation-name:scandit-flash-white-inset}.scandit .scandit-opacity-pulse{-webkit-animation-duration:.333s,1s;animation-duration:.333s,1s;-webkit-animation-iteration-count:1,infinite;animation-iteration-count:1,infinite;-webkit-animation-delay:0s,.333s;animation-delay:0s,.333s;-webkit-animation-timing-function:cubic-bezier(.645,.045,.355,1),cubic-bezier(.645,.045,.355,1);animation-timing-function:cubic-bezier(.645,.045,.355,1),cubic-bezier(.645,.045,.355,1);-webkit-animation-name:scandit-opacity-pulse-before,scandit-opacity-pulse;animation-name:scandit-opacity-pulse-before,scandit-opacity-pulse}.scandit .scandit-hidden-opacity{opacity:0}.scandit-hidden{display:none!important}@-webkit-keyframes scandit-flash-color{0%{-webkit-filter:none;filter:none}50%{-webkit-filter:drop-shadow(0 0 .75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2);filter:drop-shadow(0 0 .75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2)}to{-webkit-filter:none;filter:none}}@keyframes scandit-flash-color{0%{-webkit-filter:none;filter:none}50%{-webkit-filter:drop-shadow(0 0 .75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2);filter:drop-shadow(0 0 .75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2)}to{-webkit-filter:none;filter:none}}@-webkit-keyframes scandit-flash-white{0%{-webkit-filter:none;filter:none}50%{-webkit-filter:drop-shadow(0 0 .5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff);filter:drop-shadow(0 0 .5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff)}to{-webkit-filter:none;filter:none}}@keyframes scandit-flash-white{0%{-webkit-filter:none;filter:none}50%{-webkit-filter:drop-shadow(0 0 .5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff);filter:drop-shadow(0 0 .5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff)}to{-webkit-filter:none;filter:none}}@-webkit-keyframes scandit-flash-white-inset{0%{box-shadow:none}50%{box-shadow:inset 0 0 .5rem #fff,inset 0 0 1rem #fff,inset 0 0 2.5rem #fff}to{box-shadow:none}}@keyframes scandit-flash-white-inset{0%{box-shadow:none}50%{box-shadow:inset 0 0 .5rem #fff,inset 0 0 1rem #fff,inset 0 0 2.5rem #fff}to{box-shadow:none}}@-webkit-keyframes scandit-opacity-pulse-before{0%{opacity:1}to{opacity:.4}}@keyframes scandit-opacity-pulse-before{0%{opacity:1}to{opacity:.4}}@-webkit-keyframes scandit-opacity-pulse{0%{opacity:.4}50%{opacity:.6}to{opacity:.4}}@keyframes scandit-opacity-pulse{0%{opacity:.4}50%{opacity:.6}to{opacity:.4}}@-webkit-keyframes scandit-opacity-pulse-after{0%{opacity:.5}to{opacity:1}}@keyframes scandit-opacity-pulse-after{0%{opacity:.5}to{opacity:1}}'
  );
  var _library$1 = false;
  var _aFunction$1 = function(it) {
    if ("function" != typeof it) throw TypeError(it + " is not a function!");
    return it;
  };
  var _ctx$1 = function(fn, that, length) {
    _aFunction$1(fn);
    if (void 0 === that) return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var PROTOTYPE$3 = "prototype";
  var $export$1 = function(type, name, source) {
    var IS_FORCED = type & $export$1.F;
    var IS_GLOBAL = type & $export$1.G;
    var IS_STATIC = type & $export$1.S;
    var IS_PROTO = type & $export$1.P;
    var IS_BIND = type & $export$1.B;
    var target = IS_GLOBAL
      ? _global
      : IS_STATIC
      ? _global[name] || (_global[name] = {})
      : (_global[name] || {})[PROTOTYPE$3];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE$3] || (exports[PROTOTYPE$3] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && void 0 !== target[key];
      out = (own ? target : source)[key];
      exp =
        IS_BIND && own ? _ctx$1(out, _global) : IS_PROTO && "function" == typeof out ? _ctx$1(Function.call, out) : out;
      if (target) _redefine(target, key, out, type & $export$1.U);
      if (exports[key] != out) _hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  _global.core = _core;
  $export$1.F = 1;
  $export$1.G = 2;
  $export$1.S = 4;
  $export$1.P = 8;
  $export$1.B = 16;
  $export$1.W = 32;
  $export$1.U = 64;
  $export$1.R = 128;
  var _export$1 = $export$1;
  var TYPED = _uid("typed_array");
  var VIEW = _uid("view");
  var ABV = !!(_global.ArrayBuffer && _global.DataView);
  var CONSTR = ABV;
  var i$1 = 0;
  var l = 9;
  var Typed;
  var TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(
    ","
  );
  while (i$1 < l)
    if ((Typed = _global[TypedArrayConstructors[i$1++]])) {
      _hide(Typed.prototype, TYPED, true);
      _hide(Typed.prototype, VIEW, true);
    } else CONSTR = false;
  var _typed = { ABV: ABV, CONSTR: CONSTR, TYPED: TYPED, VIEW: VIEW };
  var _redefineAll$1 = function(target, src, safe) {
    for (var key in src) _redefine(target, key, src[key], safe);
    return target;
  };
  var _anInstance$1 = function(it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (void 0 !== forbiddenField && forbiddenField in it))
      throw TypeError(name + ": incorrect invocation!");
    return it;
  };
  var ceil$1 = Math.ceil;
  var floor$1 = Math.floor;
  var _toInteger$1 = function(it) {
    return isNaN((it = +it)) ? 0 : (it > 0 ? floor$1 : ceil$1)(it);
  };
  var min$2 = Math.min;
  var _toLength$1 = function(it) {
    return it > 0 ? min$2(_toInteger$1(it), 9007199254740991) : 0;
  };
  var _toIndex = function(it) {
    if (void 0 === it) return 0;
    var number = _toInteger$1(it);
    var length = _toLength$1(number);
    if (number !== length) throw RangeError("Wrong length!");
    return length;
  };
  var _iobject$1 = Object("z").propertyIsEnumerable(0)
    ? Object
    : function(it) {
        return "String" == _cof(it) ? it.split("") : Object(it);
      };
  var _toIobject$1 = function(it) {
    return _iobject$1(_defined(it));
  };
  var max$1 = Math.max;
  var min$3 = Math.min;
  var _toAbsoluteIndex$1 = function(index, length) {
    index = _toInteger$1(index);
    return index < 0 ? max$1(index + length, 0) : min$3(index, length);
  };
  var _arrayIncludes$1 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = _toIobject$1($this);
      var length = _toLength$1(O.length);
      var index = _toAbsoluteIndex$1(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value) return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) if (O[index] === el) return IS_INCLUDES || index || 0;
      return !IS_INCLUDES && -1;
    };
  };
  var shared$1 = _shared("keys");
  var _sharedKey$1 = function(key) {
    return shared$1[key] || (shared$1[key] = _uid(key));
  };
  var arrayIndexOf$1 = _arrayIncludes$1(false);
  var IE_PROTO$3 = _sharedKey$1("IE_PROTO");
  var _objectKeysInternal$1 = function(object, names) {
    var O = _toIobject$1(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO$3) _has(O, key) && result.push(key);
    while (names.length > i) if (_has(O, (key = names[i++]))) ~arrayIndexOf$1(result, key) || result.push(key);
    return result;
  };
  var _enumBugKeys$1 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
    ","
  );
  var hiddenKeys$1 = _enumBugKeys$1.concat("length", "prototype");
  var f$9 =
    Object.getOwnPropertyNames ||
    function getOwnPropertyNames(O) {
      return _objectKeysInternal$1(O, hiddenKeys$1);
    };
  var _objectGopn$1 = { f: f$9 };
  var _toObject$1 = function(it) {
    return Object(_defined(it));
  };
  var _arrayFill = function fill(value) {
    var O = _toObject$1(this);
    var length = _toLength$1(O.length);
    var aLen = arguments.length;
    var index = _toAbsoluteIndex$1(aLen > 1 ? arguments[1] : void 0, length);
    var end = aLen > 2 ? arguments[2] : void 0;
    var endPos = void 0 === end ? length : _toAbsoluteIndex$1(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };
  var def$1 = _objectDp.f;
  var TAG$2 = _wks("toStringTag");
  var _setToStringTag$1 = function(it, tag, stat) {
    if (it && !_has((it = stat ? it : it.prototype), TAG$2)) def$1(it, TAG$2, { configurable: true, value: tag });
  };
  var _typedBuffer = createCommonjsModule(function(module, exports) {
    var gOPN = _objectGopn$1.f;
    var dP = _objectDp.f;
    var ARRAY_BUFFER = "ArrayBuffer";
    var DATA_VIEW = "DataView";
    var PROTOTYPE = "prototype";
    var WRONG_LENGTH = "Wrong length!";
    var WRONG_INDEX = "Wrong index!";
    var $ArrayBuffer = _global[ARRAY_BUFFER];
    var $DataView = _global[DATA_VIEW];
    var Math = _global.Math;
    var RangeError = _global.RangeError;
    var Infinity = _global.Infinity;
    var BaseBuffer = $ArrayBuffer;
    var abs = Math.abs;
    var pow = Math.pow;
    var floor = Math.floor;
    var log = Math.log;
    var LN2 = Math.LN2;
    var BUFFER = "buffer";
    var BYTE_LENGTH = "byteLength";
    var BYTE_OFFSET = "byteOffset";
    var $BUFFER = _descriptors ? "_b" : BUFFER;
    var $LENGTH = _descriptors ? "_l" : BYTE_LENGTH;
    var $OFFSET = _descriptors ? "_o" : BYTE_OFFSET;
    function packIEEE754(value, mLen, nBytes) {
      var buffer = Array(nBytes);
      var eLen = 8 * nBytes - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = 23 === mLen ? pow(2, -24) - pow(2, -77) : 0;
      var i = 0;
      var s = value < 0 || (0 === value && 1 / value < 0) ? 1 : 0;
      var e, m, c;
      value = abs(value);
      if (value != value || value === Infinity) {
        m = value != value ? 1 : 0;
        e = eMax;
      } else {
        e = floor(log(value) / LN2);
        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * pow(2, 1 - eBias);
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e += eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[i++] = 255 & m, m /= 256, mLen -= 8);
      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[i++] = 255 & e, e /= 256, eLen -= 8);
      buffer[--i] |= 128 * s;
      return buffer;
    }
    function unpackIEEE754(buffer, mLen, nBytes) {
      var eLen = 8 * nBytes - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = eLen - 7;
      var i = nBytes - 1;
      var s = buffer[i--];
      var e = 127 & s;
      var m;
      s >>= 7;
      for (; nBits > 0; e = 256 * e + buffer[i], i--, nBits -= 8);
      m = e & ((1 << -nBits) - 1);
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = 256 * m + buffer[i], i--, nBits -= 8);
      if (0 === e) e = 1 - eBias;
      else if (e === eMax) return m ? NaN : s ? -Infinity : Infinity;
      else {
        m += pow(2, mLen);
        e -= eBias;
      }
      return (s ? -1 : 1) * m * pow(2, e - mLen);
    }
    function unpackI32(bytes) {
      return (bytes[3] << 24) | (bytes[2] << 16) | (bytes[1] << 8) | bytes[0];
    }
    function packI8(it) {
      return [255 & it];
    }
    function packI16(it) {
      return [255 & it, (it >> 8) & 255];
    }
    function packI32(it) {
      return [255 & it, (it >> 8) & 255, (it >> 16) & 255, (it >> 24) & 255];
    }
    function packF64(it) {
      return packIEEE754(it, 52, 8);
    }
    function packF32(it) {
      return packIEEE754(it, 23, 4);
    }
    function addGetter(C, key, internal) {
      dP(C[PROTOTYPE], key, {
        get: function() {
          return this[internal];
        }
      });
    }
    function get(view, bytes, index, isLittleEndian) {
      var numIndex = +index;
      var intIndex = _toIndex(numIndex);
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
      var store = view[$BUFFER]._b;
      var start = intIndex + view[$OFFSET];
      var pack = store.slice(start, start + bytes);
      return isLittleEndian ? pack : pack.reverse();
    }
    function set(view, bytes, index, conversion, value, isLittleEndian) {
      var numIndex = +index;
      var intIndex = _toIndex(numIndex);
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
      var store = view[$BUFFER]._b;
      var start = intIndex + view[$OFFSET];
      var pack = conversion(+value);
      for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
    }
    if (!_typed.ABV) {
      $ArrayBuffer = function ArrayBuffer(length) {
        _anInstance$1(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = _toIndex(length);
        this._b = _arrayFill.call(Array(byteLength), 0);
        this[$LENGTH] = byteLength;
      };
      $DataView = function DataView(buffer, byteOffset, byteLength) {
        _anInstance$1(this, $DataView, DATA_VIEW);
        _anInstance$1(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = buffer[$LENGTH];
        var offset = _toInteger$1(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError("Wrong offset!");
        byteLength = void 0 === byteLength ? bufferLength - offset : _toLength$1(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
        this[$BUFFER] = buffer;
        this[$OFFSET] = offset;
        this[$LENGTH] = byteLength;
      };
      if (_descriptors) {
        addGetter($ArrayBuffer, BYTE_LENGTH, "_l");
        addGetter($DataView, BUFFER, "_b");
        addGetter($DataView, BYTE_LENGTH, "_l");
        addGetter($DataView, BYTE_OFFSET, "_o");
      }
      _redefineAll$1($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
          return (get(this, 1, byteOffset)[0] << 24) >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments[1]);
          return (((bytes[1] << 8) | bytes[0]) << 16) >> 16;
        },
        getUint16: function getUint16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments[1]);
          return (bytes[1] << 8) | bytes[0];
        },
        getInt32: function getInt32(byteOffset) {
          return unpackI32(get(this, 4, byteOffset, arguments[1]));
        },
        getUint32: function getUint32(byteOffset) {
          return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
        },
        getFloat64: function getFloat64(byteOffset) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
        },
        setInt8: function setInt8(byteOffset, value) {
          set(this, 1, byteOffset, packI8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set(this, 1, byteOffset, packI8, value);
        },
        setInt16: function setInt16(byteOffset, value) {
          set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setUint16: function setUint16(byteOffset, value) {
          set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setInt32: function setInt32(byteOffset, value) {
          set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setUint32: function setUint32(byteOffset, value) {
          set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setFloat32: function setFloat32(byteOffset, value) {
          set(this, 4, byteOffset, packF32, value, arguments[2]);
        },
        setFloat64: function setFloat64(byteOffset, value) {
          set(this, 8, byteOffset, packF64, value, arguments[2]);
        }
      });
    } else {
      if (
        !_fails(function() {
          $ArrayBuffer(1);
        }) ||
        !_fails(function() {
          new $ArrayBuffer(-1);
        }) ||
        _fails(function() {
          new $ArrayBuffer();
          new $ArrayBuffer(1.5);
          new $ArrayBuffer(NaN);
          return $ArrayBuffer.name != ARRAY_BUFFER;
        })
      ) {
        $ArrayBuffer = function ArrayBuffer(length) {
          _anInstance$1(this, $ArrayBuffer);
          return new BaseBuffer(_toIndex(length));
        };
        var ArrayBufferProto = ($ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]);
        for (var key, keys = gOPN(BaseBuffer), j = 0; keys.length > j; )
          if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
        ArrayBufferProto.constructor = $ArrayBuffer;
      }
      var view = new $DataView(new $ArrayBuffer(2));
      var $setInt8 = $DataView[PROTOTYPE].setInt8;
      view.setInt8(0, 2147483648);
      view.setInt8(1, 2147483649);
      if (view.getInt8(0) || !view.getInt8(1))
        _redefineAll$1(
          $DataView[PROTOTYPE],
          {
            setInt8: function setInt8(byteOffset, value) {
              $setInt8.call(this, byteOffset, (value << 24) >> 24);
            },
            setUint8: function setUint8(byteOffset, value) {
              $setInt8.call(this, byteOffset, (value << 24) >> 24);
            }
          },
          true
        );
    }
    _setToStringTag$1($ArrayBuffer, ARRAY_BUFFER);
    _setToStringTag$1($DataView, DATA_VIEW);
    _hide($DataView[PROTOTYPE], _typed.VIEW, true);
    exports[ARRAY_BUFFER] = $ArrayBuffer;
    exports[DATA_VIEW] = $DataView;
  });
  var TAG$3 = _wks("toStringTag");
  var ARG$1 =
    "Arguments" ==
    _cof(
      (function() {
        return arguments;
      })()
    );
  var tryGet$1 = function(it, key) {
    try {
      return it[key];
    } catch (e) {}
  };
  var _classof$1 = function(it) {
    var O, T, B;
    return void 0 === it
      ? "Undefined"
      : null === it
      ? "Null"
      : "string" == typeof (T = tryGet$1((O = Object(it)), TAG$3))
      ? T
      : ARG$1
      ? _cof(O)
      : "Object" == (B = _cof(O)) && "function" == typeof O.callee
      ? "Arguments"
      : B;
  };
  var _iterators$1 = {};
  var ITERATOR$4 = _wks("iterator");
  var ArrayProto$1 = Array.prototype;
  var _isArrayIter$1 = function(it) {
    return void 0 !== it && (_iterators$1.Array === it || ArrayProto$1[ITERATOR$4] === it);
  };
  var _objectKeys$1 =
    Object.keys ||
    function keys(O) {
      return _objectKeysInternal$1(O, _enumBugKeys$1);
    };
  var _objectDps$1 = _descriptors
    ? Object.defineProperties
    : function defineProperties(O, Properties) {
        _anObject(O);
        var keys = _objectKeys$1(Properties);
        var length = keys.length;
        var i = 0;
        var P;
        while (length > i) _objectDp.f(O, (P = keys[i++]), Properties[P]);
        return O;
      };
  var document$4 = _global.document;
  var _html$1 = document$4 && document$4.documentElement;
  var IE_PROTO$4 = _sharedKey$1("IE_PROTO");
  var Empty$1 = function() {};
  var PROTOTYPE$4 = "prototype";
  var createDict$1 = function() {
    var iframe = _domCreate("iframe");
    var i = _enumBugKeys$1.length;
    var lt = "<";
    var gt = ">";
    var iframeDocument;
    iframe.style.display = "none";
    _html$1.appendChild(iframe);
    iframe.src = "javascript:";
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
    iframeDocument.close();
    createDict$1 = iframeDocument.F;
    while (i--) delete createDict$1[PROTOTYPE$4][_enumBugKeys$1[i]];
    return createDict$1();
  };
  var _objectCreate$1 =
    Object.create ||
    function create(O, Properties) {
      var result;
      if (null !== O) {
        Empty$1[PROTOTYPE$4] = _anObject(O);
        result = new Empty$1();
        Empty$1[PROTOTYPE$4] = null;
        result[IE_PROTO$4] = O;
      } else result = createDict$1();
      return void 0 === Properties ? result : _objectDps$1(result, Properties);
    };
  var IE_PROTO$5 = _sharedKey$1("IE_PROTO");
  var ObjectProto$2 = Object.prototype;
  var _objectGpo$1 =
    Object.getPrototypeOf ||
    function(O) {
      O = _toObject$1(O);
      if (_has(O, IE_PROTO$5)) return O[IE_PROTO$5];
      if ("function" == typeof O.constructor && O instanceof O.constructor) return O.constructor.prototype;
      return O instanceof Object ? ObjectProto$2 : null;
    };
  var ITERATOR$5 = _wks("iterator");
  var core_getIteratorMethod$1 = (_core.getIteratorMethod = function(it) {
    if (void 0 != it) return it[ITERATOR$5] || it["@@iterator"] || _iterators$1[_classof$1(it)];
  });
  var _isArray$1 =
    Array.isArray ||
    function isArray(arg) {
      return "Array" == _cof(arg);
    };
  var SPECIES$3 = _wks("species");
  var _arraySpeciesConstructor$1 = function(original) {
    var C;
    if (_isArray$1(original)) {
      C = original.constructor;
      if ("function" == typeof C && (C === Array || _isArray$1(C.prototype))) C = void 0;
      if (_isObject(C)) {
        C = C[SPECIES$3];
        if (null === C) C = void 0;
      }
    }
    return void 0 === C ? Array : C;
  };
  var _arraySpeciesCreate$1 = function(original, length) {
    return new (_arraySpeciesConstructor$1(original))(length);
  };
  var _arrayMethods$1 = function(TYPE, $create) {
    var IS_MAP = 1 == TYPE;
    var IS_FILTER = 2 == TYPE;
    var IS_SOME = 3 == TYPE;
    var IS_EVERY = 4 == TYPE;
    var IS_FIND_INDEX = 6 == TYPE;
    var NO_HOLES = 5 == TYPE || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate$1;
    return function($this, callbackfn, that) {
      var O = _toObject$1($this);
      var self = _iobject$1(O);
      var f = _ctx$1(callbackfn, that, 3);
      var length = _toLength$1(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
      var val, res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE)
            if (IS_MAP) result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY) return false;
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  var SPECIES$4 = _wks("species");
  var _speciesConstructor$1 = function(O, D) {
    var C = _anObject(O).constructor;
    var S;
    return void 0 === C || void 0 == (S = _anObject(C)[SPECIES$4]) ? D : _aFunction$1(S);
  };
  var UNSCOPABLES = _wks("unscopables");
  var ArrayProto$2 = Array.prototype;
  if (void 0 == ArrayProto$2[UNSCOPABLES]) _hide(ArrayProto$2, UNSCOPABLES, {});
  var _addToUnscopables$1 = function(key) {
    ArrayProto$2[UNSCOPABLES][key] = true;
  };
  var _iterStep$1 = function(done, value) {
    return { value: value, done: !!done };
  };
  var IteratorPrototype$1 = {};
  _hide(IteratorPrototype$1, _wks("iterator"), function() {
    return this;
  });
  var _iterCreate$1 = function(Constructor, NAME, next) {
    Constructor.prototype = _objectCreate$1(IteratorPrototype$1, { next: _propertyDesc(1, next) });
    _setToStringTag$1(Constructor, NAME + " Iterator");
  };
  var ITERATOR$6 = _wks("iterator");
  var BUGGY$1 = !([].keys && "next" in [].keys());
  var FF_ITERATOR$1 = "@@iterator";
  var KEYS$1 = "keys";
  var VALUES$1 = "values";
  var returnThis$1 = function() {
    return this;
  };
  var _iterDefine$1 = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate$1(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY$1 && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS$1:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES$1:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + " Iterator";
    var DEF_VALUES = DEFAULT == VALUES$1;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR$6] || proto[FF_ITERATOR$1] || (DEFAULT && proto[DEFAULT]);
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? (!DEF_VALUES ? $default : getMethod("entries")) : void 0;
    var $anyNative = "Array" == NAME ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = _objectGpo$1($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        _setToStringTag$1(IteratorPrototype, TAG, true);
        if (!_library$1 && !_has(IteratorPrototype, ITERATOR$6)) _hide(IteratorPrototype, ITERATOR$6, returnThis$1);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES$1) {
      VALUES_BUG = true;
      $default = function values() {
        return $native.call(this);
      };
    }
    if ((!_library$1 || FORCED) && (BUGGY$1 || VALUES_BUG || !proto[ITERATOR$6])) _hide(proto, ITERATOR$6, $default);
    _iterators$1[NAME] = $default;
    _iterators$1[TAG] = returnThis$1;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES$1),
        keys: IS_SET ? $default : getMethod(KEYS$1),
        entries: $entries
      };
      if (FORCED) {
        for (key in methods) if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export$1(_export$1.P + _export$1.F * (BUGGY$1 || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  var es6_array_iterator$1 = _iterDefine$1(
    Array,
    "Array",
    function(iterated, kind) {
      this._t = _toIobject$1(iterated);
      this._i = 0;
      this._k = kind;
    },
    function() {
      var O = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O || index >= O.length) {
        this._t = void 0;
        return _iterStep$1(1);
      }
      if ("keys" == kind) return _iterStep$1(0, index);
      if ("values" == kind) return _iterStep$1(0, O[index]);
      return _iterStep$1(0, [index, O[index]]);
    },
    "values"
  );
  _iterators$1.Arguments = _iterators$1.Array;
  _addToUnscopables$1("keys");
  _addToUnscopables$1("values");
  _addToUnscopables$1("entries");
  var ITERATOR$7 = _wks("iterator");
  var SAFE_CLOSING$1 = false;
  try {
    var riter$1 = [7][ITERATOR$7]();
    riter$1["return"] = function() {
      SAFE_CLOSING$1 = true;
    };
  } catch (e) {}
  var _iterDetect$1 = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING$1) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$7]();
      iter.next = function() {
        return { done: (safe = true) };
      };
      arr[ITERATOR$7] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  var SPECIES$5 = _wks("species");
  var _setSpecies$1 = function(KEY) {
    var C = _global[KEY];
    if (_descriptors && C && !C[SPECIES$5])
      _objectDp.f(C, SPECIES$5, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  var _arrayCopyWithin =
    [].copyWithin ||
    function copyWithin(target, start) {
      var O = _toObject$1(this);
      var len = _toLength$1(O.length);
      var to = _toAbsoluteIndex$1(target, len);
      var from = _toAbsoluteIndex$1(start, len);
      var end = arguments.length > 2 ? arguments[2] : void 0;
      var count = Math.min((void 0 === end ? len : _toAbsoluteIndex$1(end, len)) - from, len - to);
      var inc = 1;
      if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count-- > 0) {
        if (from in O) O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      }
      return O;
    };
  var f$a = {}.propertyIsEnumerable;
  var _objectPie$1 = { f: f$a };
  var gOPD$2 = Object.getOwnPropertyDescriptor;
  var f$b = _descriptors
    ? gOPD$2
    : function getOwnPropertyDescriptor(O, P) {
        O = _toIobject$1(O);
        P = _toPrimitive(P, true);
        if (_ie8DomDefine)
          try {
            return gOPD$2(O, P);
          } catch (e) {}
        if (_has(O, P)) return _propertyDesc(!_objectPie$1.f.call(O, P), O[P]);
      };
  var _objectGopd$1 = { f: f$b };
  var _typedArray = createCommonjsModule(function(module) {
    if (_descriptors) {
      var LIBRARY = _library$1;
      var global = _global;
      var fails = _fails;
      var $export = _export$1;
      var $typed = _typed;
      var $buffer = _typedBuffer;
      var ctx = _ctx$1;
      var anInstance = _anInstance$1;
      var propertyDesc = _propertyDesc;
      var hide = _hide;
      var redefineAll = _redefineAll$1;
      var toInteger = _toInteger$1;
      var toLength = _toLength$1;
      var toIndex = _toIndex;
      var toAbsoluteIndex = _toAbsoluteIndex$1;
      var toPrimitive = _toPrimitive;
      var has = _has;
      var classof = _classof$1;
      var isObject = _isObject;
      var toObject = _toObject$1;
      var isArrayIter = _isArrayIter$1;
      var create = _objectCreate$1;
      var getPrototypeOf = _objectGpo$1;
      var gOPN = _objectGopn$1.f;
      var getIterFn = core_getIteratorMethod$1;
      var uid = _uid;
      var wks = _wks;
      var createArrayMethod = _arrayMethods$1;
      var createArrayIncludes = _arrayIncludes$1;
      var speciesConstructor = _speciesConstructor$1;
      var ArrayIterators = es6_array_iterator$1;
      var Iterators = _iterators$1;
      var $iterDetect = _iterDetect$1;
      var setSpecies = _setSpecies$1;
      var arrayFill = _arrayFill;
      var arrayCopyWithin = _arrayCopyWithin;
      var $DP = _objectDp;
      var $GOPD = _objectGopd$1;
      var dP = $DP.f;
      var gOPD = $GOPD.f;
      var RangeError = global.RangeError;
      var TypeError = global.TypeError;
      var Uint8Array = global.Uint8Array;
      var ARRAY_BUFFER = "ArrayBuffer";
      var SHARED_BUFFER = "Shared" + ARRAY_BUFFER;
      var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      var PROTOTYPE = "prototype";
      var ArrayProto = Array[PROTOTYPE];
      var $ArrayBuffer = $buffer.ArrayBuffer;
      var $DataView = $buffer.DataView;
      var arrayForEach = createArrayMethod(0);
      var arrayFilter = createArrayMethod(2);
      var arraySome = createArrayMethod(3);
      var arrayEvery = createArrayMethod(4);
      var arrayFind = createArrayMethod(5);
      var arrayFindIndex = createArrayMethod(6);
      var arrayIncludes = createArrayIncludes(true);
      var arrayIndexOf = createArrayIncludes(false);
      var arrayValues = ArrayIterators.values;
      var arrayKeys = ArrayIterators.keys;
      var arrayEntries = ArrayIterators.entries;
      var arrayLastIndexOf = ArrayProto.lastIndexOf;
      var arrayReduce = ArrayProto.reduce;
      var arrayReduceRight = ArrayProto.reduceRight;
      var arrayJoin = ArrayProto.join;
      var arraySort = ArrayProto.sort;
      var arraySlice = ArrayProto.slice;
      var arrayToString = ArrayProto.toString;
      var arrayToLocaleString = ArrayProto.toLocaleString;
      var ITERATOR = wks("iterator");
      var TAG = wks("toStringTag");
      var TYPED_CONSTRUCTOR = uid("typed_constructor");
      var DEF_CONSTRUCTOR = uid("def_constructor");
      var ALL_CONSTRUCTORS = $typed.CONSTR;
      var TYPED_ARRAY = $typed.TYPED;
      var VIEW = $typed.VIEW;
      var WRONG_LENGTH = "Wrong length!";
      var $map = createArrayMethod(1, function(O, length) {
        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
      });
      var LITTLE_ENDIAN = fails(function() {
        return 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
      });
      var FORCED_SET =
        !!Uint8Array &&
        !!Uint8Array[PROTOTYPE].set &&
        fails(function() {
          new Uint8Array(1).set({});
        });
      var toOffset = function(it, BYTES) {
        var offset = toInteger(it);
        if (offset < 0 || offset % BYTES) throw RangeError("Wrong offset!");
        return offset;
      };
      var validate = function(it) {
        if (isObject(it) && TYPED_ARRAY in it) return it;
        throw TypeError(it + " is not a typed array!");
      };
      var allocate = function(C, length) {
        if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) throw TypeError("It is not a typed array constructor!");
        return new C(length);
      };
      var speciesFromList = function(O, list) {
        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
      };
      var fromList = function(C, list) {
        var index = 0;
        var length = list.length;
        var result = allocate(C, length);
        while (length > index) result[index] = list[index++];
        return result;
      };
      var addGetter = function(it, key, internal) {
        dP(it, key, {
          get: function() {
            return this._d[internal];
          }
        });
      };
      var $from = function from(source) {
        var O = toObject(source);
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : void 0;
        var mapping = void 0 !== mapfn;
        var iterFn = getIterFn(O);
        var i, length, values, result, step, iterator;
        if (void 0 != iterFn && !isArrayIter(iterFn)) {
          for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++)
            values.push(step.value);
          O = values;
        }
        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
        for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++)
          result[i] = mapping ? mapfn(O[i], i) : O[i];
        return result;
      };
      var $of = function of() {
        var index = 0;
        var length = arguments.length;
        var result = allocate(this, length);
        while (length > index) result[index] = arguments[index++];
        return result;
      };
      var TO_LOCALE_BUG =
        !!Uint8Array &&
        fails(function() {
          arrayToLocaleString.call(new Uint8Array(1));
        });
      var $toLocaleString = function toLocaleString() {
        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
      };
      var proto = {
        copyWithin: function copyWithin(target, start) {
          return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
        },
        every: function every(callbackfn) {
          return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        fill: function fill(value) {
          return arrayFill.apply(validate(this), arguments);
        },
        filter: function filter(callbackfn) {
          return speciesFromList(
            this,
            arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0)
          );
        },
        find: function find(predicate) {
          return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        },
        findIndex: function findIndex(predicate) {
          return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        },
        forEach: function forEach(callbackfn) {
          arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        indexOf: function indexOf(searchElement) {
          return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        },
        includes: function includes(searchElement) {
          return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        },
        join: function join(separator) {
          return arrayJoin.apply(validate(this), arguments);
        },
        lastIndexOf: function lastIndexOf(searchElement) {
          return arrayLastIndexOf.apply(validate(this), arguments);
        },
        map: function map(mapfn) {
          return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        reduce: function reduce(callbackfn) {
          return arrayReduce.apply(validate(this), arguments);
        },
        reduceRight: function reduceRight(callbackfn) {
          return arrayReduceRight.apply(validate(this), arguments);
        },
        reverse: function reverse() {
          var that = this;
          var length = validate(that).length;
          var middle = Math.floor(length / 2);
          var index = 0;
          var value;
          while (index < middle) {
            value = that[index];
            that[index++] = that[--length];
            that[length] = value;
          }
          return that;
        },
        some: function some(callbackfn) {
          return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        sort: function sort(comparefn) {
          return arraySort.call(validate(this), comparefn);
        },
        subarray: function subarray(begin, end) {
          var O = validate(this);
          var length = O.length;
          var $begin = toAbsoluteIndex(begin, length);
          return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
            O.buffer,
            O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
            toLength((void 0 === end ? length : toAbsoluteIndex(end, length)) - $begin)
          );
        }
      };
      var $slice = function slice(start, end) {
        return speciesFromList(this, arraySlice.call(validate(this), start, end));
      };
      var $set = function set(arrayLike) {
        validate(this);
        var offset = toOffset(arguments[1], 1);
        var length = this.length;
        var src = toObject(arrayLike);
        var len = toLength(src.length);
        var index = 0;
        if (len + offset > length) throw RangeError(WRONG_LENGTH);
        while (index < len) this[offset + index] = src[index++];
      };
      var $iterators = {
        entries: function entries() {
          return arrayEntries.call(validate(this));
        },
        keys: function keys() {
          return arrayKeys.call(validate(this));
        },
        values: function values() {
          return arrayValues.call(validate(this));
        }
      };
      var isTAIndex = function(target, key) {
        return (
          isObject(target) &&
          target[TYPED_ARRAY] &&
          "symbol" != typeof key &&
          key in target &&
          String(+key) == String(key)
        );
      };
      var $getDesc = function getOwnPropertyDescriptor(target, key) {
        return isTAIndex(target, (key = toPrimitive(key, true))) ? propertyDesc(2, target[key]) : gOPD(target, key);
      };
      var $setDesc = function defineProperty(target, key, desc) {
        if (
          isTAIndex(target, (key = toPrimitive(key, true))) &&
          isObject(desc) &&
          has(desc, "value") &&
          !has(desc, "get") &&
          !has(desc, "set") &&
          !desc.configurable &&
          (!has(desc, "writable") || desc.writable) &&
          (!has(desc, "enumerable") || desc.enumerable)
        ) {
          target[key] = desc.value;
          return target;
        }
        return dP(target, key, desc);
      };
      if (!ALL_CONSTRUCTORS) {
        $GOPD.f = $getDesc;
        $DP.f = $setDesc;
      }
      $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
        getOwnPropertyDescriptor: $getDesc,
        defineProperty: $setDesc
      });
      if (
        fails(function() {
          arrayToString.call({});
        })
      )
        arrayToString = arrayToLocaleString = function toString() {
          return arrayJoin.call(this);
        };
      var $TypedArrayPrototype$ = redefineAll({}, proto);
      redefineAll($TypedArrayPrototype$, $iterators);
      hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
      redefineAll($TypedArrayPrototype$, {
        slice: $slice,
        set: $set,
        constructor: function() {},
        toString: arrayToString,
        toLocaleString: $toLocaleString
      });
      addGetter($TypedArrayPrototype$, "buffer", "b");
      addGetter($TypedArrayPrototype$, "byteOffset", "o");
      addGetter($TypedArrayPrototype$, "byteLength", "l");
      addGetter($TypedArrayPrototype$, "length", "e");
      dP($TypedArrayPrototype$, TAG, {
        get: function() {
          return this[TYPED_ARRAY];
        }
      });
      module.exports = function(KEY, BYTES, wrapper, CLAMPED) {
        CLAMPED = !!CLAMPED;
        var NAME = KEY + (CLAMPED ? "Clamped" : "") + "Array";
        var GETTER = "get" + KEY;
        var SETTER = "set" + KEY;
        var TypedArray = global[NAME];
        var Base = TypedArray || {};
        var TAC = TypedArray && getPrototypeOf(TypedArray);
        var FORCED = !TypedArray || !$typed.ABV;
        var O = {};
        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
        var getter = function(that, index) {
          var data = that._d;
          return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
        };
        var setter = function(that, index, value) {
          var data = that._d;
          if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 255 ? 255 : 255 & value;
          data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
        };
        var addElement = function(that, index) {
          dP(that, index, {
            get: function() {
              return getter(this, index);
            },
            set: function(value) {
              return setter(this, index, value);
            },
            enumerable: true
          });
        };
        if (FORCED) {
          TypedArray = wrapper(function(that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME, "_d");
            var index = 0;
            var offset = 0;
            var buffer, byteLength, length, klass;
            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new $ArrayBuffer(byteLength);
            } else if (
              data instanceof $ArrayBuffer ||
              (klass = classof(data)) == ARRAY_BUFFER ||
              klass == SHARED_BUFFER
            ) {
              buffer = data;
              offset = toOffset($offset, BYTES);
              var $len = data.byteLength;
              if (void 0 === $length) {
                if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                byteLength = $len - offset;
                if (byteLength < 0) throw RangeError(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
              }
              length = byteLength / BYTES;
            } else if (TYPED_ARRAY in data) return fromList(TypedArray, data);
            else return $from.call(TypedArray, data);
            hide(that, "_d", { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) });
            while (index < length) addElement(that, index++);
          });
          TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
          hide(TypedArrayPrototype, "constructor", TypedArray);
        } else if (
          !fails(function() {
            TypedArray(1);
          }) ||
          !fails(function() {
            new TypedArray(-1);
          }) ||
          !$iterDetect(function(iter) {
            new TypedArray();
            new TypedArray(null);
            new TypedArray(1.5);
            new TypedArray(iter);
          }, true)
        ) {
          TypedArray = wrapper(function(that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME);
            var klass;
            if (!isObject(data)) return new Base(toIndex(data));
            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER)
              return void 0 !== $length
                ? new Base(data, toOffset($offset, BYTES), $length)
                : void 0 !== $offset
                ? new Base(data, toOffset($offset, BYTES))
                : new Base(data);
            if (TYPED_ARRAY in data) return fromList(TypedArray, data);
            return $from.call(TypedArray, data);
          });
          arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
            if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
          });
          TypedArray[PROTOTYPE] = TypedArrayPrototype;
          if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
        }
        var $nativeIterator = TypedArrayPrototype[ITERATOR];
        var CORRECT_ITER_NAME =
          !!$nativeIterator && ("values" == $nativeIterator.name || void 0 == $nativeIterator.name);
        var $iterator = $iterators.values;
        hide(TypedArray, TYPED_CONSTRUCTOR, true);
        hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
        hide(TypedArrayPrototype, VIEW, true);
        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype))
          dP(TypedArrayPrototype, TAG, {
            get: function() {
              return NAME;
            }
          });
        O[NAME] = TypedArray;
        $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
        $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES });
        $export(
          $export.S +
            $export.F *
              fails(function() {
                Base.of.call(TypedArray, 1);
              }),
          NAME,
          { from: $from, of: $of }
        );
        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
        $export($export.P, NAME, proto);
        setSpecies(NAME);
        $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
        $export(
          $export.P +
            $export.F *
              fails(function() {
                new TypedArray(1).slice();
              }),
          NAME,
          { slice: $slice }
        );
        $export(
          $export.P +
            $export.F *
              (fails(function() {
                return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
              }) ||
                !fails(function() {
                  TypedArrayPrototype.toLocaleString.call([1, 2]);
                })),
          NAME,
          { toLocaleString: $toLocaleString }
        );
        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
      };
    } else module.exports = function() {};
  });
  _typedArray("Uint8", 1, function(init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });
  (function(Barcode) {
    function createFromWASMResult(result) {
      var decodedData;
      try {
        decodedData = decodeURIComponent(escape(String.fromCharCode.apply(null, result.rawData)));
      } catch (error) {
        decodedData = "";
      }
      return {
        symbology: result.symbology,
        data: decodedData,
        rawData: new Uint8Array(result.rawData),
        location: {
          topLeft: { x: result.location[0][0], y: result.location[0][1] },
          topRight: { x: result.location[1][0], y: result.location[1][1] },
          bottomRight: { x: result.location[2][0], y: result.location[2][1] },
          bottomLeft: { x: result.location[3][0], y: result.location[3][1] }
        },
        compositeFlag: result.compositeFlag,
        isGs1DataCarrier: result.isGs1DataCarrier,
        encodingArray: result.encodingArray
      };
    }
    Barcode.createFromWASMResult = createFromWASMResult;
    (function(Symbology) {
      Symbology["AZTEC"] = "aztec";
      Symbology["CODABAR"] = "codabar";
      Symbology["CODE11"] = "code11";
      Symbology["CODE128"] = "code128";
      Symbology["CODE25"] = "code25";
      Symbology["CODE32"] = "code32";
      Symbology["CODE39"] = "code39";
      Symbology["CODE93"] = "code93";
      Symbology["DATA_MATRIX"] = "data-matrix";
      Symbology["DOTCODE"] = "dotcode";
      Symbology["EAN13"] = "ean13";
      Symbology["EAN8"] = "ean8";
      Symbology["FIVE_DIGIT_ADD_ON"] = "five-digit-add-on";
      Symbology["GS1_DATABAR"] = "databar";
      Symbology["GS1_DATABAR_EXPANDED"] = "databar-expanded";
      Symbology["GS1_DATABAR_LIMITED"] = "databar-limited";
      Symbology["INTERLEAVED_2_OF_5"] = "itf";
      Symbology["KIX"] = "kix";
      Symbology["LAPA4SC"] = "lapa4sc";
      Symbology["MAXICODE"] = "maxicode";
      Symbology["MICRO_PDF417"] = "micropdf417";
      Symbology["MICRO_QR"] = "microqr";
      Symbology["MSI_PLESSEY"] = "msi-plessey";
      Symbology["PDF417"] = "pdf417";
      Symbology["QR"] = "qr";
      Symbology["RM4SCC"] = "rm4scc";
      Symbology["TWO_DIGIT_ADD_ON"] = "two-digit-add-on";
      Symbology["UPCA"] = "upca";
      Symbology["UPCE"] = "upce";
    })(Barcode.Symbology || (Barcode.Symbology = {}));
    (function(CompositeFlag) {
      CompositeFlag[(CompositeFlag["NONE"] = 0)] = "NONE";
      CompositeFlag[(CompositeFlag["UNKNOWN"] = 1)] = "UNKNOWN";
      CompositeFlag[(CompositeFlag["LINKED"] = 2)] = "LINKED";
      CompositeFlag[(CompositeFlag["GS1_A"] = 4)] = "GS1_A";
      CompositeFlag[(CompositeFlag["GS1_B"] = 8)] = "GS1_B";
      CompositeFlag[(CompositeFlag["GS1_C"] = 16)] = "GS1_C";
    })(Barcode.CompositeFlag || (Barcode.CompositeFlag = {}));
    (function(Symbology) {
      function toHumanizedName(symbology) {
        switch (symbology.toLowerCase()) {
          case Symbology.AZTEC:
            return "Aztec";
          case Symbology.CODABAR:
            return "Codabar";
          case Symbology.CODE11:
            return "Code 11";
          case Symbology.CODE128:
            return "Code 128";
          case Symbology.CODE25:
            return "Code 25";
          case Symbology.CODE32:
            return "Code 32";
          case Symbology.CODE39:
            return "Code 39";
          case Symbology.CODE93:
            return "Code 93";
          case Symbology.DATA_MATRIX:
            return "Data Matrix";
          case Symbology.DOTCODE:
            return "DotCode";
          case Symbology.EAN13:
            return "EAN-13";
          case Symbology.EAN8:
            return "EAN-8";
          case Symbology.FIVE_DIGIT_ADD_ON:
            return "Five-Digit Add-On";
          case Symbology.GS1_DATABAR_EXPANDED:
            return "GS1 DataBar Expanded";
          case Symbology.GS1_DATABAR_LIMITED:
            return "GS1 DataBar Limited";
          case Symbology.GS1_DATABAR:
            return "GS1 DataBar 14";
          case Symbology.INTERLEAVED_2_OF_5:
            return "Interleaved Two of Five";
          case Symbology.KIX:
            return "KIX";
          case Symbology.LAPA4SC:
            return "LAPA4SC";
          case Symbology.MAXICODE:
            return "MaxiCode";
          case Symbology.MICRO_PDF417:
            return "MicroPDF417";
          case Symbology.MICRO_QR:
            return "Micro QR";
          case Symbology.MSI_PLESSEY:
            return "MSI-Plessey";
          case Symbology.PDF417:
            return "PDF417";
          case Symbology.QR:
            return "QR";
          case Symbology.RM4SCC:
            return "RM4SCC";
          case Symbology.TWO_DIGIT_ADD_ON:
            return "Two-Digit Add-On";
          case Symbology.UPCA:
            return "UPC-A";
          case Symbology.UPCE:
            return "UPC-E";
          default:
            return "Unknown";
        }
      }
      Symbology.toHumanizedName = toHumanizedName;
      function toJSONName(symbology) {
        switch (symbology.toLowerCase()) {
          case Symbology.AZTEC:
            return "aztec";
          case Symbology.CODABAR:
            return "codabar";
          case Symbology.CODE11:
            return "code11";
          case Symbology.CODE128:
            return "code128";
          case Symbology.CODE25:
            return "code25";
          case Symbology.CODE32:
            return "code32";
          case Symbology.CODE39:
            return "code39";
          case Symbology.CODE93:
            return "code93";
          case Symbology.DATA_MATRIX:
            return "data-matrix";
          case Symbology.DOTCODE:
            return "dotcode";
          case Symbology.EAN13:
            return "ean13";
          case Symbology.EAN8:
            return "ean8";
          case Symbology.FIVE_DIGIT_ADD_ON:
            return "five-digit-add-on";
          case Symbology.GS1_DATABAR_EXPANDED:
            return "databar-expanded";
          case Symbology.GS1_DATABAR_LIMITED:
            return "databar-limited";
          case Symbology.GS1_DATABAR:
            return "databar";
          case Symbology.INTERLEAVED_2_OF_5:
            return "itf";
          case Symbology.KIX:
            return "kix";
          case Symbology.LAPA4SC:
            return "lapa4sc";
          case Symbology.MAXICODE:
            return "maxicode";
          case Symbology.MICRO_PDF417:
            return "micropdf417";
          case Symbology.MICRO_QR:
            return "microqr";
          case Symbology.MSI_PLESSEY:
            return "msi-plessey";
          case Symbology.PDF417:
            return "pdf417";
          case Symbology.QR:
            return "qr";
          case Symbology.RM4SCC:
            return "rm4scc";
          case Symbology.TWO_DIGIT_ADD_ON:
            return "two-digit-add-on";
          case Symbology.UPCA:
            return "upca";
          case Symbology.UPCE:
            return "upce";
          default:
            return "unknown";
        }
      }
      Symbology.toJSONName = toJSONName;
    })(Barcode.Symbology || (Barcode.Symbology = {}));
  })(exports.Barcode || (exports.Barcode = {}));
  _export(_export.S + _export.F * !_descriptors$1, "Object", { defineProperty: _objectDp$1.f });
  var $Object$1 = _core$1.Object;
  var defineProperty$1 = function defineProperty(it, key, desc) {
    return $Object$1.defineProperty(it, key, desc);
  };
  var defineProperty$2 = defineProperty$1;
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      defineProperty$2(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var createClass = _createClass;
  var eventemitter3 = createCommonjsModule(function(module) {
    var has = Object.prototype.hasOwnProperty,
      prefix = "~";
    function Events() {}
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if ("function" !== typeof fn) throw new TypeError("The listener must be a function");
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) (emitter._events[evt] = listener), emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (0 === --emitter._eventsCount) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var events,
        name,
        names = [];
      if (0 === this._eventsCount) return names;
      for (name in (events = this._events)) if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var args,
        i,
        listeners = this._events[evt],
        len = arguments.length;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
      } else {
        var j,
          length = listeners.length;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context))
          clearEvent(this, evt);
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++)
          if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context))
            events.push(listeners[i]);
        if (events.length) this._events[evt] = 1 === events.length ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    module.exports = EventEmitter;
  });
  var eventemitter3_1 = eventemitter3.EventEmitter;
  var howler_core_min = createCommonjsModule(function(module, exports) {
    !(function() {
      var e = function() {
        this.init();
      };
      e.prototype = {
        init: function() {
          var e = this || n;
          return (
            (e._counter = 1e3),
            (e._html5AudioPool = []),
            (e.html5PoolSize = 10),
            (e._codecs = {}),
            (e._howls = []),
            (e._muted = !1),
            (e._volume = 1),
            (e._canPlayEvent = "canplaythrough"),
            (e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null),
            (e.masterGain = null),
            (e.noAudio = !1),
            (e.usingWebAudio = !0),
            (e.autoSuspend = !0),
            (e.ctx = null),
            (e.autoUnlock = !0),
            e._setup(),
            e
          );
        },
        volume: function(e) {
          var o = this || n;
          if (((e = parseFloat(e)), o.ctx || _(), void 0 !== e && e >= 0 && e <= 1)) {
            if (((o._volume = e), o._muted)) return o;
            o.usingWebAudio && o.masterGain.gain.setValueAtTime(e, n.ctx.currentTime);
            for (var t = 0; t < o._howls.length; t++)
              if (!o._howls[t]._webAudio)
                for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
                  var u = o._howls[t]._soundById(r[a]);
                  u && u._node && (u._node.volume = u._volume * e);
                }
            return o;
          }
          return o._volume;
        },
        mute: function(e) {
          var o = this || n;
          o.ctx || _(),
            (o._muted = e),
            o.usingWebAudio && o.masterGain.gain.setValueAtTime(e ? 0 : o._volume, n.ctx.currentTime);
          for (var t = 0; t < o._howls.length; t++)
            if (!o._howls[t]._webAudio)
              for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
                var u = o._howls[t]._soundById(r[a]);
                u && u._node && (u._node.muted = !!e || u._muted);
              }
          return o;
        },
        unload: function() {
          for (var e = this || n, o = e._howls.length - 1; o >= 0; o--) e._howls[o].unload();
          return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), (e.ctx = null), _()), e;
        },
        codecs: function(e) {
          return (this || n)._codecs[e.replace(/^x-/, "")];
        },
        _setup: function() {
          var e = this || n;
          if (((e.state = e.ctx ? e.ctx.state || "suspended" : "suspended"), e._autoSuspend(), !e.usingWebAudio))
            if ("undefined" != typeof Audio)
              try {
                var o = new Audio();
                void 0 === o.oncanplaythrough && (e._canPlayEvent = "canplay");
              } catch (n) {
                e.noAudio = !0;
              }
            else e.noAudio = !0;
          try {
            o = new Audio();
            o.muted && (e.noAudio = !0);
          } catch (e) {}
          return e.noAudio || e._setupCodecs(), e;
        },
        _setupCodecs: function() {
          var e = this || n,
            o = null;
          try {
            o = "undefined" != typeof Audio ? new Audio() : null;
          } catch (n) {
            return e;
          }
          if (!o || "function" != typeof o.canPlayType) return e;
          var t = o.canPlayType("audio/mpeg;").replace(/^no$/, ""),
            r = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g),
            a = r && parseInt(r[0].split("/")[1], 10) < 33;
          return (
            (e._codecs = {
              mp3: !(a || (!t && !o.canPlayType("audio/mp3;").replace(/^no$/, ""))),
              mpeg: !!t,
              opus: !!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
              ogg: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
              oga: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
              wav: !!o.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
              aac: !!o.canPlayType("audio/aac;").replace(/^no$/, ""),
              caf: !!o.canPlayType("audio/x-caf;").replace(/^no$/, ""),
              m4a: !!(
                o.canPlayType("audio/x-m4a;") ||
                o.canPlayType("audio/m4a;") ||
                o.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              mp4: !!(
                o.canPlayType("audio/x-mp4;") ||
                o.canPlayType("audio/mp4;") ||
                o.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              weba: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
              webm: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
              dolby: !!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
              flac: !!(o.canPlayType("audio/x-flac;") || o.canPlayType("audio/flac;")).replace(/^no$/, "")
            }),
            e
          );
        },
        _unlockAudio: function() {
          var e = this || n,
            o = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi|Chrome|Safari/i.test(
              e._navigator && e._navigator.userAgent
            );
          if (!e._audioUnlocked && e.ctx && o) {
            (e._audioUnlocked = !1),
              (e.autoUnlock = !1),
              e._mobileUnloaded || 44100 === e.ctx.sampleRate || ((e._mobileUnloaded = !0), e.unload()),
              (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
            var t = function(n) {
              for (var o = 0; o < e.html5PoolSize; o++) {
                var r = new Audio();
                (r._unlocked = !0), e._releaseHtml5Audio(r);
              }
              for (o = 0; o < e._howls.length; o++)
                if (!e._howls[o]._webAudio)
                  for (var a = e._howls[o]._getSoundIds(), u = 0; u < a.length; u++) {
                    var i = e._howls[o]._soundById(a[u]);
                    i && i._node && !i._node._unlocked && ((i._node._unlocked = !0), i._node.load());
                  }
              e._autoResume();
              var d = e.ctx.createBufferSource();
              (d.buffer = e._scratchBuffer),
                d.connect(e.ctx.destination),
                void 0 === d.start ? d.noteOn(0) : d.start(0),
                "function" == typeof e.ctx.resume && e.ctx.resume(),
                (d.onended = function() {
                  d.disconnect(0),
                    (e._audioUnlocked = !0),
                    document.removeEventListener("touchstart", t, !0),
                    document.removeEventListener("touchend", t, !0),
                    document.removeEventListener("click", t, !0);
                  for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("unlock");
                });
            };
            return (
              document.addEventListener("touchstart", t, !0),
              document.addEventListener("touchend", t, !0),
              document.addEventListener("click", t, !0),
              e
            );
          }
        },
        _obtainHtml5Audio: function() {
          var e = this || n;
          if (e._html5AudioPool.length) return e._html5AudioPool.pop();
          var o = new Audio().play();
          return (
            o &&
              "undefined" != typeof Promise &&
              (o instanceof Promise || "function" == typeof o.then) &&
              o.catch(function() {
                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
              }),
            new Audio()
          );
        },
        _releaseHtml5Audio: function(e) {
          var o = this || n;
          return e._unlocked && o._html5AudioPool.push(e), o;
        },
        _autoSuspend: function() {
          var e = this;
          if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && n.usingWebAudio) {
            for (var o = 0; o < e._howls.length; o++)
              if (e._howls[o]._webAudio)
                for (var t = 0; t < e._howls[o]._sounds.length; t++) if (!e._howls[o]._sounds[t]._paused) return e;
            return (
              e._suspendTimer && clearTimeout(e._suspendTimer),
              (e._suspendTimer = setTimeout(function() {
                e.autoSuspend &&
                  ((e._suspendTimer = null),
                  (e.state = "suspending"),
                  e.ctx.suspend().then(function() {
                    (e.state = "suspended"), e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume());
                  }));
              }, 3e4)),
              e
            );
          }
        },
        _autoResume: function() {
          var e = this;
          if (e.ctx && void 0 !== e.ctx.resume && n.usingWebAudio)
            return (
              "running" === e.state && e._suspendTimer
                ? (clearTimeout(e._suspendTimer), (e._suspendTimer = null))
                : "suspended" === e.state
                ? (e.ctx.resume().then(function() {
                    e.state = "running";
                    for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("resume");
                  }),
                  e._suspendTimer && (clearTimeout(e._suspendTimer), (e._suspendTimer = null)))
                : "suspending" === e.state && (e._resumeAfterSuspend = !0),
              e
            );
        }
      };
      var n = new e(),
        o = function(e) {
          var n = this;
          if (!e.src || 0 === e.src.length)
            return void console.error("An array of source files must be passed with any new Howl.");
          n.init(e);
        };
      o.prototype = {
        init: function(e) {
          var o = this;
          return (
            n.ctx || _(),
            (o._autoplay = e.autoplay || !1),
            (o._format = "string" != typeof e.format ? e.format : [e.format]),
            (o._html5 = e.html5 || !1),
            (o._muted = e.mute || !1),
            (o._loop = e.loop || !1),
            (o._pool = e.pool || 5),
            (o._preload = "boolean" != typeof e.preload || e.preload),
            (o._rate = e.rate || 1),
            (o._sprite = e.sprite || {}),
            (o._src = "string" != typeof e.src ? e.src : [e.src]),
            (o._volume = void 0 !== e.volume ? e.volume : 1),
            (o._xhrWithCredentials = e.xhrWithCredentials || !1),
            (o._duration = 0),
            (o._state = "unloaded"),
            (o._sounds = []),
            (o._endTimers = {}),
            (o._queue = []),
            (o._playLock = !1),
            (o._onend = e.onend ? [{ fn: e.onend }] : []),
            (o._onfade = e.onfade ? [{ fn: e.onfade }] : []),
            (o._onload = e.onload ? [{ fn: e.onload }] : []),
            (o._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : []),
            (o._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : []),
            (o._onpause = e.onpause ? [{ fn: e.onpause }] : []),
            (o._onplay = e.onplay ? [{ fn: e.onplay }] : []),
            (o._onstop = e.onstop ? [{ fn: e.onstop }] : []),
            (o._onmute = e.onmute ? [{ fn: e.onmute }] : []),
            (o._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
            (o._onrate = e.onrate ? [{ fn: e.onrate }] : []),
            (o._onseek = e.onseek ? [{ fn: e.onseek }] : []),
            (o._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
            (o._onresume = []),
            (o._webAudio = n.usingWebAudio && !o._html5),
            void 0 !== n.ctx && n.ctx && n.autoUnlock && n._unlockAudio(),
            n._howls.push(o),
            o._autoplay &&
              o._queue.push({
                event: "play",
                action: function() {
                  o.play();
                }
              }),
            o._preload && o.load(),
            o
          );
        },
        load: function() {
          var e = this,
            o = null;
          if (n.noAudio) return void e._emit("loaderror", null, "No audio support.");
          "string" == typeof e._src && (e._src = [e._src]);
          for (var r = 0; r < e._src.length; r++) {
            var u, i;
            if (e._format && e._format[r]) u = e._format[r];
            else {
              if ("string" != typeof (i = e._src[r])) {
                e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              (u = /^data:audio\/([^;,]+);/i.exec(i)),
                u || (u = /\.([^.]+)$/.exec(i.split("?", 1)[0])),
                u && (u = u[1].toLowerCase());
            }
            if (
              (u ||
                console.warn(
                  'No file extension was found. Consider using the "format" property or specify an extension.'
                ),
              u && n.codecs(u))
            ) {
              o = e._src[r];
              break;
            }
          }
          return o
            ? ((e._src = o),
              (e._state = "loading"),
              "https:" === window.location.protocol &&
                "http:" === o.slice(0, 5) &&
                ((e._html5 = !0), (e._webAudio = !1)),
              new t(e),
              e._webAudio && a(e),
              e)
            : void e._emit("loaderror", null, "No codec support for selected audio sources.");
        },
        play: function(e, o) {
          var t = this,
            r = null;
          if ("number" == typeof e) (r = e), (e = null);
          else {
            if ("string" == typeof e && "loaded" === t._state && !t._sprite[e]) return null;
            if (void 0 === e && ((e = "__default"), !t._playLock)) {
              for (var a = 0, u = 0; u < t._sounds.length; u++)
                t._sounds[u]._paused && !t._sounds[u]._ended && (a++, (r = t._sounds[u]._id));
              1 === a ? (e = null) : (r = null);
            }
          }
          var i = r ? t._soundById(r) : t._inactiveSound();
          if (!i) return null;
          if ((r && !e && (e = i._sprite || "__default"), "loaded" !== t._state)) {
            (i._sprite = e), (i._ended = !1);
            var d = i._id;
            return (
              t._queue.push({
                event: "play",
                action: function() {
                  t.play(d);
                }
              }),
              d
            );
          }
          if (r && !i._paused) return o || t._loadQueue("play"), i._id;
          t._webAudio && n._autoResume();
          var _ = Math.max(0, i._seek > 0 ? i._seek : t._sprite[e][0] / 1e3),
            s = Math.max(0, (t._sprite[e][0] + t._sprite[e][1]) / 1e3 - _),
            l = (1e3 * s) / Math.abs(i._rate),
            c = t._sprite[e][0] / 1e3,
            f = (t._sprite[e][0] + t._sprite[e][1]) / 1e3,
            p = !(!i._loop && !t._sprite[e][2]);
          (i._sprite = e), (i._ended = !1);
          var m = function() {
            (i._paused = !1), (i._seek = _), (i._start = c), (i._stop = f), (i._loop = p);
          };
          if (_ >= f) return void t._ended(i);
          var v = i._node;
          if (t._webAudio) {
            var h = function() {
              (t._playLock = !1), m(), t._refreshBuffer(i);
              var e = i._muted || t._muted ? 0 : i._volume;
              v.gain.setValueAtTime(e, n.ctx.currentTime),
                (i._playStart = n.ctx.currentTime),
                void 0 === v.bufferSource.start
                  ? i._loop
                    ? v.bufferSource.noteGrainOn(0, _, 86400)
                    : v.bufferSource.noteGrainOn(0, _, s)
                  : i._loop
                  ? v.bufferSource.start(0, _, 86400)
                  : v.bufferSource.start(0, _, s),
                l !== 1 / 0 && (t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l)),
                o ||
                  setTimeout(function() {
                    t._emit("play", i._id), t._loadQueue();
                  }, 0);
            };
            "running" === n.state ? h() : ((t._playLock = !0), t.once("resume", h), t._clearTimer(i._id));
          } else {
            var y = function() {
                (v.currentTime = _),
                  (v.muted = i._muted || t._muted || n._muted || v.muted),
                  (v.volume = i._volume * n.volume()),
                  (v.playbackRate = i._rate);
                try {
                  var r = v.play();
                  if (
                    (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then)
                      ? ((t._playLock = !0),
                        m(),
                        r
                          .then(function() {
                            (t._playLock = !1), (v._unlocked = !0), o || (t._emit("play", i._id), t._loadQueue());
                          })
                          .catch(function() {
                            (t._playLock = !1),
                              t._emit(
                                "playerror",
                                i._id,
                                "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                              ),
                              (i._ended = !0),
                              (i._paused = !0);
                          }))
                      : o || ((t._playLock = !1), m(), t._emit("play", i._id), t._loadQueue()),
                    (v.playbackRate = i._rate),
                    v.paused)
                  )
                    return void t._emit(
                      "playerror",
                      i._id,
                      "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                    );
                  "__default" !== e || i._loop
                    ? (t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l))
                    : ((t._endTimers[i._id] = function() {
                        t._ended(i), v.removeEventListener("ended", t._endTimers[i._id], !1);
                      }),
                      v.addEventListener("ended", t._endTimers[i._id], !1));
                } catch (e) {
                  t._emit("playerror", i._id, e);
                }
              },
              g = (window && window.ejecta) || (!v.readyState && n._navigator.isCocoonJS);
            if (v.readyState >= 3 || g) y();
            else {
              t._playLock = !0;
              var b = function() {
                y(), v.removeEventListener(n._canPlayEvent, b, !1);
              };
              v.addEventListener(n._canPlayEvent, b, !1), t._clearTimer(i._id);
            }
          }
          return i._id;
        },
        pause: function(e) {
          var n = this;
          if ("loaded" !== n._state || n._playLock)
            return (
              n._queue.push({
                event: "pause",
                action: function() {
                  n.pause(e);
                }
              }),
              n
            );
          for (var o = n._getSoundIds(e), t = 0; t < o.length; t++) {
            n._clearTimer(o[t]);
            var r = n._soundById(o[t]);
            if (
              r &&
              !r._paused &&
              ((r._seek = n.seek(o[t])), (r._rateSeek = 0), (r._paused = !0), n._stopFade(o[t]), r._node)
            )
              if (n._webAudio) {
                if (!r._node.bufferSource) continue;
                void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
                  n._cleanBuffer(r._node);
              } else (isNaN(r._node.duration) && r._node.duration !== 1 / 0) || r._node.pause();
            arguments[1] || n._emit("pause", r ? r._id : null);
          }
          return n;
        },
        stop: function(e, n) {
          var o = this;
          if ("loaded" !== o._state || o._playLock)
            return (
              o._queue.push({
                event: "stop",
                action: function() {
                  o.stop(e);
                }
              }),
              o
            );
          for (var t = o._getSoundIds(e), r = 0; r < t.length; r++) {
            o._clearTimer(t[r]);
            var a = o._soundById(t[r]);
            a &&
              ((a._seek = a._start || 0),
              (a._rateSeek = 0),
              (a._paused = !0),
              (a._ended = !0),
              o._stopFade(t[r]),
              a._node &&
                (o._webAudio
                  ? a._node.bufferSource &&
                    (void 0 === a._node.bufferSource.stop
                      ? a._node.bufferSource.noteOff(0)
                      : a._node.bufferSource.stop(0),
                    o._cleanBuffer(a._node))
                  : (isNaN(a._node.duration) && a._node.duration !== 1 / 0) ||
                    ((a._node.currentTime = a._start || 0), a._node.pause())),
              n || o._emit("stop", a._id));
          }
          return o;
        },
        mute: function(e, o) {
          var t = this;
          if ("loaded" !== t._state || t._playLock)
            return (
              t._queue.push({
                event: "mute",
                action: function() {
                  t.mute(e, o);
                }
              }),
              t
            );
          if (void 0 === o) {
            if ("boolean" != typeof e) return t._muted;
            t._muted = e;
          }
          for (var r = t._getSoundIds(o), a = 0; a < r.length; a++) {
            var u = t._soundById(r[a]);
            u &&
              ((u._muted = e),
              u._interval && t._stopFade(u._id),
              t._webAudio && u._node
                ? u._node.gain.setValueAtTime(e ? 0 : u._volume, n.ctx.currentTime)
                : u._node && (u._node.muted = !!n._muted || e),
              t._emit("mute", u._id));
          }
          return t;
        },
        volume: function() {
          var e,
            o,
            t = this,
            r = arguments;
          if (0 === r.length) return t._volume;
          if (1 === r.length || (2 === r.length && void 0 === r[1]))
            t._getSoundIds().indexOf(r[0]) >= 0 ? (o = parseInt(r[0], 10)) : (e = parseFloat(r[0]));
          else r.length >= 2 && ((e = parseFloat(r[0])), (o = parseInt(r[1], 10)));
          var a;
          if (!(void 0 !== e && e >= 0 && e <= 1)) return (a = o ? t._soundById(o) : t._sounds[0]), a ? a._volume : 0;
          if ("loaded" !== t._state || t._playLock)
            return (
              t._queue.push({
                event: "volume",
                action: function() {
                  t.volume.apply(t, r);
                }
              }),
              t
            );
          void 0 === o && (t._volume = e), (o = t._getSoundIds(o));
          for (var u = 0; u < o.length; u++)
            (a = t._soundById(o[u])) &&
              ((a._volume = e),
              r[2] || t._stopFade(o[u]),
              t._webAudio && a._node && !a._muted
                ? a._node.gain.setValueAtTime(e, n.ctx.currentTime)
                : a._node && !a._muted && (a._node.volume = e * n.volume()),
              t._emit("volume", a._id));
          return t;
        },
        fade: function(e, o, t, r) {
          var a = this;
          if ("loaded" !== a._state || a._playLock)
            return (
              a._queue.push({
                event: "fade",
                action: function() {
                  a.fade(e, o, t, r);
                }
              }),
              a
            );
          (e = parseFloat(e)), (o = parseFloat(o)), (t = parseFloat(t)), a.volume(e, r);
          for (var u = a._getSoundIds(r), i = 0; i < u.length; i++) {
            var d = a._soundById(u[i]);
            if (d) {
              if ((r || a._stopFade(u[i]), a._webAudio && !d._muted)) {
                var _ = n.ctx.currentTime,
                  s = _ + t / 1e3;
                (d._volume = e), d._node.gain.setValueAtTime(e, _), d._node.gain.linearRampToValueAtTime(o, s);
              }
              a._startFadeInterval(d, e, o, t, u[i], void 0 === r);
            }
          }
          return a;
        },
        _startFadeInterval: function(e, n, o, t, r, a) {
          var u = this,
            i = n,
            d = o - n,
            _ = Math.abs(d / 0.01),
            s = Math.max(4, _ > 0 ? t / _ : t),
            l = Date.now();
          (e._fadeTo = o),
            (e._interval = setInterval(function() {
              var r = (Date.now() - l) / t;
              (l = Date.now()),
                (i += d * r),
                (i = Math.max(0, i)),
                (i = Math.min(1, i)),
                (i = Math.round(100 * i) / 100),
                u._webAudio ? (e._volume = i) : u.volume(i, e._id, !0),
                a && (u._volume = i),
                ((o < n && i <= o) || (o > n && i >= o)) &&
                  (clearInterval(e._interval),
                  (e._interval = null),
                  (e._fadeTo = null),
                  u.volume(o, e._id),
                  u._emit("fade", e._id));
            }, s));
        },
        _stopFade: function(e) {
          var o = this,
            t = o._soundById(e);
          return (
            t &&
              t._interval &&
              (o._webAudio && t._node.gain.cancelScheduledValues(n.ctx.currentTime),
              clearInterval(t._interval),
              (t._interval = null),
              o.volume(t._fadeTo, e),
              (t._fadeTo = null),
              o._emit("fade", e)),
            o
          );
        },
        loop: function() {
          var e,
            n,
            o,
            t = this,
            r = arguments;
          if (0 === r.length) return t._loop;
          if (1 === r.length) {
            if ("boolean" != typeof r[0]) return !!(o = t._soundById(parseInt(r[0], 10))) && o._loop;
            (e = r[0]), (t._loop = e);
          } else 2 === r.length && ((e = r[0]), (n = parseInt(r[1], 10)));
          for (var a = t._getSoundIds(n), u = 0; u < a.length; u++)
            (o = t._soundById(a[u])) &&
              ((o._loop = e),
              t._webAudio &&
                o._node &&
                o._node.bufferSource &&
                ((o._node.bufferSource.loop = e),
                e && ((o._node.bufferSource.loopStart = o._start || 0), (o._node.bufferSource.loopEnd = o._stop))));
          return t;
        },
        rate: function() {
          var e,
            o,
            t = this,
            r = arguments;
          if (0 === r.length) o = t._sounds[0]._id;
          else if (1 === r.length) {
            var a = t._getSoundIds(),
              u = a.indexOf(r[0]);
            u >= 0 ? (o = parseInt(r[0], 10)) : (e = parseFloat(r[0]));
          } else 2 === r.length && ((e = parseFloat(r[0])), (o = parseInt(r[1], 10)));
          var i;
          if ("number" != typeof e) return (i = t._soundById(o)), i ? i._rate : t._rate;
          if ("loaded" !== t._state || t._playLock)
            return (
              t._queue.push({
                event: "rate",
                action: function() {
                  t.rate.apply(t, r);
                }
              }),
              t
            );
          void 0 === o && (t._rate = e), (o = t._getSoundIds(o));
          for (var d = 0; d < o.length; d++)
            if ((i = t._soundById(o[d]))) {
              t.playing(o[d]) &&
                ((i._rateSeek = t.seek(o[d])), (i._playStart = t._webAudio ? n.ctx.currentTime : i._playStart)),
                (i._rate = e),
                t._webAudio && i._node && i._node.bufferSource
                  ? i._node.bufferSource.playbackRate.setValueAtTime(e, n.ctx.currentTime)
                  : i._node && (i._node.playbackRate = e);
              var _ = t.seek(o[d]),
                s = (t._sprite[i._sprite][0] + t._sprite[i._sprite][1]) / 1e3 - _,
                l = (1e3 * s) / Math.abs(i._rate);
              (!t._endTimers[o[d]] && i._paused) ||
                (t._clearTimer(o[d]), (t._endTimers[o[d]] = setTimeout(t._ended.bind(t, i), l))),
                t._emit("rate", i._id);
            }
          return t;
        },
        seek: function() {
          var e,
            o,
            t = this,
            r = arguments;
          if (0 === r.length) o = t._sounds[0]._id;
          else if (1 === r.length) {
            var a = t._getSoundIds(),
              u = a.indexOf(r[0]);
            u >= 0 ? (o = parseInt(r[0], 10)) : t._sounds.length && ((o = t._sounds[0]._id), (e = parseFloat(r[0])));
          } else 2 === r.length && ((e = parseFloat(r[0])), (o = parseInt(r[1], 10)));
          if (void 0 === o) return t;
          if ("loaded" !== t._state || t._playLock)
            return (
              t._queue.push({
                event: "seek",
                action: function() {
                  t.seek.apply(t, r);
                }
              }),
              t
            );
          var i = t._soundById(o);
          if (i) {
            if (!("number" == typeof e && e >= 0)) {
              if (t._webAudio) {
                var d = t.playing(o) ? n.ctx.currentTime - i._playStart : 0,
                  _ = i._rateSeek ? i._rateSeek - i._seek : 0;
                return i._seek + (_ + d * Math.abs(i._rate));
              }
              return i._node.currentTime;
            }
            var s = t.playing(o);
            s && t.pause(o, !0),
              (i._seek = e),
              (i._ended = !1),
              t._clearTimer(o),
              t._webAudio || !i._node || isNaN(i._node.duration) || (i._node.currentTime = e);
            var l = function() {
              t._emit("seek", o), s && t.play(o, !0);
            };
            if (s && !t._webAudio) {
              var c = function() {
                t._playLock ? setTimeout(c, 0) : l();
              };
              setTimeout(c, 0);
            } else l();
          }
          return t;
        },
        playing: function(e) {
          var n = this;
          if ("number" == typeof e) {
            var o = n._soundById(e);
            return !!o && !o._paused;
          }
          for (var t = 0; t < n._sounds.length; t++) if (!n._sounds[t]._paused) return !0;
          return !1;
        },
        duration: function(e) {
          var n = this,
            o = n._duration,
            t = n._soundById(e);
          return t && (o = n._sprite[t._sprite][1] / 1e3), o;
        },
        state: function() {
          return this._state;
        },
        unload: function() {
          for (var e = this, o = e._sounds, t = 0; t < o.length; t++) {
            if ((o[t]._paused || e.stop(o[t]._id), !e._webAudio))
              /MSIE |Trident\//.test(n._navigator && n._navigator.userAgent) ||
                (o[t]._node.src =
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),
                o[t]._node.removeEventListener("error", o[t]._errorFn, !1),
                o[t]._node.removeEventListener(n._canPlayEvent, o[t]._loadFn, !1),
                n._releaseHtml5Audio(o[t]._node);
            delete o[t]._node, e._clearTimer(o[t]._id);
          }
          var a = n._howls.indexOf(e);
          a >= 0 && n._howls.splice(a, 1);
          var u = !0;
          for (t = 0; t < n._howls.length; t++)
            if (n._howls[t]._src === e._src || e._src.indexOf(n._howls[t]._src) >= 0) {
              u = !1;
              break;
            }
          return (
            r && u && delete r[e._src], (n.noAudio = !1), (e._state = "unloaded"), (e._sounds = []), (e = null), null
          );
        },
        on: function(e, n, o, t) {
          var r = this,
            a = r["_on" + e];
          return "function" == typeof n && a.push(t ? { id: o, fn: n, once: t } : { id: o, fn: n }), r;
        },
        off: function(e, n, o) {
          var t = this,
            r = t["_on" + e],
            a = 0;
          if (("number" == typeof n && ((o = n), (n = null)), n || o))
            for (a = 0; a < r.length; a++) {
              var u = o === r[a].id;
              if ((n === r[a].fn && u) || (!n && u)) {
                r.splice(a, 1);
                break;
              }
            }
          else if (e) t["_on" + e] = [];
          else {
            var i = Object.keys(t);
            for (a = 0; a < i.length; a++) 0 === i[a].indexOf("_on") && Array.isArray(t[i[a]]) && (t[i[a]] = []);
          }
          return t;
        },
        once: function(e, n, o) {
          var t = this;
          return t.on(e, n, o, 1), t;
        },
        _emit: function(e, n, o) {
          for (var t = this, r = t["_on" + e], a = r.length - 1; a >= 0; a--)
            (r[a].id && r[a].id !== n && "load" !== e) ||
              (setTimeout(
                function(e) {
                  e.call(this, n, o);
                }.bind(t, r[a].fn),
                0
              ),
              r[a].once && t.off(e, r[a].fn, r[a].id));
          return t._loadQueue(e), t;
        },
        _loadQueue: function(e) {
          var n = this;
          if (n._queue.length > 0) {
            var o = n._queue[0];
            o.event === e && (n._queue.shift(), n._loadQueue()), e || o.action();
          }
          return n;
        },
        _ended: function(e) {
          var o = this,
            t = e._sprite;
          if (!o._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop)
            return setTimeout(o._ended.bind(o, e), 100), o;
          var r = !(!e._loop && !o._sprite[t][2]);
          if ((o._emit("end", e._id), !o._webAudio && r && o.stop(e._id, !0).play(e._id), o._webAudio && r)) {
            o._emit("play", e._id), (e._seek = e._start || 0), (e._rateSeek = 0), (e._playStart = n.ctx.currentTime);
            var a = (1e3 * (e._stop - e._start)) / Math.abs(e._rate);
            o._endTimers[e._id] = setTimeout(o._ended.bind(o, e), a);
          }
          return (
            o._webAudio &&
              !r &&
              ((e._paused = !0),
              (e._ended = !0),
              (e._seek = e._start || 0),
              (e._rateSeek = 0),
              o._clearTimer(e._id),
              o._cleanBuffer(e._node),
              n._autoSuspend()),
            o._webAudio || r || o.stop(e._id, !0),
            o
          );
        },
        _clearTimer: function(e) {
          var n = this;
          if (n._endTimers[e]) {
            if ("function" != typeof n._endTimers[e]) clearTimeout(n._endTimers[e]);
            else {
              var o = n._soundById(e);
              o && o._node && o._node.removeEventListener("ended", n._endTimers[e], !1);
            }
            delete n._endTimers[e];
          }
          return n;
        },
        _soundById: function(e) {
          for (var n = this, o = 0; o < n._sounds.length; o++) if (e === n._sounds[o]._id) return n._sounds[o];
          return null;
        },
        _inactiveSound: function() {
          var e = this;
          e._drain();
          for (var n = 0; n < e._sounds.length; n++) if (e._sounds[n]._ended) return e._sounds[n].reset();
          return new t(e);
        },
        _drain: function() {
          var e = this,
            n = e._pool,
            o = 0,
            t = 0;
          if (!(e._sounds.length < n)) {
            for (t = 0; t < e._sounds.length; t++) e._sounds[t]._ended && o++;
            for (t = e._sounds.length - 1; t >= 0; t--) {
              if (o <= n) return;
              e._sounds[t]._ended &&
                (e._webAudio && e._sounds[t]._node && e._sounds[t]._node.disconnect(0), e._sounds.splice(t, 1), o--);
            }
          }
        },
        _getSoundIds: function(e) {
          var n = this;
          if (void 0 === e) {
            for (var o = [], t = 0; t < n._sounds.length; t++) o.push(n._sounds[t]._id);
            return o;
          }
          return [e];
        },
        _refreshBuffer: function(e) {
          var o = this;
          return (
            (e._node.bufferSource = n.ctx.createBufferSource()),
            (e._node.bufferSource.buffer = r[o._src]),
            e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node),
            (e._node.bufferSource.loop = e._loop),
            e._loop &&
              ((e._node.bufferSource.loopStart = e._start || 0), (e._node.bufferSource.loopEnd = e._stop || 0)),
            e._node.bufferSource.playbackRate.setValueAtTime(e._rate, n.ctx.currentTime),
            o
          );
        },
        _cleanBuffer: function(e) {
          var o = this,
            t = n._navigator && n._navigator.vendor.indexOf("Apple") >= 0;
          if (n._scratchBuffer && e.bufferSource && ((e.bufferSource.onended = null), e.bufferSource.disconnect(0), t))
            try {
              e.bufferSource.buffer = n._scratchBuffer;
            } catch (e) {}
          return (e.bufferSource = null), o;
        }
      };
      var t = function(e) {
        (this._parent = e), this.init();
      };
      t.prototype = {
        init: function() {
          var e = this,
            o = e._parent;
          return (
            (e._muted = o._muted),
            (e._loop = o._loop),
            (e._volume = o._volume),
            (e._rate = o._rate),
            (e._seek = 0),
            (e._paused = !0),
            (e._ended = !0),
            (e._sprite = "__default"),
            (e._id = ++n._counter),
            o._sounds.push(e),
            e.create(),
            e
          );
        },
        create: function() {
          var e = this,
            o = e._parent,
            t = n._muted || e._muted || e._parent._muted ? 0 : e._volume;
          return (
            o._webAudio
              ? ((e._node = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain()),
                e._node.gain.setValueAtTime(t, n.ctx.currentTime),
                (e._node.paused = !0),
                e._node.connect(n.masterGain))
              : ((e._node = n._obtainHtml5Audio()),
                (e._errorFn = e._errorListener.bind(e)),
                e._node.addEventListener("error", e._errorFn, !1),
                (e._loadFn = e._loadListener.bind(e)),
                e._node.addEventListener(n._canPlayEvent, e._loadFn, !1),
                (e._node.src = o._src),
                (e._node.preload = "auto"),
                (e._node.volume = t * n.volume()),
                e._node.load()),
            e
          );
        },
        reset: function() {
          var e = this,
            o = e._parent;
          return (
            (e._muted = o._muted),
            (e._loop = o._loop),
            (e._volume = o._volume),
            (e._rate = o._rate),
            (e._seek = 0),
            (e._rateSeek = 0),
            (e._paused = !0),
            (e._ended = !0),
            (e._sprite = "__default"),
            (e._id = ++n._counter),
            e
          );
        },
        _errorListener: function() {
          var e = this;
          e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0),
            e._node.removeEventListener("error", e._errorFn, !1);
        },
        _loadListener: function() {
          var e = this,
            o = e._parent;
          (o._duration = Math.ceil(10 * e._node.duration) / 10),
            0 === Object.keys(o._sprite).length && (o._sprite = { __default: [0, 1e3 * o._duration] }),
            "loaded" !== o._state && ((o._state = "loaded"), o._emit("load"), o._loadQueue()),
            e._node.removeEventListener(n._canPlayEvent, e._loadFn, !1);
        }
      };
      var r = {},
        a = function(e) {
          var n = e._src;
          if (r[n]) return (e._duration = r[n].duration), void d(e);
          if (/^data:[^;]+;base64,/.test(n)) {
            for (var o = atob(n.split(",")[1]), t = new Uint8Array(o.length), a = 0; a < o.length; ++a)
              t[a] = o.charCodeAt(a);
            i(t.buffer, e);
          } else {
            var _ = new XMLHttpRequest();
            _.open("GET", n, !0),
              (_.withCredentials = e._xhrWithCredentials),
              (_.responseType = "arraybuffer"),
              (_.onload = function() {
                var n = (_.status + "")[0];
                if ("0" !== n && "2" !== n && "3" !== n)
                  return void e._emit("loaderror", null, "Failed loading audio file with status: " + _.status + ".");
                i(_.response, e);
              }),
              (_.onerror = function() {
                e._webAudio && ((e._html5 = !0), (e._webAudio = !1), (e._sounds = []), delete r[n], e.load());
              }),
              u(_);
          }
        },
        u = function(e) {
          try {
            e.send();
          } catch (n) {
            e.onerror();
          }
        },
        i = function(e, o) {
          var t = function() {
              o._emit("loaderror", null, "Decoding audio data failed.");
            },
            a = function(e) {
              e && o._sounds.length > 0 ? ((r[o._src] = e), d(o, e)) : t();
            };
          "undefined" != typeof Promise && 1 === n.ctx.decodeAudioData.length
            ? n.ctx
                .decodeAudioData(e)
                .then(a)
                .catch(t)
            : n.ctx.decodeAudioData(e, a, t);
        },
        d = function(e, n) {
          n && !e._duration && (e._duration = n.duration),
            0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }),
            "loaded" !== e._state && ((e._state = "loaded"), e._emit("load"), e._loadQueue());
        },
        _ = function() {
          if (n.usingWebAudio) {
            try {
              "undefined" != typeof AudioContext
                ? (n.ctx = new AudioContext())
                : "undefined" != typeof webkitAudioContext
                ? (n.ctx = new webkitAudioContext())
                : (n.usingWebAudio = !1);
            } catch (e) {
              n.usingWebAudio = !1;
            }
            n.ctx || (n.usingWebAudio = !1);
            var e = /iP(hone|od|ad)/.test(n._navigator && n._navigator.platform),
              o = n._navigator && n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
              t = o ? parseInt(o[1], 10) : null;
            if (e && t && t < 9) {
              var r = /safari/.test(n._navigator && n._navigator.userAgent.toLowerCase());
              ((n._navigator && n._navigator.standalone && !r) || (n._navigator && !n._navigator.standalone && !r)) &&
                (n.usingWebAudio = !1);
            }
            n.usingWebAudio &&
              ((n.masterGain = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain()),
              n.masterGain.gain.setValueAtTime(n._muted ? 0 : 1, n.ctx.currentTime),
              n.masterGain.connect(n.ctx.destination)),
              n._setup();
          }
        };
      (exports.Howler = n),
        (exports.Howl = o),
        "undefined" != typeof window
          ? ((window.HowlerGlobal = e), (window.Howler = n), (window.Howl = o), (window.Sound = t))
          : "undefined" != typeof commonjsGlobal$1 &&
            ((commonjsGlobal$1.HowlerGlobal = e),
            (commonjsGlobal$1.Howler = n),
            (commonjsGlobal$1.Howl = o),
            (commonjsGlobal$1.Sound = t));
    })();
  });
  var howler_core_min_1 = howler_core_min.Howler;
  var howler_core_min_2 = howler_core_min.Howl;
  var beepSound =
    "data:audio/mp3;base64,//uwAAAAA8ROTJVigAB4icmSrFAAE/IjVfj6gAJ+RGq/H1AAADEN55555509PSUkYjEMQ5DCaBiMBmSoGPBh6QGGJAZo8BoDwGYJADEBmQbAAbMBcAJ0IIRQuFwuF8vm6aaaaaaCCH/9RcIubDkCgBQAzBOLL5cLhog3p////6BgTBFC4yZfTah/////WmYFwuBgTh///5cEDgnB8AMQ3nnnnnnT09JSRiMQxDkMJoGIwGZKgY8GHpAYYkBmjwGgPAZgkAMQGZBsABswFwAnQghFC4XC4Xy+bppppppoIIf/1Fwi5sOQKAFADME4svlwuGiDen////oGBMEULjJl9NqH////9aZgXC4GBOH///lwQOCcH7usq4IwABEoZUkABBACSAH6LQxWQ1ekTmN4ZafMA1wANy7UyDUPgZzK4WdA1sdhHQGm0eAcG0Uwxsang94vpi3jMEgeLBTM1nUEFdDatet8mwsLJddIZ0CIGTVYoADBkuf9NrJ1f3UsUMJtLy/dMOCTfrUURBBm/6mKA7P6lkcLj/z5mI2/+plE5/9TFgqrf/qYpFf/9v///9Z7////Weu6yrgjAAEShlSQAEEAJIAfotDFZDV6ROY3hlp8wDXAA3LtTINQ+BnMrhZ0DWx2EdAabR4BwbRTDGxqeD3i+mLeMwSB4sFMzWdQQV0Nq163ybCwsl10hnQIgZNVigAMGS5/02snV/dSxQwm0vL90w4JN+tRREEGb/qYoDs/qWRwuP/PmYjb/6mUTn/1MWCqt/+pikV//2////1nv///9Z57qrtSAAaAEOPo6q0VkVoBSMfBmZVHFMomra/sFv//+7IADwAEcXjR92KgAo4vGj7sVABRJeNFzHKLAiS8aLmOUWARYQFAEDoGXFeBv7iAZHHAGKwQLnD0RkkCKmpzOKUjUjUiy0nUlpOh2UUjSoc4VsAaFAMkgspOZb1de+/222v3lN9ikN8FBKOaa0lI/b/+32+TGsxIaGIRJknav9///1fSInqSWHRKS6v///6/nCEJvdVdqQADQAhx9HVWisitAKRj4MzKo4plE1bX9gt/iLCAoAgdAy4rwN/cQDI44AxWCBc4eiMkgRU1OZxSkakakWWk6ktJ0OyikaVDnCtgDQoBkkFlJzLerr33+221+8pvsUhvgoJRzTWkpH7f/2+3yY1mJDQxCJMk7V/v//+r6RE9SSw6JSXV////X84QhNqq9yGAAtDIPgN54cGQ0s4MLUdIZgz1qumUxddqEpWGZfQdAYAOR0btmDgYpm3SG6ec7wnc1aVs2dj+1bbTnyweolsigCR4Bd4UcqIoKbf1mlbVoekvRo/NT+yIW3Ci11PUfr6dTaC7b2fe/yLtUspAgFDuR53///+pvOkM14YR+pvt/+v6/koSLVV7kMABaGQfAbzw4MhpZwYWo6QzBnrVdMpi67UJSsMy+g6AwAcjo3bMHAxTNukN0853hO5q0rZs7H9q22nPlg9RLZFAEjwC7wo5URQU2/rNK2rQ9JejR+an9kQtuFFrqeo/X06m0F23s+9/kXapZSBAKHcjzv///9TedIZrwwj9Tfb/9f1/JQkVi7zplQAFIAgwMk9GmLaGUorLwS8iIOIgIHDACBpGPGPIQTeb9Ig1+zoNGAMN6Ijtv5KI3h0rZfrLVE0dZ6n/+7IAHwAEk3jRez2kEJJvGi9ntIIT3eU/7PqwQnu8p/2fVgg7IPUzJfLB65iPwTcgPIEeWDqpvvvo6N2qSs9T1fIxKtlg1Fg5Kkp6z7nWWdSqqUulspS3s9vkhqoBb8Kg7POv6///9vUQVqqgx7Xmf7f//rbyUN1Rd50yoACkAQYGSejTFtDKUVl4JeREHEQEDhgBA0jHjHkIJvN+kQa/Z0GjAGG9ER238lEbw6Vsv1lqiaOs9SdkHqZkvlg9cxH4JuQHkCPLB1U3330dG7VJWep6vkYlWywaiwclSU9Z9zrLOpVVKXS2Upb2e3yQ1UAt+FQdnnX9f//+3qIK1VQY9rzP9v//1t5KG6jmYd0IAA0gIAD4Llq2gAnFo8YQd9sJd67dV09LYmltad5GkSGPh80IAtg4NUiAWeV15W6FXRpnnczdM46C/SvZzut0SUNUjYiIywAAvA1QCg40iSbnTJdtr85/P3fO63YhxpWgiDUWgsOUjjzp+tq2+r+++jtYd2dURoFQ+LhSOZ0/Xrb/9T9Sz21xU3rrCIH1Zi9ev9/1atZ7aRwqb1nMw7oQABpAQAHwXLVtABOLR4wg77YS7126rp6WxNLa07yNIkMfD5oQBbBwapEAs8rryt0KujTPO5m6Zx0F+lezndbokoapGxERlgABeBqgFBxpEk3OmS7bX5z+fu+d1uxDjStBEGotBYcpHHnT9bVt9X999Haw7s6ojQKh8XCkczp+vW3/6n6lntripvXWEQPqzF69f7/q1az20jhU3rV7maZEAAWQDDArs+W/cFQBSysHAKdYWnzUwc2mlLOlivqupASYLMR//In/+7IAFQAEsHlRe4mkoJYPKi9xNJQSUeVF7hqSwko8qL3DUliIwQla+ytB9/jCGTwOk7YLCgqBZuy6Dc6/c4eQc0L4CDQAc0T4T5smsq7e5vm9np2bqoaspnmWgiEzoOAqU861fWtS6kamrTW703pasnfL4YpEzZ2sf+32//WnrnSY1XDcPXnP/r/q/baZjfd7maZEAAWQDDArs+W/cFQBSysHAKdYWnzUwc2mlLOlivqupASYLMR//ImIwQla+ytB9/jCGTwOk7YLCgqBZuy6Dc6/c4eQc0L4CDQAc0T4T5smsq7e5vm9np2bqoaspnmWgiEzoOAqU861fWtS6kamrTW703pasnfL4YpEzZ2sf+32//WnrnSY1XDcPXnP/r/q/baZjfdpycyVAATgBDA1ALqbMHAeBrYsAWWvHH2AywaA7BHvZmwaGmklUBEh5MPfAYCKjjZQRAGyw/4fwM8hGdB9J4CJscei+u5YLTImQ+QavAASY+iycWpPbNd999Hba+rMXrrCZ0W1StZar1utXOa91mj1O3XkCZ1SkCRAiy16n9Tfq//P+onVdYcXq02/9f9bf+P47nacnMlQAE4AQwNQC6mzBwHga2LAFlrxx9gMsGgOwR72ZsGhppJVARIeTD3wGAio42UEQBssP+H8DPIRnQfSeAibHHovruWC0yJkPkGrwAEmPosnFqT2zXfffR22vqzF66wmdFtUrWWq9brVzmvdZo9Tt15AmdUpAkQIstep/U36v/z/qJ1XWHF6tNv/X/W3/j+O543/+6UACbAYaztA4tsHCcKBx5S8EJ48ScsKkEaV3wtIwd45ACAQBij/+7IAFAAEt3hUfWKgApbvCo+sVABSgV9f+YoAAlAr6/8xQAAgAbKYoGDwWBIDlhrJuWqzTL9SbKMay9NzZaZstX1Hqz6AYYCxHFLl9Pf+tVapulmK7UWt9B61l8Neg3tQSZCrztaV88yFfW7oCbU6RmLPAOCwEggQQ0TqfapGrV//Uf9RC6EzDAiSHKL/////nREb//dKABNgMNZ2gcW2DhOFA48peCE8eJOWFSCNK74WkYO8cgBAIAxQQANlMUDB4LAkByw1k3LVZpl+pNlGNZem5stM2Wr6j1Z9AMMBYjily+nv/WqtU3SzFdqLW+g9ay+GvQb2oJMhV52tK+eZCvrd0BNqdIzFngHBYCQQIIaJ1PtUjVq//qP+ohdCZhgRJDlF/////zoi5C6lVAABQCoDYQD4ZCwVB9kTFKkiv9NQcExMLk3ipgtxrzPf8LZgdNYHsgYIPgbIgAEXEAwCgpAie4XVi5BaBlBUxSQfMO7yfQPFcsGReNjIgX0QvmASaIgQc3SJkgpqr+myNNNNJSSX/n1Hw/4CgwqkXN3qSMTVX//U2skkQuTq9JJEy/+ybvT6p1IjCCpfiL/+SuQupVQAAUAqA2EA+GQsFQfZExSpIr/TUHBMTC5N4qYLca8z3/C2YHTWB7IGCD4GyIABFxAMAoKQInuF1YuQWgZQVMUkHzDu8n0DxXLBkXjYyIF9EL5gEmiIEHN0iZIKaq/psjTTTSUkl/59R8P+AoMKpFzd6kjE1V//1NrJJELk6vSSRMv/sm70+qdSIwgqX4i//klMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+7IAAA/wAABpBwAACAAADSDgAAEAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjk5LjVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=";
  var scanditLogoImage =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUcAAAAhCAMAAAB9TZmqAAABgFBMVEVHcEyCgoL+/v6Kior///+FhYXW1tbn5+eAgIDp6en+/v6BgYH///////////+BgYH///////////+wsLCCgoL4+PiBgYH///+srKyAgID////s7OyCgoKBgYGDg4P///+BgYH6+vqBgYH////MzMz39/f///+BgYGbm5uDg4OMjIyBgYG+vr6QkJD///////+BgYGDg4P+/v7Hx8eOjo6BgYH09PT7+/v///////+MjIz9/f3////////Y2Nj6+vrPz8+BgYH9/f3///+3t7f///+Ghob///+AgICDg4P///+IiIj///////+CgoL6+vqmpqb////////t7e3////////////b29vj4+PNzc3y8vLl5eXv7+/U1NTDw8O8vLyRkZH////x8fGJiYmZmZnDw8Pf39/S0tLT09PCwsKfn5/4+PjV1dWlpaWwsLCjo6OsrKzj4+OZmZnCwsLq6uqurq7///+AgICfn5+Tk5OFhYXCwsLJycmYmJjU1NS/v79wPZvPAAAAdnRSTlMAcvoPxiTEAsby9L8p/eusNEoJBlEZ2Pb67nz25fVGOv1Eh+RW7oyC/ToXzkALzmqTe8BJHmf9Uu+n/B2Dnt7/+6MvEP2ZKrmzXHIx2dScYv6wkf3o3SL+/uDhqLbnuNrVV4u4ie7LNGlhweeUnrTsZOjkis/PjpWtfQAACfhJREFUaN7tmXlbGksWxtlMEwRUVjUgrSQqEAQccXdQQRUVVYxqoolqjGa9WW7uW25Xv/pUdxe9q2TM88zMM55/aE5V1/Lr03XeqrZYHuzBHuzB/vPmX+hzgdmcyh/sXrIx95LKPQ64/JoG5oaHHVztzya8Ssl0rV1PfO6A03YbR4xdzUBnblbgXphZm2hv+W0z9bW0+H7tjmL9d2w6VDPon7XX/CsuxR2fTcr1hervk+oWBM9KDa0bLqVys5pOn1vTrxfvG6SrCT3HpwNiS3O1Gzt/E8dN5RHVadNAsL6aXB9ch3/9zWyUdDF/Bqh8/ngm2Shpkp+QB49xEdJy3MbgW4UjaVQ42nola73ywDWt5XhKpIcWbP4h9F3CIOuOEOodiwNz4wvdDsDW/N/PMYPhb1GiGOMY82CiSeWWObYgXsI2SWo4tq7jusOco9xC7yAGF005WixOocIq1mt1eerrw/BT6/L8cu69C3Hfb+EY3NkJ/tINHOU4Vl/VORxGiTOQ9DOTVjGugrVGwmdn/Zxkcv0qds/gOS9rOa6isM+Zc3TaRUsmvhQw2WDO0Z+mNoRnpEnurgjs8RLVPeD3vNkNhMz+2h1PgZP6anrxkTT69d4hhI8IHzCpX8Eb8gyrU1qOxIHJ/A0c5XqHwL7flCOL9GdK2NMR4JRv7LJmnYQvoF2OEHcsqEpY/s1YzK1JYJy7WRu8KoeGo75iMea7iWMxdncYb6CXLBq8I5jhSd7s1YBnnxzjMqLjSDv8kb6Do8+L6556OXYCpYR41RFdbWXx2NwfBrCRYU+jOO4FgBfjEsn+8EpxZBjAHHsX9Y4Tm+3EtKLFV10CPA73SrjfwPFgA0C8KlIOusILtVmHq1pil1HOsC548YcKgMpWUOHJCtbJrJZjwwi2eu7gaGnHdlu6To4DgHdIugwQIi2+GRvwogJgRByxzwF4+vqos5uNY8EBl/Cfrad6Ry3PGCoGHYCLqr94Nxx6joceeIWqfSLzNVQkQptATE0sBk+rXU9rDJ4IKZtxnMAOCQWB0byO46YNqwN3cIzRv+U6OQauAfSNd9KJ+qMkx1SUY3M2cVIFFiQl6xqaTSQW55hkpWy8Q9zs83EgY+pQOBorDiUT9gMbYOCIjWl7YmDBI2nrFmCaxURFS2YG+JlpoRYrWpT5ewlvN+MYp4Gapbm0dV7H0dKN9ak7OAaB8+U6OXaQkihgPX3jsY5yQkqJS05BWkQ+SbN14FGbkIe+ApvC/8dAZxP18IMYsZg5ngP/MPPHgD9C9K9zBXis5+j9FhL6fCMmu2R0kAV/BaWs9h3eqclf20RQntInkjLD6IYtRAKU2WQbp+NY9KK0eDtHH3CWqpNjmieRz2vDAABHjEVTiU6Izqr3pbgiruydET6Vip6yMHuMV07SluLJJfotZg6Fo9Y/gieERFNREnlm5PiIF6uSdZH5/DXinCQsRxM6OB8vtx6/evXKBWyM1Rb5T2TeXG06hEBtwSBJ6DjSMkGM38axCJxH6uRoyRFCUl0fMmthwNYpvVKjTtpPQ5YQq1Cjh0QD6WBn+6DMcbKNSgx77hqvLCYOTuGorVihOSLAWfzl6JWR498hGh1+K3+JPmG5GZVE2DiuQoaskuNrSvl7ks3fRabMOK5hh1AwPhvOcnqO/iVcBG7lOA2Qtno5WqziS8ununY8GKbL5AIKKTFL+UNSo87zR3PDAFwyngsxH3HvGA294/kNFV0oSYmsfGHkOCohyZcQFm6JbGFClDmrVhOBmlueorZvw1d7bSFrMtP3w/iDCDuefpQa9Ryp5Cvs+2/jeEDDvN54PDhwp/NNIkryUsyNhyiw5Jbo6hHerT/D8DjoOcY3Gc9LqfyRzFHjUMWj1m/DOza/SSPHI1b0Djah055V4aE2Y5BP3iwmd3GdZenktNGkPAZXRNQg7diKpvUcKd0r620cZ/CT1Ls+VsTHzi3mm6LkTEzQfwIDTH0HBS0edGEuaEl25H7IeB7pOWodz2+o+ATHrNfvRo4f2OUxnoh6jB/EEE0QF/O3iPIFXPED0so7GTEpb0c/ifpFoAWm6dQcm4GvJzdz9HvxhkzVyXECGyyTpXtOgRaR41BtGC6fEN04mhcCtrdOjtxNHK/wTOoraDNyPGSXn7Al/s5fYI2L4yxwC8cqXksCrxOF0QFjeT8FIULyu9DbZeBI8W9/uZnjAsIhYq2T4+eauhZDoUAfWm4d0jGn7wXWRJoFKlWWc4Hde8YjtwqssPmb6J4iGx1axd4DZx5bC7Yj/lvOOV9QTlL+6MNWzlhuw0diZQnnOmXkOBbGxY0cm13YIaShTo6hLWBElLxjM8Ak7TWwCqwVhT0c0MlZuCFgj65RxRkAT+8Vj6lteDJFy2YVg0aOWKKj4IbC2JYStJBp4mjtugXjGuIptuGYtmHLsDlvQTwqbca5DLblhVbhSOVA4QaO/swwlt6qovMOjsvnTwDEHf1LAK6ERWSRXILKcscwcCEsLuV1YGNuyePZGUR84T7rY9PoNoBhYK5k5HgMvOinZetnbEWkmQaFc/3BUay7ZmteeN4TnhEZssE2Mt4uGdubd2OXtNWOx2znASPHohdajp7J1xOC9dOCjSOiUp13cCwT8qbCDunfED4typ2/Kh4AG19FcZs72wLgWWpZvgBm7hOPHYTfcYRRqWav8d2gezJxAN7dc8LmK2SaSacxdSjmfR+R8wD3YVspcFnYy/5Gnmkcq8tGjpYMUFBzVMy2+5aQrKVejtw8IVPPYysrnSdZQpbZeUVTsjkWzBK+Q/p7FIv57LT47AMnngazl62Hhb3eUTs3M1RsJHw+WaQCf7KmiJgtEkJCs+7OzUBUURpvCzg1nIV1zhz/U7KXexFCInJ24QK915evWdGUsFhy1eq+fJiW2V0NmXDkltQcgzPHl5OvBXu5N0p4MsXVzdFiTwnbWmdjiCeE3ZcVZLmTpmjxZMkeIiREi/muCIlY78Nx+nCPtkzbfevCnp7jMh1FY5uAU0mB64roU0z+fEAHPK+e2WKjUiChsfNKnlCug+6owrH45YyopGde9W0ipJEKY8+JlqPffaTZz3DlkHRfY7mGPyBAldtpmBfGFuqgOMRA//c5Al+cUT6UnVG+M8kcB/I0vEjblDxW3xJKyybppcNas7J+8Wwo14qkoSfzqnjOW2WmbUQRSemImuOs3HhA33iS53VP1Up0m6iBRLncodFf6cWEah+RTCTEJhpmuXt9cHAgXG3pzPQDJbM8PKsaQ7W9D4PniYfP9Sa2mPsJAMBwyfQjgNqGgfBp6IGZKUfCf1vonmkfWiZt9ru+r1bb9++E/f9qThLNBhL5RkKsd1XN9qRIJP2AzNTSTdLJYVv+znWWZu7ow+p4ow1Ys3Snnry7Yj5rHfjfmda/AA1uqYyEPVX6AAAAAElFTkSuQmCC";
  var laserActiveImage =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuwAAAAvCAMAAACPHW/9AAAAwFBMVEVHcExUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFVydJUyNFUyNFUyNFUyNH8/v5UyNFUyNFUyNFVydJUyNFUyNFUyNFVydJUyNFVydL3/f1YytNUyNFUyNFUyNHx+/ve9fbp+PnR8fNUyNGF2N9009q15+uW3ePD7O+l4+dv0dlv0dj///9Ujp4pAAAAP3RSTlMAiXJnBFsIARM5oA1+UKsuG5W3JEULBishQj5iAm0QkTQZ/h5MF3snWISbSHb8plMFjfjv9Oeyua3Ww9/Nn4y/IgemAAAIrElEQVR42u2da1saOxCAq8jRVuql0qOVIgcvgHhBrBbUYv//vzpzySSTZBeWqo8fOm+E9Vv3eXxnOptNJh8+vD3rhvFC3lHR73/GmmEsxdKKVY+N3ONFN3OT8O+S/GMYnmXtid0rCJAy7b3nrPDyQn5dnk3DiFnaoeJ4Ife98ZnqTnTSPHZ38R0ezWPDMF6BeY6lseK0F+Ej3Vl1MJ1EZ78rmXrmBvxWTLcCO4axU8WUEsk2nIMhJsh6Et75HnQn10l1NB093xB9F9p4UsBBKXuGsQSlIuXSScSQ/Og8Ch9097aT66I6mo6S74i1c++mn7G/v4+fQrYNYymKPWLBEvEkOtD7LhoPvmN+R93R9sR1UR1FR8n7/cqS/oejjI+G8UIyqbb9NQ4NtB6MJ99J99j2deU6q35AnrPDFew99FcY+MN8K6VpGHMpVecwQL5p/1h+dL6/Bwm+i9k92M6yY2IPrpPqaLqT2omrR7hk9l4ETvEHRuAzD8OogNNFgUpd8DeRhgYGACkPvqPuO5jc2XZM7SGxK9dRdRSdknNicIy+Ey/xyDMYDRR1dzGMaihrHKCUxweFhALpD8qj76Q71jLOdknt6y6xB9dZdRCddU4ibpSgdA606q2cWqtWq7VqfDWMUpwk8BVRd99xPHAYkP6oPPkOurPtVMlwaneyU2KHZ1NxHVVvXqDm3uXC0GuR1Nrr+J7bODyr9IGByNUwYtr+wrYEgcClJCZ0FJD6YDz5Drqz7Vi3U2oX2amKgcR+1nWuk+okelmOrmVWB6XxVi9xBHpFNHoNw0gpUkU8WsUfCYoQBLW2uA/Cj0aQ353tBydcyHAdQ8+na5TYsYg52GPXUXUwnbXW2TnC/atKbO+x47xxnrFiGBXIxEGbkoCQAHD2k/CgO2T3JtkOT6ldl9q17JtUxOz1xXXM6WC6N5qVVtm6B2ZfRmrnPo9Xxkxn3InYlWEYGudFDOjDpHEAyin7UXoQnnVn27mQodQusksVw0UMuj6CrM6mU7ZO/6ehIFNZ28uNXjudFUPNJxz8ZRgxw09eDbgEQCEdERwCSn+X+EF48B11B9uxkqFCZmNjk4t2/3xKFTsl9m9Ndh1N7zUa5eWHZO1Y7qFzW+7/GgZ+AVvXW1v0RR/DKMGZgldAFJKAcP7vDhP30fkG6I7ZnWynQoZS+9ev/ISKz6euioHEDkWMdx1UJ8Wdz+NOqEZU1vaJW9ntxBZ+5nzhYRgJJEYBKhQoAjL3wXr0nXRH20+bnNpdHQNPqCQ7VzGS2C9GXnUQncQe+nyNZcjsegZMZ1NgMp0Aj8Av5AF5Qu6RH8wdcctcBY49v42/m6CC8oN8YXnu2CSyivwi01A5dO8RJZxMp+jl8/Pzee+yXasPJLV3pWj3slMVgxV78xTyunN93KG8HWoqjKkZfKZb06A6u462P4DtTyT7Pdn+g3S/I9tvyfYrHInpJPvxbzP+79Qc//BBddEdPLm9cvmRZCfd78t0d7ZP2fbn3mq7VcfU7uqYWPYjnnekKmYAiV1cZ9W5MnGmo+jadQotSuwPvySxR64H1dl2dh1/LLMbLHyku8/sV2z6rU/tJPvTvbhO1cSjtx2E5NzeoNT++SLUMaWy1yPZOZ+L7VtTlP3ndPqFbJ9M0irmKVQxktddYpfMTrofp5ndMNlF9WNnep7ZXWIH2x+C7uT6Y5zaWfZvy8o+lPIF8/oW6z5F3Sec2UNiDxX7vS7Z7+6KqhjU3TK7kVTsKrOz7XeuaM/KGK5iojpmSmU7uT43s0c1Oz2fNs7P8elUlewzrGJwkO6+Yp/oil1ndl2ySxnjXD9OUrv9vU12pzqNUMWEZ9TwiPoUinYpYySzu0dUKmNKa3Y9G0MTj5doO0/G4BzMDAZ+fZrRXEw0FePLmHQu5l5l9rRmvzLZjeLUfhW7ns3GJM+nfj5mqlzHB9Ti2Zh8nr2l5tnjF/67qL9+PxomJYd6ziZ6bVQwz24Y5XPt2SQ7jvDGiebZr7Np9irz7Okb1IvsDeqKjNIXqJ3s/elQvWOS6Rz1psneoRrlL1D16yN+gxpeoPplBLslb1BXy9+ghrUx3cK1Mb2CtTGN4oWMWv6Ol1/nfnkvRStkeJmMrZExooUxTo4E8kjWioXFYdHSsEZj0dqYSqseLwuQNY9h0WMjW0Yz9sTrHnnFY0fu3jCcCR2vc77ocbwyztf/hmWPbtVjbf6qR1nP3o3Xs9fdevaa3yeithz5bRpxMMT6Fy1o53vlj61tN+I17JEX2Xr282SDh9/TIbs5eD37YDRvPXvpTqV6vcI+Jdou5f1XWzr0fwL5ZiW+a9uZY0T7lBpzNioFsfVOJdr9WXGnkt+DulG+B7Vk+3eyZa+m4qCdbEBVwWCbT41Ke1H1/tOgdbtoE6reg3qa7kHd1HtQo+4Ce2l3gfLeAoO4X0YSBfWstUAr7Bo3jMXtBdiatMGA7i5Qj3pshO4C4rokdtVdwPeNOYv7xnD7o6W6xnzWoTBIWsdwRFjrGGNBw5ikT4YyelDaN+ZU+sYcUp+k4r4xlTqCHc7radcsagiWBINvCGYdwYxqHcFO855g1BWMWs2VtwRTHcHQ9aOoI9jcXo/S3NEP/3tOHBSuRV4WGNbq0ajW7DFr+Mg9F2Oy5qfS6/Eg9HpUib2ki+8ed/HtL27iK91PS9ugWhtf4zW6+H7MO/lux518ky6+2vWsZ3VRf/ZqzdnD70l39m1rz268eoN2TML9/Vi90J/9ZE5/9kUnbyx77gYOfdqGHbxhvPLRGycFZ2+EkzfO+LQZOXnjZi0/Z6boTKVFJyrJLy84UcmOVDJefqhSctDYnDOVotPy3GGQ1Q7LO8JhZ+UZ731cHoqojsuT0/Ju1uYeDpmfg/pmp6DaMajGWx2EOvcc1OTg32oHXN+89HxrO+DaeNMjrqsd7M5Huxfy/Y9ZM4wlWVoyZ+mHd2LdMF7Ma5j4P+hE04Z78rHKAAAAAElFTkSuQmCC";
  var laserPausedImage =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuwAAAAvCAMAAACPHW/9AAAAYFBMVEVHcExUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFUyNFTyNFUyNE9ws1UyNFUyNFUyNFTyNFCxM5UyNFHxc9RyNE5wcwd5ZO7AAAAH3RSTlMAZ35yAQgbBAwTI4lbRDmUoKtQLrc080osVZvhKMyyq5oARwAAB8JJREFUeNrtnYtS4koQhhUENRFRRBQRff+3PNP3nktCRHbPqTr9T5jErdrVrfr6t5PMdF9d/XndhEK/1H8T0dtQ6K/ol7FxAWIX+Veh0AVVoLaYEAojoP8C1btQ6O8KmBsPiSbwnvSfsHvPB4w7ucBhRyh0EQlROgw5/kKjwDNf4G6ke8yngrrkaYmDr+hIk35CoXPlOKJTAZxQSCHhiK9xV9aFdKN3BNNOJ5w7nTs60tR1PIdCZ2pp52VHXC3lBMh1SqEGBjHPvJe056gj6UsFt6HPdMAH5s9K73zQ9I6Tnlp6CYVqGSCf/hK4+pQTq6OJg4KQF+AVdzV2Yt2jjlDjP1ux2cLzFUZTj3A8hkLn6JXn1yEReRofSD0gT7wb7WLtjnVGHTkHpo3YbIxrBccKjlDoskKucLQiA+lPzAPw7O6OdoNdWGfUCXSBtxhyKnh+g5GEU0sbGqHQKb1tGJYBlFY854EgyL+8GO5CO8HOxm6sA+oIOsEsDBffqODYaZ+OfTpMD6HQWdrLKQ0T8JWFhqIJzAPviHuDdjV2ZZ1RB9ALjgXmzd7jDD/S/qFG+pqGnUKhn+iBJkUojToaLAwIe+Q94f5utJewo7Ej68nWkXTkfIov489AP5PTPA0+zfmY21eh0KgEE4GHh2DlwsFHAQAvuCvtYO0edjV29HVgnUh3/vxwPeLOAnGB8awcIrsKhXLNGY+5Xs95QqJ8PABzHn5kHnh3tDtrB9idsad7U2adSDeY9eCpsueZwV2r7+lInxme+15OoVCtmcwzZgYpqoOCsWP6EXjAHdw90Y53qWbtBjsbO7KebF1QL3Cm06yJdT9jlBXjNQ1/QvEpFCrUu6t+vc4B8rEAmOX0E6CKO3q7WbvBTlmMJOyJdUad4B6U0t0b3X2J8sdHOgo9PcGUBkyhEIphIELwYK1pAph8LHj6e3Z/wZ1p50SG8pgbn7KzsaccZg+oK+gDCcea4e6N7g+Hdv4feYYRCv1IT8/PRE4WExYEAr/aPvGutIu1Ux6T7lARdjV2TGI2zDom2y4d6UvTZr4rujOwv56/vvQj2tIIhTIxGIUSRIkeHwQV/Agj8Q7unmgvrL2GHZMY9nVCvfDrD8k8GGTgFnQUHY4H067SN4xv/IRCA9p9IyeAS6bDzthKpJG2RwqTFAxA/pp4v0bazdqHYSfWGfXCs51tM+nHLX5LZZ1x38kwzr9tootQqME5kQFnYl5QJ6CYdcOdgUfchfaUyoC1D8LedZTFJGNnX/eoU9b95HMTJn0rpAPqauye853EKYNunAfvoYx0vVJ3d/Z+8N5+VNq3Ge2QzaC1b+DxI+Qxbdg/4fZ0442dWLc7BYe6ZNyKumd9dyh8fWesh7OHTno7o54lM4ec92OWyhydtc+asN82nV1gtyTm+Snz9crYt01nrzj3pLfiOfQ/t/WdT9kbeXuGepbFHC1td87+yrDfD+bslsb0RcpON8HFvamzdkvZd2buyrsDPjtCoTx/cfeombET621nB9iJ9fWUnL28QeU71LU+hDHuFXez9/phzO7QeBKzC7xDU4DftY39MJTDoK9Lyi6wjz6NyZ6zu/dJ/Oq2krzcGnvOrnGhj9jtcvu1jSfuoS8/CIniYXv1tql6zN54zr5qP2fP36Bu9rJYYKbvlXgZV/0a1cVA/TRen+M82Q1uvEkNTXt7ys9F+Jax8Qb1w1bU9PIGdT72BvXU2pjB9bi6irGIgew3QGthDK16gGiIpTEhvzYGgfjQ1TFea8d2c21MP2VtzPCqx2LRY75GvV726NaEzZr+H2sdQ+csg2xxravF3YrfYtXjamDV4/B69odsb4Yuma83G7UX/orzZxexkj00bU27QqMI5dt/5oJ4vqB9bD37lJ1KugHK9gaWW/Aa2zlm/heBj4LYqRQa36k0L7ZoCNSzYqOS36pEG5XGdypN2YO69xtc29uqiyiY2xanYkfhtW0zDIXG9qEaN5JdtPZku53Y+/3pPagj1QVaVT2stMCD1hfgKgMaAdmmcPndEAqdridwnW13tu3PVYGBPeKt9QVcdYHHkeoCi2bdGKuB9DasRuWjfVYzBn4U/o3gym5w0YIoKRNqFYmRCyOmVF43hsopcbEkrJPUrhszXBFMC4LVFcHa4npKqywWaJKIeMvLPoVCw0XB+PxWFwdbYTmwt6o4nlQEex+oCCbWPlbr0RcqxWqTUgGyVebRRUUodPFqj4JYWfDxNav1WLBusOdVfJdVFd/091/k896q4Gs1VduFfF1J1KjoG5pUvZeReR2u4fviSvm6Mr6uii+zvrAqvpzHtOqzj8nXZu/qQu3D9dijPHvoRGn2F/XUkpbPrDC7VWdnyLVA+1B99qrzhnaPmdwehnsgVO0Lou9G6A904ei6svdG1XhDSF8M95nJeyqdbKR0r81tfI8buaBQuY+OSqFLNVVSsvyF76zkQB/oqZThzt3ysPHeYqRDnmtTZh3yrK0Zf+7sD0KhczvkOYQyohyM2jAvsbsY65ZX9UFd/KAP6p2c7vwVd6ksm1ZG787Q+V1P2X4BOYKNDfzOMETKF+N9UH/V4XpRNB1e6BdFM1b+hEKT+lkLLbd5P1+meZGBVzZX/0Fjdwf+dN3+pg98KPRDjbF49S/pJhT6tS5B4j8UFQCShr1YqAAAAABJRU5ErkJggg==";
  var cameraImage =
    "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0xNyA1Yy0uOCAwLTEuNC41LTEuOCAxLS40LjUtLjcgMS0xLjEgMS41cy0uNiAxLS44IDEuM2wtLjMuM0gzYy0xLjYgMC0zIDEuNC0zIDN2MjdjMCAxLjYgMS40IDMgMyAzaDQ0YzEuNiAwIDMtMS40IDMtM3YtMjdjMC0xLjYtMS40LTMtMy0zSDM3bC0uMy0uM2MtLjItLjMtLjUtLjctLjgtMS4ycy0uNi0xLTEuMS0xLjVjLS40LS41LTEtMS0xLjgtMXptMCAyaDE2Yy0uMSAwIC4xIDAgLjMuM3MuNS44LjggMS4zLjcgMSAxLjEgMS41IDEgMSAxLjggMWgxMGMuNiAwIDEgLjQgMSAxdjI3YzAgLjYtLjQgMS0xIDFIM2MtLjYgMC0xLS40LTEtMXYtMjdjMC0uNi40LTEgMS0xaDEwYy44IDAgMS40LS41IDEuOC0xcy44LTEgMS4xLTEuNS42LTEgLjgtMS4yLjQtLjMuMy0uM3ptOCA0Yy03LjIgMC0xMyA1LjgtMTMgMTNzNS44IDEzIDEzIDEzIDEzLTUuOCAxMy0xMy01LjgtMTMtMTMtMTN6bTAgMmM2LjEgMCAxMSA0LjkgMTEgMTFzLTQuOSAxMS0xMSAxMS0xMS00LjktMTEtMTEgNC45LTExIDExLTExek04IDE0Yy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMmgxYzEuMSAwIDItLjkgMi0ycy0uOS0yLTItMnptMTcgMWMtNSAwLTkgNC05IDlzNCA5IDkgOSA5LTQgOS05LTQtOS05LTl6bTAgMmMzLjkgMCA3IDMuMSA3IDdzLTMuMSA3LTcgNy03LTMuMS03LTcgMy4xLTcgNy03eiIgY2xhc3M9ImEiLz48L3N2Zz4K";
  var switchCameraImage =
    "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yNi4xNCA4YTQuOTkgNC45OSAwIDAgMC00LjE2IDIuMjI3bC0yLjIxOCAzLjMyOGExLjAwMyAxLjAwMyAwIDAgMS0uODMyLjQ0NUgxOHYtMmMwLTEuMTAyLS44OTgtMi0yLTJoLTZjLTEuMTAyIDAtMiAuODk4LTIgMnYySDVjLTEuNjUyIDAtMyAxLjM0OC0zIDN2MzZjMCAxLjY1MiAxLjM0OCAzIDMgM2g1NGMxLjY1MiAwIDMtMS4zNDggMy0zVjE3YzAtMS42NTItMS4zNDgtMy0zLTNoLTN2LTFjMC0xLjEwMi0uODk4LTItMi0yaC0yYy0xLjEwMiAwLTIgLjg5OC0yIDJ2MWgtNC45MzhhLjk5Ny45OTcgMCAwIDEtLjgyOC0uNDQxbC0yLjI1NC0zLjM1MkE1LjAwMSA1LjAwMSAwIDAgMCAzNy44MjggOHptMCAyaDExLjY4OGMxIDAgMS45MzQuNDk2IDIuNDkyIDEuMzI0bDIuMjU0IDMuMzUyQTIuOTk4IDIuOTk4IDAgMCAwIDQ1LjA2MyAxNkg1OWMuNTUgMCAxIC40NSAxIDF2MzZjMCAuNTUtLjQ1IDEtMSAxSDVjLS41NSAwLTEtLjQ1LTEtMVYxN2MwLS41NS40NS0xIDEtMWgxMy45M2MxLjAwNCAwIDEuOTM3LS41IDIuNDk2LTEuMzM2bDIuMjE5LTMuMzI4QTIuOTk4IDIuOTk4IDAgMCAxIDI2LjE0IDEwek0xMCAxMmg2djJoLTZ6bTQyIDFoMnYxaC0yem0tMjAgNWMtNS4yOSAwLTEwLjI0NiAyLjgzNi0xMi45MzQgNy4zOThhLjk5Ni45OTYgMCAwIDAgLjM1NiAxLjM2OC45OTcuOTk3IDAgMCAwIDEuMzY3LS4zNTZBMTMuMDY1IDEzLjA2NSAwIDAgMSAzMiAyMGM3LjE2OCAwIDEzIDUuODMyIDEzIDEzIDAgLjE4OC0uMDE2LjM3NS0uMDIzLjU2M2wtMi4yNy0yLjI3YTEgMSAwIDEgMC0xLjQxNCAxLjQxNGw0IDRjLjE5NS4xOTUuNDUuMjkzLjcwNy4yOTNhLjk5My45OTMgMCAwIDAgLjcwNy0uMjkzbDQtNGExIDEgMCAxIDAtMS40MTQtMS40MTRsLTIuMzIgMi4zMTZjLjAxMS0uMjAzLjAyNy0uNDA2LjAyNy0uNjA5IDAtOC4yNy02LjczLTE1LTE1LTE1ek0xOCAyOWExIDEgMCAwIDAtLjcwNy4yOTNsLTQgNGExIDEgMCAxIDAgMS40MTQgMS40MTRsMi4zMTMtMi4zMTZjLS4wMDguMjAzLS4wMi40MDYtLjAyLjYwOSAwIDguMjcgNi43MyAxNSAxNSAxNSA1LjM2NyAwIDEwLjM2LTIuODk4IDEzLjAyNy03LjU2M2EuOTk5Ljk5OSAwIDEgMC0xLjczNC0uOTkyQTEzLjA0MiAxMy4wNDIgMCAwIDEgMzIgNDZjLTcuMTY4IDAtMTMtNS44MzItMTMtMTMgMC0uMTg4LjAxMi0uMzc5LjAyLS41NjZsMi4yNzMgMi4yNzNjLjE5NS4xOTUuNDUuMjkzLjcwNy4yOTNhMSAxIDAgMCAwIC43MDctMS43MDdsLTQtNEExIDEgMCAwIDAgMTggMjl6bTkgMmMtLjU1NSAwLTEgLjQ0NS0xIDF2MmMwIC41NTUuNDQ1IDEgMSAxIC41NTUgMCAxLS40NDUgMS0xdi0yYzAtLjU1NS0uNDQ1LTEtMS0xem01IDBjLS41NTUgMC0xIC40NDUtMSAxdjJjMCAuNTU1LjQ0NSAxIDEgMSAuNTU1IDAgMS0uNDQ1IDEtMXYtMmMwLS41NTUtLjQ0NS0xLTEtMXptNSAwYy0uNTU1IDAtMSAuNDQ1LTEgMXYyYzAgLjU1NS40NDUgMSAxIDEgLjU1NSAwIDEtLjQ0NSAxLTF2LTJjMC0uNTU1LS40NDUtMS0xLTF6Ii8+PC9zdmc+Cg==";
  var toggleTorchImage =
    "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0zMC45MzggMWMtLjQ0Ni4wMi0xIC4yMy0xLjMxMy42NTZhMS4zMDIgMS4zMDIgMCAwIDAtLjA2My4wOTRsLTYuNzggMTIuMDYzLS4wNjMuMDkzYy0uNTU1Ljc4NS0uNzI3IDEuNzMtLjU5NCAyLjY1NmwtMjAuNSAyMi41NjMtLjAzMS4wMzFjLTEuMDcgMS4yMTktLjY2NCAzLjAxMi40NjggNC4xNTdoLjAzMmw0LjU5NCA0LjU5M2MuNTcuNTcgMS4yNjUuOTUgMiAxLjA2My43MzQuMTEzIDEuNTQ2LS4wNTUgMi4xNTYtLjU5NGguMDMxbDIyLjU2My0yMC41Yy45My4xMjkgMS44Ny0uMDQzIDIuNjU2LS41OTQuMDItLjAxNS4wNDMtLjAxNS4wNjItLjAzMWwuMDYzLS4wMzEgMTIuMDMxLTYuNzgyYy4wMzEtLjAxOS4wNjMtLjAzOS4wOTQtLjA2Mi40MjItLjMxMy42MzYtLjg2Ny42NTYtMS4zMTMuMDItLjQ0NS0uMDk4LS44NC0uMjUtMS4yNS0uMzA1LS44Mi0uODI4LTEuNjktMS41MzEtMi42ODctMS40MDctMS45OTItMy41MTYtNC4zOS01Ljc1LTYuNjI1LTIuMjM1LTIuMjM0LTQuNjAyLTQuMzEzLTYuNTk0LTUuNzE5LS45OTYtLjcwMy0xLjg2Ny0xLjIyNi0yLjY4OC0xLjUzMS0uNDEtLjE1Mi0uODA0LS4yNy0xLjI1LS4yNXptLjIxOCAyLjAzMWMuMDc4LjAxMi4xNTMuMDI0LjM0NC4wOTQuNTIuMTkxIDEuMy42MzMgMi4yMTkgMS4yODEgMS44MzYgMS4yOTcgNC4xNjggMy4zNTYgNi4zNDMgNS41MzIgMi4xNzYgMi4xNzUgNC4yMzUgNC40NzYgNS41MzIgNi4zMTIuNjQ4LjkxOCAxLjA5IDEuNzMgMS4yODEgMi4yNS4wNy4xOTEuMDgyLjI2Ni4wOTQuMzQ0TDM1LjEyNSAyNS41M2EuOTQ5Ljk0OSAwIDAgMC0uMTI1LjA5NGMtLjMxNi4yNDItLjg2LjMyOC0xLjQzOC4yMTlhMS4wNTYgMS4wNTYgMCAwIDAtLjE4Ny0uMDYzIDMuMTEzIDMuMTEzIDAgMCAxLTEuNDM4LS44MTJsLTYuOTA2LTYuOTA3Yy0uOTc2LS45ODQtMS4xMjktMi40MzctLjY1Ni0zLjA2MmEuNTMyLjUzMiAwIDAgMCAuMDk0LS4wOTR6bS04LjIxOCAxNS41OTRjLjE5OS4yOTcuNDMuNTg2LjY4Ny44NDRsNi45MDYgNi45MDZjLjI2Mi4yNjIuNTQzLjQ4OC44NDQuNjg4TDkuNTMxIDQ2LjkwNmMtLjA4Ni4wNzgtLjI1NC4xMzctLjUzMS4wOTQtLjI3Ny0uMDQzLS42MjktLjIyMy0uOTA2LS41TDMuNSA0MS45MDZjLS41NTktLjU2Ni0uNTYzLTEuMjYxLS40MDYtMS40Mzd6bS0yLjg3NSA4LjMxM2MtLjc3IDAtMS41NDMuMjkyLTIuMTI1Ljg3NWwtMi4xMjUgMi4xMjVhMy4wMjMgMy4wMjMgMCAwIDAgMCA0LjI1IDMuMDIzIDMuMDIzIDAgMCAwIDQuMjUgMGwyLjEyNS0yLjEyNmEzLjAyMyAzLjAyMyAwIDAgMCAwLTQuMjUgMy4wMDIgMy4wMDIgMCAwIDAtMi4xMjUtLjg3NXptMCAyYy4yNTMgMCAuNTE5LjA4Mi43MTguMjguMzk5LjQuMzk5IDEuMDQgMCAxLjQzOGwtMi4xMjUgMi4xMjVhMS4wMTQgMS4wMTQgMCAwIDEtMS40MzcgMCAxLjAxNCAxLjAxNCAwIDAgMSAwLTEuNDM3Yy40MjItLjQyMiAxLjY5OS0xLjY5NiAyLjEyNS0yLjEyNS4xOTktLjIuNDY1LS4yODIuNzE4LS4yODJ6Ii8+PC9zdmc+Cg==";
  _objectSap("keys", function() {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });
  var keys = _core$1.Object.keys;
  var keys$1 = keys;
  var abs = Math.abs;
  _export$1(_export$1.S, "Math", {
    hypot: function hypot(value1, value2) {
      var sum = 0;
      var i = 0;
      var aLen = arguments.length;
      var larg = 0;
      var arg, div;
      while (i < aLen) {
        arg = abs(arguments[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else sum += arg;
      }
      return Infinity === larg ? Infinity : larg * Math.sqrt(sum);
    }
  });
  var ITERATOR$8 = _wks("iterator");
  var TO_STRING_TAG$1 = _wks("toStringTag");
  var ArrayValues = _iterators$1.Array;
  var DOMIterables$1 = {
    CSSRuleList: true,
    CSSStyleDeclaration: false,
    CSSValueList: false,
    ClientRectList: false,
    DOMRectList: false,
    DOMStringList: false,
    DOMTokenList: true,
    DataTransferItemList: false,
    FileList: false,
    HTMLAllCollection: false,
    HTMLCollection: false,
    HTMLFormElement: false,
    HTMLSelectElement: false,
    MediaList: true,
    MimeTypeArray: false,
    NamedNodeMap: false,
    NodeList: true,
    PaintRequestList: false,
    Plugin: false,
    PluginArray: false,
    SVGLengthList: false,
    SVGNumberList: false,
    SVGPathSegList: false,
    SVGPointList: false,
    SVGStringList: false,
    SVGTransformList: false,
    SourceBufferList: false,
    StyleSheetList: true,
    TextTrackCueList: false,
    TextTrackList: false,
    TouchList: false
  };
  for (var collections = _objectKeys$1(DOMIterables$1), i$2 = 0; i$2 < collections.length; i$2++) {
    var NAME$2 = collections[i$2];
    var explicit = DOMIterables$1[NAME$2];
    var Collection$1 = _global[NAME$2];
    var proto$1 = Collection$1 && Collection$1.prototype;
    var key;
    if (proto$1) {
      if (!proto$1[ITERATOR$8]) _hide(proto$1, ITERATOR$8, ArrayValues);
      if (!proto$1[TO_STRING_TAG$1]) _hide(proto$1, TO_STRING_TAG$1, NAME$2);
      _iterators$1[NAME$2] = ArrayValues;
      if (explicit)
        for (key in es6_array_iterator$1) if (!proto$1[key]) _redefine(proto$1, key, es6_array_iterator$1[key], true);
    }
  }
  var $find = _arrayMethods$1(5);
  var KEY = "find";
  var forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  _export$1(_export$1.P + _export$1.F * forced, "Array", {
    find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  _addToUnscopables$1(KEY);
  (function(Camera) {
    (function(Type) {
      Type["FRONT"] = "front";
      Type["BACK"] = "back";
    })(Camera.Type || (Camera.Type = {}));
  })(exports.Camera || (exports.Camera = {}));
  _export(_export.S, "Array", { isArray: _isArray });
  var isArray = _core$1.Array.isArray;
  var isArray$1 = isArray;
  function _arrayWithoutHoles(arr) {
    if (isArray$1(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    }
  }
  var arrayWithoutHoles = _arrayWithoutHoles;
  var _createProperty = function(object, index, value) {
    if (index in object) _objectDp$1.f(object, index, _propertyDesc$1(0, value));
    else object[index] = value;
  };
  _export(_export.S + _export.F * !_iterDetect(function(iter) {}), "Array", {
    from: function from(arrayLike) {
      var O = _toObject(arrayLike);
      var C = "function" == typeof this ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : void 0;
      var mapping = void 0 !== mapfn;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
      if (void 0 != iterFn && !(C == Array && _isArrayIter(iterFn)))
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++)
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++)
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
      result.length = index;
      return result;
    }
  });
  var from_1 = _core$1.Array.from;
  var from_1$1 = from_1;
  var ITERATOR$9 = _wks$1("iterator");
  var core_isIterable = (_core$1.isIterable = function(it) {
    var O = Object(it);
    return void 0 !== O[ITERATOR$9] || "@@iterator" in O || _iterators.hasOwnProperty(_classof(O));
  });
  var isIterable = core_isIterable;
  var isIterable$1 = isIterable;
  function _iterableToArray(iter) {
    if (isIterable$1(Object(iter)) || "[object Arguments]" === Object.prototype.toString.call(iter))
      return from_1$1(iter);
  }
  var iterableToArray = _iterableToArray;
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  var nonIterableSpread = _nonIterableSpread;
  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }
  var toConsumableArray = _toConsumableArray;
  (function(CameraAccess) {
    var backCameraKeywords = [
      "rear",
      "back",
      "rck",
      "arrire",
      "trasera",
      "trs",
      "traseira",
      "posteriore",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "arka",
      "achterzijde",
      "",
      "baksidan",
      "bagside",
      "sau",
      "bak",
      "tylny",
      "takakamera",
      "belakang",
      "",
      "",
      "spate",
      "hts",
      "zadn",
      "darrere",
      "zadn",
      "",
      "stranja",
      "belakang",
      ""
    ];
    var cameraObjects = new map$1();
    var getCamerasPromise;
    function getCameras() {
      if (null != getCamerasPromise) return getCamerasPromise;
      var browserCompatibility = exports.BrowserHelper.checkBrowserCompatibility();
      if (!browserCompatibility.fullSupport)
        return promise$1.reject(
          new CustomError({
            name: "UnsupportedBrowserError",
            message: "This OS / Browser has one or more missing features preventing it from working correctly",
            data: browserCompatibility
          })
        );
      getCamerasPromise = new promise$1(function(resolve, reject) {
        var accessPermissionPromise = promise$1.resolve();
        if (null == CameraAccess.mediaStream)
          accessPermissionPromise = navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        accessPermissionPromise
          .then(function(stream) {
            if (null != stream) CameraAccess.mediaStream = stream;
            return enumerateDevices()
              .then(function(devices) {
                var _console;
                var cameras = devices
                  .filter(function(device) {
                    return "videoinput" === device.kind;
                  })
                  .map(function(videoDevice) {
                    if (cameraObjects.has(videoDevice.deviceId)) return cameraObjects.get(videoDevice.deviceId);
                    var label = null != videoDevice.label ? videoDevice.label : "";
                    var lowercaseLabel = label.toLowerCase();
                    var camera = {
                      deviceId: videoDevice.deviceId,
                      label: label,
                      cameraType: backCameraKeywords.some(function(keyword) {
                        return -1 !== lowercaseLabel.indexOf(keyword);
                      })
                        ? exports.Camera.Type.BACK
                        : exports.Camera.Type.FRONT
                    };
                    if ("" !== label) cameraObjects.set(videoDevice.deviceId, camera);
                    return camera;
                  });
                if (
                  cameras.length > 1 &&
                  !cameras.some(function(camera) {
                    return camera.cameraType === exports.Camera.Type.BACK;
                  })
                ) {
                  var camera = cameras.slice(-1)[0];
                  cameras[cameras.length - 1] = {
                    deviceId: camera.deviceId,
                    label: camera.label,
                    cameraType: exports.Camera.Type.BACK
                  };
                }
                CameraAccess.mediaStream.getVideoTracks().forEach(function(track) {
                  track.stop();
                });
                (_console = console).debug.apply(_console, ["Camera list: "].concat(toConsumableArray(cameras)));
                getCamerasPromise = void 0;
                return resolve(cameras);
              })
              .catch(function(error) {
                CameraAccess.mediaStream.getVideoTracks().forEach(function(track) {
                  track.stop();
                });
                getCamerasPromise = void 0;
                return reject(error);
              });
          })
          .catch(function(error) {
            getCamerasPromise = void 0;
            return reject(error);
          });
      });
      return getCamerasPromise;
    }
    CameraAccess.getCameras = getCameras;
    function getUserMediaDelayed(getUserMediaParams) {
      console.debug("Camera access:", getUserMediaParams.video);
      return new promise$1(function(resolve, reject) {
        window.setTimeout(function() {
          navigator.mediaDevices
            .getUserMedia(getUserMediaParams)
            .then(resolve)
            .catch(reject);
        }, 0);
      });
    }
    function accessCameraStream(resolutionFallbackLevel, camera) {
      var getUserMediaParams = { audio: false, video: {} };
      if (0 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 1400, ideal: 1920, max: 1920 },
          height: { min: 900, ideal: 1440, max: 1440 }
        };
      else if (1 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 1200, ideal: 1920, max: 1920 },
          height: { min: 900, ideal: 1200, max: 1200 }
        };
      else if (2 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 1080, ideal: 1920, max: 1920 },
          height: { min: 900, ideal: 1080, max: 1080 }
        };
      else if (3 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 960, ideal: 1280, max: 1440 },
          height: { min: 480, ideal: 960, max: 960 }
        };
      else if (4 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 720, ideal: 1280, max: 1440 },
          height: { min: 480, ideal: 720, max: 768 }
        };
      else if (5 === resolutionFallbackLevel)
        getUserMediaParams.video = {
          width: { min: 640, ideal: 960, max: 1440 },
          height: { min: 480, ideal: 720, max: 720 }
        };
      if (void 0 === camera) getUserMediaParams.video = true;
      else getUserMediaParams.video.deviceId = { exact: camera.deviceId };
      return getUserMediaDelayed(getUserMediaParams);
    }
    CameraAccess.accessCameraStream = accessCameraStream;
    function enumerateDevices() {
      if ("function" === typeof navigator.enumerateDevices) return navigator.enumerateDevices();
      else if (
        "object" === _typeof_1(navigator.mediaDevices) &&
        "function" === typeof navigator.mediaDevices.enumerateDevices
      )
        return navigator.mediaDevices.enumerateDevices();
      else
        return new promise$1(function(resolve, reject) {
          try {
            window.MediaStreamTrack.getSources(function(devices) {
              resolve(
                devices
                  .filter(function(device) {
                    return "video" === device.kind.toLowerCase() || "videoinput" === device.kind.toLowerCase();
                  })
                  .map(function(device) {
                    return {
                      deviceId: null != device.deviceId ? device.deviceId : "",
                      groupId: device.groupId,
                      kind: "videoinput",
                      label: device.label
                    };
                  })
              );
            });
          } catch (error) {
            var browserCompatiblity = {
              fullSupport: false,
              scannerSupport: true,
              missingFeatures: [exports.BrowserCompatibility.Feature.MEDIA_DEVICES]
            };
            return reject(
              new CustomError({
                name: "UnsupportedBrowserError",
                message: "This OS / Browser has one or more missing features preventing it from working correctly",
                data: browserCompatiblity
              })
            );
          }
        });
    }
  })(exports.CameraAccess || (exports.CameraAccess = {}));
  var CameraManager = function CameraManager() {
    classCallCheck(this, CameraManager);
  };
  (function(CameraSettings) {
    (function(ResolutionPreference) {
      ResolutionPreference["FULL_HD"] = "full-hd";
      ResolutionPreference["HD"] = "hd";
    })(CameraSettings.ResolutionPreference || (CameraSettings.ResolutionPreference = {}));
  })(exports.CameraSettings || (exports.CameraSettings = {}));
  var BarcodePickerCameraManager = (function(_CameraManager) {
    inherits(BarcodePickerCameraManager, _CameraManager);
    function BarcodePickerCameraManager(triggerFatalError, barcodePickerGui) {
      var _this;
      classCallCheck(this, BarcodePickerCameraManager);
      _this = possibleConstructorReturn(this, getPrototypeOf$2(BarcodePickerCameraManager).call(this));
      _this.postStreamInitializationListener = _this.postStreamInitialization.bind(
        assertThisInitialized(assertThisInitialized(_this))
      );
      _this.videoTrackUnmuteListener = _this.videoTrackUnmuteRecovery.bind(
        assertThisInitialized(assertThisInitialized(_this))
      );
      _this.triggerManualFocusListener = _this.triggerManualFocus.bind(
        assertThisInitialized(assertThisInitialized(_this))
      );
      _this.triggerZoomStartListener = _this.triggerZoomStart.bind(assertThisInitialized(assertThisInitialized(_this)));
      _this.triggerZoomMoveListener = _this.triggerZoomMove.bind(assertThisInitialized(assertThisInitialized(_this)));
      _this.triggerFatalError = triggerFatalError;
      _this.barcodePickerGui = barcodePickerGui;
      return _this;
    }
    createClass(BarcodePickerCameraManager, [
      {
        key: "setInteractionOptions",
        value: function setInteractionOptions(
          cameraSwitcherEnabled,
          torchToggleEnabled,
          tapToFocusEnabled,
          pinchToZoomEnabled
        ) {
          this.cameraSwitcherEnabled = cameraSwitcherEnabled;
          this.torchToggleEnabled = torchToggleEnabled;
          this.tapToFocusEnabled = tapToFocusEnabled;
          this.pinchToZoomEnabled = pinchToZoomEnabled;
        }
      },
      {
        key: "isCameraSwitcherEnabled",
        value: function isCameraSwitcherEnabled() {
          return this.cameraSwitcherEnabled;
        }
      },
      {
        key: "setCameraSwitcherEnabled",
        value: function setCameraSwitcherEnabled(enabled) {
          var _this2 = this;
          this.cameraSwitcherEnabled = enabled;
          if (this.cameraSwitcherEnabled)
            return exports.CameraAccess.getCameras().then(function(cameras) {
              if (cameras.length > 1) _this2.barcodePickerGui.setCameraSwitcherVisible(true);
            });
          else {
            this.barcodePickerGui.setCameraSwitcherVisible(false);
            return promise$1.resolve();
          }
        }
      },
      {
        key: "isTorchToggleEnabled",
        value: function isTorchToggleEnabled() {
          return this.torchToggleEnabled;
        }
      },
      {
        key: "setTorchToggleEnabled",
        value: function setTorchToggleEnabled(enabled) {
          this.torchToggleEnabled = enabled;
          if (this.torchToggleEnabled) {
            if (
              null != this.mediaStream &&
              null != this.mediaTrackCapabilities &&
              null != this.mediaTrackCapabilities.torch &&
              this.mediaTrackCapabilities.torch
            )
              this.barcodePickerGui.setTorchTogglerVisible(true);
          } else this.barcodePickerGui.setTorchTogglerVisible(false);
        }
      },
      {
        key: "isTapToFocusEnabled",
        value: function isTapToFocusEnabled() {
          return this.tapToFocusEnabled;
        }
      },
      {
        key: "setTapToFocusEnabled",
        value: function setTapToFocusEnabled(enabled) {
          this.tapToFocusEnabled = enabled;
          if (null != this.mediaStream)
            if (this.tapToFocusEnabled) this.enableTapToFocusListeners();
            else this.disableTapToFocusListeners();
        }
      },
      {
        key: "isPinchToZoomEnabled",
        value: function isPinchToZoomEnabled() {
          return this.pinchToZoomEnabled;
        }
      },
      {
        key: "setPinchToZoomEnabled",
        value: function setPinchToZoomEnabled(enabled) {
          this.pinchToZoomEnabled = enabled;
          if (null != this.mediaStream)
            if (this.pinchToZoomEnabled) this.enablePinchToZoomListeners();
            else this.disablePinchToZoomListeners();
        }
      },
      {
        key: "setSelectedCamera",
        value: function setSelectedCamera(camera) {
          this.selectedCamera = camera;
        }
      },
      {
        key: "setSelectedCameraSettings",
        value: function setSelectedCameraSettings(cameraSettings) {
          this.selectedCameraSettings = cameraSettings;
        }
      },
      {
        key: "setupCameras",
        value: function setupCameras() {
          var _this3 = this;
          if (null != this.cameraInitializationPromise) return this.cameraInitializationPromise;
          return exports.CameraAccess.getCameras().then(function(cameras) {
            if (_this3.cameraSwitcherEnabled && cameras.length > 1)
              _this3.barcodePickerGui.setCameraSwitcherVisible(true);
            if (null == _this3.selectedCamera) {
              var autoselectedCamera = cameras.find(function(currentCamera) {
                return currentCamera.cameraType === exports.Camera.Type.BACK;
              });
              if (void 0 === autoselectedCamera) autoselectedCamera = cameras[0];
              if (void 0 === autoselectedCamera)
                return promise$1.reject(
                  new CustomError({ name: "NoCameraAvailableError", message: "No camera available" })
                );
              return _this3.initializeCameraWithSettings(autoselectedCamera, _this3.selectedCameraSettings);
            } else return _this3.initializeCameraWithSettings(_this3.selectedCamera, _this3.selectedCameraSettings);
          });
        }
      },
      {
        key: "stopStream",
        value: function stopStream() {
          if (null != this.activeCamera) this.activeCamera.currentResolution = void 0;
          this.activeCamera = void 0;
          if (null != this.mediaStream) {
            window.clearTimeout(this.cameraAccessTimeout);
            window.clearInterval(this.cameraMetadataCheckInterval);
            window.clearTimeout(this.getCapabilitiesTimeout);
            window.clearTimeout(this.manualFocusWaitTimeout);
            window.clearTimeout(this.manualToAutofocusResumeTimeout);
            window.clearInterval(this.autofocusInterval);
            this.mediaStream.getVideoTracks().forEach(function(track) {
              track.stop();
            });
            this.mediaStream = void 0;
            this.mediaTrackCapabilities = void 0;
          }
        }
      },
      {
        key: "applyCameraSettings",
        value: function applyCameraSettings(cameraSettings) {
          this.selectedCameraSettings = cameraSettings;
          if (null == this.activeCamera)
            return promise$1.reject(
              new CustomError({ name: "NoCameraAvailableError", message: "No camera available" })
            );
          return this.initializeCameraWithSettings(this.activeCamera, cameraSettings);
        }
      },
      {
        key: "reinitializeCamera",
        value: function reinitializeCamera(camera) {
          if (null == this.activeCamera && null == camera)
            return promise$1.reject(
              new CustomError({ name: "NoCameraAvailableError", message: "No camera available" })
            );
          return this.initializeCameraWithSettings(
            null == camera ? this.activeCamera : camera,
            this.activeCameraSettings
          ).catch(this.triggerFatalError);
        }
      },
      {
        key: "initializeCameraWithSettings",
        value: function initializeCameraWithSettings(camera, cameraSettings) {
          var _this4 = this;
          var existingCameraInitializationPromise = promise$1.resolve();
          if (null != this.cameraInitializationPromise)
            existingCameraInitializationPromise = this.cameraInitializationPromise;
          return existingCameraInitializationPromise.then(function() {
            _this4.setSelectedCamera(camera);
            _this4.selectedCameraSettings = _this4.activeCameraSettings = cameraSettings;
            if (
              null != cameraSettings &&
              cameraSettings.resolutionPreference === exports.CameraSettings.ResolutionPreference.FULL_HD
            )
              _this4.cameraInitializationPromise = _this4.initializeCameraAndCheckUpdatedSettings(camera);
            else _this4.cameraInitializationPromise = _this4.initializeCameraAndCheckUpdatedSettings(camera, 3);
            return _this4.cameraInitializationPromise;
          });
        }
      },
      {
        key: "setTorchEnabled",
        value: function setTorchEnabled(enabled) {
          if (
            null != this.mediaStream &&
            null != this.mediaTrackCapabilities &&
            null != this.mediaTrackCapabilities.torch &&
            this.mediaTrackCapabilities.torch
          ) {
            this.torchEnabled = enabled;
            var videoTracks = this.mediaStream.getVideoTracks();
            if (0 !== videoTracks.length && "function" === typeof videoTracks[0].applyConstraints)
              videoTracks[0].applyConstraints({ advanced: [{ torch: enabled }] });
          }
        }
      },
      {
        key: "toggleTorch",
        value: function toggleTorch() {
          this.torchEnabled = !this.torchEnabled;
          this.setTorchEnabled(this.torchEnabled);
        }
      },
      {
        key: "setZoom",
        value: function setZoom(zoomPercentage, currentZoom) {
          if (
            null != this.mediaStream &&
            null != this.mediaTrackCapabilities &&
            null != this.mediaTrackCapabilities.zoom
          ) {
            var videoTracks = this.mediaStream.getVideoTracks();
            if (0 !== videoTracks.length && "function" === typeof videoTracks[0].applyConstraints) {
              var zoomRange = this.mediaTrackCapabilities.zoom.max - this.mediaTrackCapabilities.zoom.min;
              if (null == currentZoom) currentZoom = this.mediaTrackCapabilities.zoom.min;
              var targetZoom = Math.max(
                this.mediaTrackCapabilities.zoom.min,
                Math.min(currentZoom + zoomRange * zoomPercentage, this.mediaTrackCapabilities.zoom.max)
              );
              videoTracks[0].applyConstraints({ advanced: [{ zoom: targetZoom }] });
            }
          }
        }
      },
      {
        key: "postStreamInitialization",
        value: function postStreamInitialization() {
          var _this5 = this;
          window.clearTimeout(this.getCapabilitiesTimeout);
          this.getCapabilitiesTimeout = window.setTimeout(function() {
            _this5.storeStreamCapabilities();
            _this5.setupAutofocus();
            if (
              _this5.torchToggleEnabled &&
              null != _this5.mediaStream &&
              null != _this5.mediaTrackCapabilities &&
              null != _this5.mediaTrackCapabilities.torch &&
              _this5.mediaTrackCapabilities.torch
            )
              _this5.barcodePickerGui.setTorchTogglerVisible(true);
          }, BarcodePickerCameraManager.getCapabilitiesTimeoutMs);
        }
      },
      {
        key: "videoTrackUnmuteRecovery",
        value: function videoTrackUnmuteRecovery() {
          this.reinitializeCamera();
        }
      },
      {
        key: "triggerManualFocus",
        value: function triggerManualFocus(event) {
          var _this6 = this;
          if (null != event) {
            event.preventDefault();
            if ("touchend" === event.type && 0 !== event.touches.length) return;
            if (null != this.pinchToZoomDistance) {
              this.pinchToZoomDistance = void 0;
              return;
            }
          }
          window.clearTimeout(this.manualFocusWaitTimeout);
          window.clearTimeout(this.manualToAutofocusResumeTimeout);
          if (null != this.mediaStream && null != this.mediaTrackCapabilities) {
            var focusModeCapability = this.mediaTrackCapabilities.focusMode;
            if (focusModeCapability instanceof Array && -1 !== focusModeCapability.indexOf("single-shot"))
              if (-1 !== focusModeCapability.indexOf("continuous") && -1 !== focusModeCapability.indexOf("manual")) {
                this.triggerFocusMode("continuous")
                  .then(function() {
                    _this6.manualFocusWaitTimeout = window.setTimeout(function() {
                      _this6.triggerFocusMode("manual");
                    }, BarcodePickerCameraManager.manualFocusWaitTimeoutMs);
                  })
                  .catch(function() {});
                this.manualToAutofocusResumeTimeout = window.setTimeout(function() {
                  _this6.triggerFocusMode("continuous");
                }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
              } else if (-1 === focusModeCapability.indexOf("continuous")) {
                window.clearInterval(this.autofocusInterval);
                this.triggerFocusMode("single-shot").catch(function() {});
                this.manualToAutofocusResumeTimeout = window.setTimeout(function() {
                  _this6.autofocusInterval = window.setInterval(
                    _this6.triggerAutoFocus.bind(_this6),
                    BarcodePickerCameraManager.autofocusIntervalMs
                  );
                }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
              }
          }
        }
      },
      {
        key: "triggerZoomStart",
        value: function triggerZoomStart(event) {
          if (null == event || 2 !== event.touches.length) return;
          event.preventDefault();
          this.pinchToZoomDistance = Math.hypot(
            (event.touches[1].screenX - event.touches[0].screenX) / screen.width,
            (event.touches[1].screenY - event.touches[0].screenY) / screen.height
          );
          if (
            null != this.mediaStream &&
            null != this.mediaTrackCapabilities &&
            null != this.mediaTrackCapabilities.zoom
          ) {
            var videoTracks = this.mediaStream.getVideoTracks();
            if (0 !== videoTracks.length && "function" === typeof videoTracks[0].getConstraints) {
              this.pinchToZoomInitialZoom = this.mediaTrackCapabilities.zoom.min;
              var currentConstraints = videoTracks[0].getConstraints();
              if (null != currentConstraints.advanced) {
                var currentZoomConstraint = currentConstraints.advanced.find(function(constraint) {
                  return "zoom" in constraint;
                });
                if (null != currentZoomConstraint) this.pinchToZoomInitialZoom = currentZoomConstraint.zoom;
              }
            }
          }
        }
      },
      {
        key: "triggerZoomMove",
        value: function triggerZoomMove(event) {
          if (null == this.pinchToZoomDistance || null == event || 2 !== event.touches.length) return;
          event.preventDefault();
          this.setZoom(
            2 *
              (Math.hypot(
                (event.touches[1].screenX - event.touches[0].screenX) / screen.width,
                (event.touches[1].screenY - event.touches[0].screenY) / screen.height
              ) -
                this.pinchToZoomDistance),
            this.pinchToZoomInitialZoom
          );
        }
      },
      {
        key: "storeStreamCapabilities",
        value: function storeStreamCapabilities() {
          if (null != this.mediaStream) {
            var videoTracks = this.mediaStream.getVideoTracks();
            if (0 !== videoTracks.length && "function" === typeof videoTracks[0].getCapabilities)
              this.mediaTrackCapabilities = videoTracks[0].getCapabilities();
          }
        }
      },
      {
        key: "setupAutofocus",
        value: function setupAutofocus() {
          window.clearTimeout(this.manualFocusWaitTimeout);
          window.clearTimeout(this.manualToAutofocusResumeTimeout);
          if (null != this.mediaStream && null != this.mediaTrackCapabilities) {
            var focusModeCapability = this.mediaTrackCapabilities.focusMode;
            if (
              focusModeCapability instanceof Array &&
              -1 === focusModeCapability.indexOf("continuous") &&
              -1 !== focusModeCapability.indexOf("single-shot")
            ) {
              window.clearInterval(this.autofocusInterval);
              this.autofocusInterval = window.setInterval(
                this.triggerAutoFocus.bind(this),
                BarcodePickerCameraManager.autofocusIntervalMs
              );
            }
          }
        }
      },
      {
        key: "triggerAutoFocus",
        value: function triggerAutoFocus() {
          this.triggerFocusMode("single-shot").catch(function() {});
        }
      },
      {
        key: "triggerFocusMode",
        value: function triggerFocusMode(focusMode) {
          if (null != this.mediaStream) {
            var videoTracks = this.mediaStream.getVideoTracks();
            if (0 !== videoTracks.length && "function" === typeof videoTracks[0].applyConstraints)
              return videoTracks[0].applyConstraints({ advanced: [{ focusMode: focusMode }] });
          }
          return promise$1.reject(void 0);
        }
      },
      {
        key: "enableTapToFocusListeners",
        value: function enableTapToFocusListeners() {
          var _this7 = this;
          ["touchend", "mousedown"].forEach(function(eventName) {
            _this7.barcodePickerGui.videoElement.addEventListener(eventName, _this7.triggerManualFocusListener);
          });
        }
      },
      {
        key: "enablePinchToZoomListeners",
        value: function enablePinchToZoomListeners() {
          this.barcodePickerGui.videoElement.addEventListener("touchstart", this.triggerZoomStartListener);
          this.barcodePickerGui.videoElement.addEventListener("touchmove", this.triggerZoomMoveListener);
        }
      },
      {
        key: "disableTapToFocusListeners",
        value: function disableTapToFocusListeners() {
          var _this8 = this;
          ["touchend", "mousedown"].forEach(function(eventName) {
            _this8.barcodePickerGui.videoElement.removeEventListener(eventName, _this8.triggerManualFocusListener);
          });
        }
      },
      {
        key: "disablePinchToZoomListeners",
        value: function disablePinchToZoomListeners() {
          this.barcodePickerGui.videoElement.removeEventListener("touchstart", this.triggerZoomStartListener);
          this.barcodePickerGui.videoElement.removeEventListener("touchmove", this.triggerZoomMoveListener);
        }
      },
      {
        key: "initializeCameraAndCheckUpdatedSettings",
        value: function initializeCameraAndCheckUpdatedSettings(camera, resolutionFallbackLevel) {
          var _this9 = this;
          return this.initializeCamera(camera, resolutionFallbackLevel)
            .then(function() {
              if (
                _this9.selectedCameraSettings !== _this9.activeCameraSettings &&
                (null == _this9.selectedCameraSettings ||
                  null == _this9.activeCameraSettings ||
                  keys$1(_this9.selectedCameraSettings).some(function(cameraSettingsProperty) {
                    return (
                      _this9.selectedCameraSettings[cameraSettingsProperty] !==
                      _this9.activeCameraSettings[cameraSettingsProperty]
                    );
                  }))
              ) {
                _this9.activeCameraSettings = _this9.selectedCameraSettings;
                return _this9.initializeCameraAndCheckUpdatedSettings(camera, resolutionFallbackLevel);
              }
              _this9.cameraInitializationPromise = void 0;
              return promise$1.resolve();
            })
            .catch(function(error) {
              _this9.cameraInitializationPromise = void 0;
              return promise$1.reject(error);
            });
        }
      },
      {
        key: "retryInitializeCameraIfNeeded",
        value: function retryInitializeCameraIfNeeded(camera, resolutionFallbackLevel, resolve, reject, error) {
          if (resolutionFallbackLevel < 6)
            return this.initializeCamera(camera, resolutionFallbackLevel + 1)
              .then(resolve)
              .catch(reject);
          else return reject(error);
        }
      },
      {
        key: "initializeCamera",
        value: function initializeCamera(camera) {
          var _this10 = this;
          var resolutionFallbackLevel = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          if (null == camera)
            return promise$1.reject(
              new CustomError({ name: "NoCameraAvailableError", message: "No camera available" })
            );
          this.stopStream();
          this.torchEnabled = false;
          this.barcodePickerGui.setTorchTogglerVisible(false);
          return new promise$1(function(resolve, reject) {
            exports.CameraAccess.accessCameraStream(resolutionFallbackLevel, camera)
              .then(function(stream) {
                if ("function" === typeof stream.getTracks()[0].getSettings) {
                  var mediaTrackSettings = stream.getTracks()[0].getSettings();
                  if (
                    null != mediaTrackSettings.width &&
                    null != mediaTrackSettings.height &&
                    (2 === mediaTrackSettings.width || 2 === mediaTrackSettings.height)
                  )
                    if (6 === resolutionFallbackLevel)
                      return reject(
                        new CustomError({ name: "NotReadableError", message: "Could not initialize camera correctly" })
                      );
                    else
                      return _this10
                        .initializeCamera(camera, resolutionFallbackLevel + 1)
                        .then(resolve)
                        .catch(reject);
                }
                _this10.mediaStream = stream;
                _this10.mediaStream.getVideoTracks().forEach(function(track) {
                  track.addEventListener("unmute", _this10.videoTrackUnmuteListener);
                });
                _this10.barcodePickerGui.videoElement.addEventListener(
                  "loadedmetadata",
                  _this10.postStreamInitializationListener
                );
                if (_this10.tapToFocusEnabled) _this10.enableTapToFocusListeners();
                if (_this10.pinchToZoomEnabled) _this10.enablePinchToZoomListeners();
                _this10.resolveInitializeCamera(camera, resolve, reject);
                _this10.barcodePickerGui.videoElement.srcObject = stream;
                _this10.barcodePickerGui.videoElement.load();
                _this10.barcodePickerGui.playVideo();
              })
              .catch(function(error) {
                if ("SourceUnavailableError" === error.name) error.name = "NotReadableError";
                if (
                  "Invalid constraint" === error.message ||
                  ("OverconstrainedError" === error.name && "deviceId" === error.constraint)
                )
                  return exports.CameraAccess.getCameras().then(function(cameras) {
                    var newCamera = cameras.find(function(currentCamera) {
                      return (
                        currentCamera.label === camera.label &&
                        currentCamera.cameraType === camera.cameraType &&
                        currentCamera.deviceId !== camera.deviceId
                      );
                    });
                    if (null == newCamera)
                      return _this10.retryInitializeCameraIfNeeded(
                        camera,
                        resolutionFallbackLevel,
                        resolve,
                        reject,
                        error
                      );
                    else
                      return _this10
                        .initializeCamera(newCamera, resolutionFallbackLevel)
                        .then(resolve)
                        .catch(reject);
                  });
                if (
                  "PermissionDeniedError" === error.name ||
                  "PermissionDismissedError" === error.name ||
                  "NotAllowedError" === error.name ||
                  "NotFoundError" === error.name ||
                  "AbortError" === error.name
                )
                  return reject(error);
                return _this10.retryInitializeCameraIfNeeded(camera, resolutionFallbackLevel, resolve, reject, error);
              });
          });
        }
      },
      {
        key: "resolveInitializeCamera",
        value: function resolveInitializeCamera(camera, resolve, reject) {
          var _this11 = this;
          var cameraNotReadableError = new CustomError({
            name: "NotReadableError",
            message: "Could not initialize camera correctly"
          });
          window.clearTimeout(this.cameraAccessTimeout);
          this.cameraAccessTimeout = window.setTimeout(function() {
            _this11.stopStream();
            reject(cameraNotReadableError);
          }, BarcodePickerCameraManager.cameraAccessTimeoutMs);
          if ("iOS" === exports.BrowserHelper.userAgentInfo.getOS().name)
            this.barcodePickerGui.videoElement.onloadstart = function() {
              _this11.barcodePickerGui.videoElement.onloadstart = null;
              window.clearTimeout(_this11.cameraAccessTimeout);
              _this11.activeCamera = camera;
              _this11.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));
              resolve();
            };
          else
            this.barcodePickerGui.videoElement.onloadeddata = function() {
              _this11.barcodePickerGui.videoElement.onloadeddata = null;
              window.clearTimeout(_this11.cameraAccessTimeout);
              if (
                _this11.barcodePickerGui.videoElement.videoWidth > 2 &&
                _this11.barcodePickerGui.videoElement.videoHeight > 2 &&
                _this11.barcodePickerGui.videoElement.currentTime > 0
              ) {
                _this11.activeCamera = camera;
                _this11.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));
                return resolve();
              }
              var cameraMetadataCheckStartTime = performance.now();
              window.clearInterval(_this11.cameraMetadataCheckInterval);
              _this11.cameraMetadataCheckInterval = window.setInterval(function() {
                if (
                  2 === _this11.barcodePickerGui.videoElement.videoWidth ||
                  2 === _this11.barcodePickerGui.videoElement.videoHeight ||
                  0 === _this11.barcodePickerGui.videoElement.currentTime
                ) {
                  if (
                    performance.now() - cameraMetadataCheckStartTime >
                    BarcodePickerCameraManager.cameraMetadataCheckTimeoutMs
                  ) {
                    window.clearInterval(_this11.cameraMetadataCheckInterval);
                    _this11.stopStream();
                    return reject(cameraNotReadableError);
                  }
                  return;
                }
                window.clearInterval(_this11.cameraMetadataCheckInterval);
                _this11.activeCamera = camera;
                _this11.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));
                return resolve();
              }, BarcodePickerCameraManager.cameraMetadataCheckIntervalMs);
            };
        }
      }
    ]);
    return BarcodePickerCameraManager;
  })(CameraManager);
  BarcodePickerCameraManager.cameraAccessTimeoutMs = 4e3;
  BarcodePickerCameraManager.cameraMetadataCheckTimeoutMs = 4e3;
  BarcodePickerCameraManager.cameraMetadataCheckIntervalMs = 50;
  BarcodePickerCameraManager.getCapabilitiesTimeoutMs = 500;
  BarcodePickerCameraManager.autofocusIntervalMs = 1500;
  BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs = 5e3;
  BarcodePickerCameraManager.manualFocusWaitTimeoutMs = 400;
  var $find$1 = _arrayMethods$1(6);
  var KEY$1 = "findIndex";
  var forced$1 = true;
  if (KEY$1 in [])
    Array(1)[KEY$1](function() {
      forced$1 = false;
    });
  _export$1(_export$1.P + _export$1.F * forced$1, "Array", {
    findIndex: function findIndex(callbackfn) {
      return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  _addToUnscopables$1(KEY$1);
  var _flags = function() {
    var that = _anObject(this);
    var result = "";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.unicode) result += "u";
    if (that.sticky) result += "y";
    return result;
  };
  if (_descriptors && "g" != /./g.flags) _objectDp.f(RegExp.prototype, "flags", { configurable: true, get: _flags });
  var TO_STRING = "toString";
  var $toString = /./[TO_STRING];
  var define = function(fn) {
    _redefine(RegExp.prototype, TO_STRING, fn, true);
  };
  if (
    _fails(function() {
      return "/a/b" != $toString.call({ source: "a", flags: "b" });
    })
  )
    define(function toString() {
      var R = _anObject(this);
      return "/".concat(
        R.source,
        "/",
        "flags" in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : void 0
      );
    });
  else if ($toString.name != TO_STRING)
    define(function toString() {
      return $toString.call(this);
    });
  var DateProto = Date.prototype;
  var INVALID_DATE = "Invalid Date";
  var TO_STRING$1 = "toString";
  var $toString$1 = DateProto[TO_STRING$1];
  var getTime = DateProto.getTime;
  if (new Date(NaN) + "" != INVALID_DATE)
    _redefine(DateProto, TO_STRING$1, function toString() {
      var value = getTime.call(this);
      return value === value ? $toString$1.call(this) : INVALID_DATE;
    });
  (function(ImageSettings) {
    (function(Format) {
      Format[(Format["GRAY_8U"] = 0)] = "GRAY_8U";
      Format[(Format["RGB_8U"] = 1)] = "RGB_8U";
      Format[(Format["RGBA_8U"] = 2)] = "RGBA_8U";
    })(ImageSettings.Format || (ImageSettings.Format = {}));
  })(exports.ImageSettings || (exports.ImageSettings = {}));
  var BarcodePickerGui = (function() {
    function BarcodePickerGui(
      scanner,
      originElement,
      singleImageMode,
      scanningPaused,
      visible,
      guiStyle,
      videoFit,
      cameraUploadCallback
    ) {
      var _this = this;
      classCallCheck(this, BarcodePickerGui);
      this.scanner = scanner;
      this.originElement = originElement;
      this.singleImageMode = singleImageMode;
      this.scanningPaused = scanningPaused;
      this.cameraUploadCallback = cameraUploadCallback;
      this.mirrorImageOverrides = new map$1();
      this.grandParentElement = document.createElement("div");
      this.grandParentElement.className = BarcodePickerGui.grandParentElementClassName;
      this.originElement.appendChild(this.grandParentElement);
      this.parentElement = document.createElement("div");
      this.parentElement.className = BarcodePickerGui.parentElementClassName;
      this.grandParentElement.appendChild(this.parentElement);
      this.videoImageCanvasContext = document.createElement("canvas").getContext("2d");
      this.videoElement = document.createElement("video");
      this.cameraSwitcherElement = document.createElement("img");
      this.torchTogglerElement = document.createElement("img");
      this.laserActiveImageElement = document.createElement("img");
      this.laserPausedImageElement = document.createElement("img");
      this.viewfinderElement = document.createElement("div");
      if (singleImageMode) {
        this.cameraUploadElement = document.createElement("div");
        this.cameraUploadInputElement = document.createElement("input");
        this.cameraUploadLabelElement = document.createElement("label");
        this.cameraUploadProgressElement = document.createElement("div");
        this.setupCameraUploadGuiAssets();
        this.guiStyle = exports.BarcodePicker.GuiStyle.NONE;
      } else {
        this.setupVideoElement();
        this.setupCameraSwitcher();
        this.setupTorchToggler();
        this.setupFullGuiAssets();
        this.setGuiStyle(guiStyle);
        this.setVideoFit(videoFit);
        this.visibilityListener = this.checkAndRecoverPlayback.bind(this);
        document.addEventListener("visibilitychange", this.visibilityListener);
      }
      this.resizeInterval = window.setInterval(function() {
        _this.resizeIfNeeded();
      }, 250);
      this.setupSharedAssets();
      this.setVisible(visible);
    }
    createClass(BarcodePickerGui, [
      {
        key: "destroy",
        value: function destroy() {
          if (null != this.visibilityListener)
            document.removeEventListener("visibilitychange", this.visibilityListener);
          window.clearInterval(this.resizeInterval);
          this.grandParentElement.remove();
          this.originElement.classList.remove(BarcodePickerGui.hiddenClassName);
        }
      },
      {
        key: "setCameraManager",
        value: function setCameraManager(cameraManager) {
          this.cameraManager = cameraManager;
        }
      },
      {
        key: "pauseScanning",
        value: function pauseScanning() {
          this.scanningPaused = true;
          this.laserActiveImageElement.classList.add(BarcodePickerGui.hiddenOpacityClassName);
          this.laserPausedImageElement.classList.remove(BarcodePickerGui.hiddenOpacityClassName);
          this.viewfinderElement.classList.add(BarcodePickerGui.pausedClassName);
        }
      },
      {
        key: "resumeScanning",
        value: function resumeScanning() {
          this.scanningPaused = false;
          this.laserPausedImageElement.classList.add(BarcodePickerGui.hiddenOpacityClassName);
          this.laserActiveImageElement.classList.remove(BarcodePickerGui.hiddenOpacityClassName);
          this.viewfinderElement.classList.remove(BarcodePickerGui.pausedClassName);
        }
      },
      {
        key: "isVisible",
        value: function isVisible() {
          return this.visible;
        }
      },
      {
        key: "setVisible",
        value: function setVisible(visible) {
          var browserName = exports.BrowserHelper.userAgentInfo.getBrowser().name;
          if (
            null != browserName &&
            -1 !== browserName.indexOf("Safari") &&
            null != this.visible &&
            !this.visible &&
            visible
          ) {
            this.videoElement.pause();
            this.videoElement.currentTime = 0;
            this.videoElement.load();
            this.playVideo();
          }
          this.visible = visible;
          if (visible) {
            this.originElement.classList.remove(BarcodePickerGui.hiddenClassName);
            if (this.guiStyle === exports.BarcodePicker.GuiStyle.LASER)
              this.laserActiveImageElement.classList.remove(BarcodePickerGui.flashColorClassName);
            else if (this.guiStyle === exports.BarcodePicker.GuiStyle.VIEWFINDER)
              this.viewfinderElement.classList.remove(BarcodePickerGui.flashWhiteClassName);
          } else this.originElement.classList.add(BarcodePickerGui.hiddenClassName);
        }
      },
      {
        key: "isMirrorImageEnabled",
        value: function isMirrorImageEnabled() {
          if (
            null != this.cameraManager &&
            null != this.cameraManager.selectedCamera &&
            null != this.cameraManager.activeCamera
          ) {
            var mirrorImageOverride = this.mirrorImageOverrides.get(
              this.cameraManager.activeCamera.deviceId + this.cameraManager.activeCamera.label
            );
            if (null != mirrorImageOverride) return mirrorImageOverride;
            else return this.cameraManager.activeCamera.cameraType === exports.Camera.Type.FRONT;
          } else return false;
        }
      },
      {
        key: "setMirrorImageEnabled",
        value: function setMirrorImageEnabled(enabled, override) {
          if (null != this.cameraManager && null != this.cameraManager.selectedCamera) {
            if (enabled) this.videoElement.classList.add(BarcodePickerGui.mirroredClassName);
            else this.videoElement.classList.remove(BarcodePickerGui.mirroredClassName);
            if (override)
              this.mirrorImageOverrides.set(
                this.cameraManager.selectedCamera.deviceId + this.cameraManager.selectedCamera.label,
                enabled
              );
          }
        }
      },
      {
        key: "setGuiStyle",
        value: function setGuiStyle(guiStyle) {
          if (this.singleImageMode) return;
          this.guiStyle = guiStyle;
          switch (this.guiStyle) {
            case exports.BarcodePicker.GuiStyle.NONE:
              this.laserActiveImageElement.classList.add(BarcodePickerGui.hiddenClassName);
              this.laserPausedImageElement.classList.add(BarcodePickerGui.hiddenClassName);
              this.viewfinderElement.classList.add(BarcodePickerGui.hiddenClassName);
              break;
            case exports.BarcodePicker.GuiStyle.LASER:
              this.laserActiveImageElement.classList.remove(BarcodePickerGui.hiddenClassName);
              this.laserPausedImageElement.classList.remove(BarcodePickerGui.hiddenClassName);
              this.viewfinderElement.classList.add(BarcodePickerGui.hiddenClassName);
              break;
            case exports.BarcodePicker.GuiStyle.VIEWFINDER:
              this.laserActiveImageElement.classList.add(BarcodePickerGui.hiddenClassName);
              this.laserPausedImageElement.classList.add(BarcodePickerGui.hiddenClassName);
              this.viewfinderElement.classList.remove(BarcodePickerGui.hiddenClassName);
          }
        }
      },
      {
        key: "setVideoFit",
        value: function setVideoFit(objectFit) {
          if (this.singleImageMode) return;
          this.videoFit = objectFit;
          if (objectFit === exports.BarcodePicker.ObjectFit.COVER) {
            this.videoElement.style.objectFit = "cover";
            this.videoElement.dataset.objectFit = "cover";
          } else {
            this.videoElement.style.objectFit = "contain";
            this.videoElement.dataset.objectFit = "contain";
            this.scanner.applyScanSettings(
              this.scanner.getScanSettings().setBaseSearchArea({ x: 0, y: 0, width: 1, height: 1 })
            );
          }
          this.lastKnownElementWidth = 0;
          this.lastKnownElementHeight = 0;
          this.resizeIfNeeded();
          window.objectFitPolyfill(this.videoElement);
        }
      },
      {
        key: "reassignOriginElement",
        value: function reassignOriginElement(originElement) {
          if (!this.visible) {
            this.originElement.classList.remove(BarcodePickerGui.hiddenClassName);
            originElement.classList.add(BarcodePickerGui.hiddenClassName);
          }
          originElement.appendChild(this.grandParentElement);
          this.checkAndRecoverPlayback();
          this.resizeIfNeeded();
          this.originElement = originElement;
        }
      },
      {
        key: "flashGUI",
        value: function flashGUI() {
          if (this.guiStyle === exports.BarcodePicker.GuiStyle.LASER) this.flashLaser();
          else if (this.guiStyle === exports.BarcodePicker.GuiStyle.VIEWFINDER) this.flashViewfinder();
        }
      },
      {
        key: "getVideoImageData",
        value: function getVideoImageData() {
          if (!this.singleImageMode) {
            this.videoImageCanvasContext.drawImage(this.videoElement, 0, 0);
            if (
              4 !== this.videoElement.readyState ||
              this.videoImageCanvasContext.canvas.width <= 2 ||
              this.videoImageCanvasContext.canvas.height <= 2
            )
              return;
          }
          return this.videoImageCanvasContext.getImageData(
            0,
            0,
            this.videoImageCanvasContext.canvas.width,
            this.videoImageCanvasContext.canvas.height
          ).data;
        }
      },
      {
        key: "getVideoCurrentTime",
        value: function getVideoCurrentTime() {
          return this.videoElement.currentTime;
        }
      },
      {
        key: "setCameraSwitcherVisible",
        value: function setCameraSwitcherVisible(visible) {
          if (visible) this.cameraSwitcherElement.classList.remove(BarcodePickerGui.hiddenClassName);
          else this.cameraSwitcherElement.classList.add(BarcodePickerGui.hiddenClassName);
        }
      },
      {
        key: "setTorchTogglerVisible",
        value: function setTorchTogglerVisible(visible) {
          if (visible) this.torchTogglerElement.classList.remove(BarcodePickerGui.hiddenClassName);
          else this.torchTogglerElement.classList.add(BarcodePickerGui.hiddenClassName);
        }
      },
      {
        key: "playVideo",
        value: function playVideo() {
          var playPromise = this.videoElement.play();
          if (null != playPromise) playPromise.catch(function() {});
        }
      },
      {
        key: "setCameraUploadGuiAvailable",
        value: function setCameraUploadGuiAvailable(available) {
          if (available) {
            this.cameraUploadProgressElement.classList.add(BarcodePickerGui.flashWhiteInsetClassName);
            this.cameraUploadElement.classList.remove(BarcodePickerGui.opacityPulseClassName);
          } else {
            this.cameraUploadProgressElement.classList.remove(BarcodePickerGui.flashWhiteInsetClassName);
            this.cameraUploadElement.classList.add(BarcodePickerGui.opacityPulseClassName);
          }
        }
      },
      {
        key: "setupVideoElement",
        value: function setupVideoElement() {
          var _this2 = this;
          this.videoElement.setAttribute("autoplay", "autoplay");
          this.videoElement.setAttribute("playsinline", "true");
          this.videoElement.setAttribute("muted", "muted");
          this.videoElement.className = BarcodePickerGui.videoElementClassName;
          this.parentElement.appendChild(this.videoElement);
          this.videoElement.addEventListener("canplay", function() {
            if (null != _this2.cameraManager && null != _this2.cameraManager.activeCamera) {
              window.setTimeout(function() {
                _this2.lastKnownElementWidth = 0;
                _this2.lastKnownElementHeight = 0;
                _this2.resizeIfNeeded();
                window.objectFitPolyfill(_this2.videoElement);
              }, 0);
              _this2.cameraManager.activeCamera.currentResolution = {
                width: _this2.videoElement.videoWidth,
                height: _this2.videoElement.videoHeight
              };
              _this2.videoImageCanvasContext.canvas.width = _this2.videoElement.videoWidth;
              _this2.videoImageCanvasContext.canvas.height = _this2.videoElement.videoHeight;
              _this2.scanner.applyImageSettings({
                width: _this2.videoElement.videoWidth,
                height: _this2.videoElement.videoHeight,
                format: exports.ImageSettings.Format.RGBA_8U
              });
              _this2.setMirrorImageEnabled(_this2.isMirrorImageEnabled(), false);
            }
          });
        }
      },
      {
        key: "setupSharedAssets",
        value: function setupSharedAssets() {
          var scanditLogoImageElement = document.createElement("img");
          scanditLogoImageElement.src = scanditLogoImage;
          scanditLogoImageElement.className = BarcodePickerGui.scanditLogoImageElementClassName;
          this.parentElement.appendChild(scanditLogoImageElement);
        }
      },
      {
        key: "setupCameraUploadGuiAssets",
        value: function setupCameraUploadGuiAssets() {
          var _this3 = this;
          this.cameraUploadElement.className = BarcodePickerGui.cameraUploadElementClassName;
          this.parentElement.appendChild(this.cameraUploadElement);
          this.cameraUploadInputElement.type = "file";
          this.cameraUploadInputElement.accept = "image/*";
          this.cameraUploadInputElement.setAttribute("capture", "environment");
          this.cameraUploadInputElement.addEventListener("change", this.cameraUploadFile.bind(this));
          this.cameraUploadInputElement.addEventListener("click", function(event) {
            if (_this3.scanningPaused || _this3.scanner.isBusyProcessing()) event.preventDefault();
          });
          this.cameraUploadLabelElement.appendChild(this.cameraUploadInputElement);
          this.cameraUploadElement.appendChild(this.cameraUploadLabelElement);
          var cameraUploadImageElement = document.createElement("img");
          cameraUploadImageElement.src = cameraImage;
          this.cameraUploadLabelElement.appendChild(cameraUploadImageElement);
          var cameraUploadTextElement = document.createElement("div");
          cameraUploadTextElement.innerText = "Scan from Camera";
          this.cameraUploadLabelElement.appendChild(cameraUploadTextElement);
          this.cameraUploadProgressElement.classList.add("radial-progress");
          this.cameraUploadElement.appendChild(this.cameraUploadProgressElement);
        }
      },
      {
        key: "setupFullGuiAssets",
        value: function setupFullGuiAssets() {
          this.laserActiveImageElement.src = laserActiveImage;
          this.laserActiveImageElement.className = BarcodePickerGui.laserImageElementClassName;
          this.parentElement.appendChild(this.laserActiveImageElement);
          this.laserPausedImageElement.src = laserPausedImage;
          this.laserPausedImageElement.className = BarcodePickerGui.laserImageElementClassName;
          this.parentElement.appendChild(this.laserPausedImageElement);
          this.viewfinderElement.className = BarcodePickerGui.viewfinderElementClassName;
          this.parentElement.appendChild(this.viewfinderElement);
          this.laserActiveImageElement.classList.add(BarcodePickerGui.hiddenOpacityClassName);
          this.laserPausedImageElement.classList.remove(BarcodePickerGui.hiddenOpacityClassName);
          this.viewfinderElement.classList.add(BarcodePickerGui.pausedClassName);
        }
      },
      {
        key: "flashLaser",
        value: function flashLaser() {
          this.laserActiveImageElement.classList.remove(BarcodePickerGui.flashColorClassName);
          this.laserActiveImageElement.offsetHeight;
          this.laserActiveImageElement.classList.add(BarcodePickerGui.flashColorClassName);
        }
      },
      {
        key: "flashViewfinder",
        value: function flashViewfinder() {
          this.viewfinderElement.classList.remove(BarcodePickerGui.flashWhiteClassName);
          this.viewfinderElement.offsetHeight;
          this.viewfinderElement.classList.add(BarcodePickerGui.flashWhiteClassName);
        }
      },
      {
        key: "resizeIfNeeded",
        value: function resizeIfNeeded() {
          if (
            this.lastKnownElementWidth === this.originElement.clientWidth &&
            this.lastKnownElementHeight === this.originElement.clientHeight
          )
            return;
          if (this.singleImageMode) this.resizeCameraUploadIfNeeded();
          else this.resizeVideoIfNeeded();
        }
      },
      {
        key: "resizeCameraUploadIfNeeded",
        value: function resizeCameraUploadIfNeeded() {
          var width = this.cameraUploadElement.clientWidth;
          var height = this.cameraUploadElement.clientHeight;
          this.lastKnownElementWidth = width;
          this.lastKnownElementHeight = height;
          this.cameraUploadLabelElement.style.transform = "scale(".concat(Math.min(1, width / 500, height / 300), ")");
          this.cameraUploadProgressElement.style.transform = "scale(".concat(
            Math.min(1, width / 500, height / 300),
            ")"
          );
        }
      },
      {
        key: "resizeVideoIfNeeded",
        value: function resizeVideoIfNeeded() {
          if (
            this.videoElement.videoHeight < 1 ||
            this.originElement.clientHeight < 1 ||
            (this.lastKnownElementWidth === this.originElement.clientWidth &&
              this.lastKnownElementHeight === this.originElement.clientHeight)
          )
            return;
          this.parentElement.style.maxWidth = null;
          this.parentElement.style.maxHeight = null;
          var videoRatio = this.videoElement.videoWidth / this.videoElement.videoHeight;
          var width = this.originElement.clientWidth;
          var height = this.originElement.clientHeight;
          this.lastKnownElementWidth = width;
          this.lastKnownElementHeight = height;
          if (this.videoFit === exports.BarcodePicker.ObjectFit.COVER) {
            var widthPercentage = 1;
            var heightPercentage = 1;
            if (videoRatio < width / height) heightPercentage = Math.min(1, height / (width / videoRatio));
            else widthPercentage = Math.min(1, width / (height * videoRatio));
            this.scanner.applyScanSettings(
              this.scanner
                .getScanSettings()
                .setBaseSearchArea({
                  x: (1 - widthPercentage) / 2,
                  y: (1 - heightPercentage) / 2,
                  width: widthPercentage,
                  height: heightPercentage
                })
            );
            return;
          }
          if (videoRatio > width / height) height = width / videoRatio;
          else width = height * videoRatio;
          this.parentElement.style.maxWidth = "".concat(Math.ceil(width), "px");
          this.parentElement.style.maxHeight = "".concat(Math.ceil(height), "px");
          window.objectFitPolyfill(this.videoElement);
        }
      },
      {
        key: "checkAndRecoverPlayback",
        value: function checkAndRecoverPlayback() {
          if (
            null != this.cameraManager &&
            null != this.cameraManager.activeCamera &&
            null != this.videoElement &&
            null != this.videoElement.srcObject
          )
            if (!this.videoElement.srcObject.active) this.cameraManager.reinitializeCamera();
            else this.playVideo();
        }
      },
      {
        key: "cameraUploadFileProcess",
        value: function cameraUploadFileProcess(image, width, height) {
          var _this4 = this;
          this.videoImageCanvasContext.canvas.width = width;
          this.videoImageCanvasContext.canvas.height = height;
          this.videoImageCanvasContext.drawImage(image, 0, 0, width, height);
          this.scanner.applyImageSettings({
            width: width,
            height: height,
            format: exports.ImageSettings.Format.RGBA_8U
          });
          this.setCameraUploadGuiAvailable(false);
          this.cameraUploadCallback().then(function() {
            _this4.setCameraUploadGuiAvailable(true);
          });
        }
      },
      {
        key: "cameraUploadFile",
        value: function cameraUploadFile() {
          var _this5 = this;
          var files = this.cameraUploadInputElement.files;
          if (null != files && 0 !== files.length) {
            var image = new Image();
            var fileReader = new FileReader();
            fileReader.onload = function(event) {
              _this5.cameraUploadInputElement.value = "";
              if (null != event.target) {
                image.onload = function() {
                  _this5.cameraUploadProgressElement.setAttribute("data-progress", "100");
                  var resizedImageWidth;
                  var resizedImageHeight;
                  var resizedImageSizeLimit = 1440;
                  if (image.naturalWidth <= resizedImageSizeLimit && image.naturalHeight <= resizedImageSizeLimit) {
                    resizedImageWidth = image.naturalWidth;
                    resizedImageHeight = image.naturalHeight;
                  } else if (image.naturalWidth > image.naturalHeight) {
                    resizedImageWidth = resizedImageSizeLimit;
                    resizedImageHeight = Math.round((image.naturalHeight / image.naturalWidth) * resizedImageSizeLimit);
                  } else {
                    resizedImageWidth = Math.round((image.naturalWidth / image.naturalHeight) * resizedImageSizeLimit);
                    resizedImageHeight = resizedImageSizeLimit;
                  }
                  _this5.cameraUploadFileProcess(image, resizedImageWidth, resizedImageHeight);
                };
                image.onprogress = function(event2) {
                  if (event2.lengthComputable) {
                    var progress = 5 * Math.round((event2.loaded / event2.total) * 20);
                    if (progress <= 100)
                      _this5.cameraUploadProgressElement.setAttribute("data-progress", progress.toString());
                  }
                };
                image.src = event.target.result;
              }
            };
            this.cameraUploadProgressElement.setAttribute("data-progress", "0");
            fileReader.readAsDataURL(files[0]);
          }
        }
      },
      {
        key: "setupCameraSwitcher",
        value: function setupCameraSwitcher() {
          var _this6 = this;
          this.cameraSwitcherElement.src = switchCameraImage;
          this.cameraSwitcherElement.className = BarcodePickerGui.cameraSwitcherElementClassName;
          this.cameraSwitcherElement.classList.add(BarcodePickerGui.hiddenClassName);
          this.parentElement.appendChild(this.cameraSwitcherElement);
          ["touchstart", "mousedown"].forEach(function(eventName) {
            _this6.cameraSwitcherElement.addEventListener(eventName, function(event) {
              if (null != _this6.cameraManager) {
                var cameraManager = _this6.cameraManager;
                event.preventDefault();
                exports.CameraAccess.getCameras()
                  .then(function(cameras) {
                    var newCameraIndex =
                      (cameras.findIndex(function(camera) {
                        return (
                          camera.deviceId ===
                          (null == cameraManager.activeCamera ? camera.deviceId : cameraManager.activeCamera.deviceId)
                        );
                      }) +
                        1) %
                      cameras.length;
                    cameraManager
                      .initializeCameraWithSettings(cameras[newCameraIndex], cameraManager.activeCameraSettings)
                      .catch(console.error);
                  })
                  .catch(console.error);
              }
            });
          });
        }
      },
      {
        key: "setupTorchToggler",
        value: function setupTorchToggler() {
          var _this7 = this;
          this.torchTogglerElement.src = toggleTorchImage;
          this.torchTogglerElement.className = BarcodePickerGui.torchTogglerElementClassName;
          this.torchTogglerElement.classList.add(BarcodePickerGui.hiddenClassName);
          this.parentElement.appendChild(this.torchTogglerElement);
          ["touchstart", "mousedown"].forEach(function(eventName) {
            _this7.torchTogglerElement.addEventListener(eventName, function(event) {
              if (null != _this7.cameraManager) {
                event.preventDefault();
                _this7.cameraManager.toggleTorch();
              }
            });
          });
        }
      }
    ]);
    return BarcodePickerGui;
  })();
  BarcodePickerGui.grandParentElementClassName = "scandit scandit-container";
  BarcodePickerGui.parentElementClassName = "scandit scandit-barcode-picker";
  BarcodePickerGui.hiddenClassName = "scandit-hidden";
  BarcodePickerGui.hiddenOpacityClassName = "scandit-hidden-opacity";
  BarcodePickerGui.videoElementClassName = "scandit-video";
  BarcodePickerGui.scanditLogoImageElementClassName = "scandit-logo";
  BarcodePickerGui.laserImageElementClassName = "scandit-laser";
  BarcodePickerGui.viewfinderElementClassName = "scandit-viewfinder";
  BarcodePickerGui.cameraSwitcherElementClassName = "scandit-camera-switcher";
  BarcodePickerGui.torchTogglerElementClassName = "scandit-torch-toggle";
  BarcodePickerGui.cameraUploadElementClassName = "scandit-camera-upload";
  BarcodePickerGui.flashColorClassName = "scandit-flash-color";
  BarcodePickerGui.flashWhiteClassName = "scandit-flash-white";
  BarcodePickerGui.flashWhiteInsetClassName = "scandit-flash-white-inset";
  BarcodePickerGui.opacityPulseClassName = "scandit-opacity-pulse";
  BarcodePickerGui.mirroredClassName = "mirrored";
  BarcodePickerGui.pausedClassName = "paused";
  var DummyCameraManager = (function(_CameraManager) {
    inherits(DummyCameraManager, _CameraManager);
    function DummyCameraManager() {
      classCallCheck(this, DummyCameraManager);
      return possibleConstructorReturn(this, getPrototypeOf$2(DummyCameraManager).apply(this, arguments));
    }
    createClass(DummyCameraManager, [
      {
        key: "setInteractionOptions",
        value: function setInteractionOptions(_1, _2, _3, _4) {
          return;
        }
      },
      {
        key: "isCameraSwitcherEnabled",
        value: function isCameraSwitcherEnabled() {
          return false;
        }
      },
      {
        key: "setCameraSwitcherEnabled",
        value: function setCameraSwitcherEnabled(_1) {
          return promise$1.resolve();
        }
      },
      {
        key: "isTorchToggleEnabled",
        value: function isTorchToggleEnabled() {
          return false;
        }
      },
      {
        key: "setTorchToggleEnabled",
        value: function setTorchToggleEnabled(_1) {
          return;
        }
      },
      {
        key: "isTapToFocusEnabled",
        value: function isTapToFocusEnabled() {
          return false;
        }
      },
      {
        key: "setTapToFocusEnabled",
        value: function setTapToFocusEnabled(_1) {
          return;
        }
      },
      {
        key: "isPinchToZoomEnabled",
        value: function isPinchToZoomEnabled() {
          return false;
        }
      },
      {
        key: "setPinchToZoomEnabled",
        value: function setPinchToZoomEnabled(_1) {
          return;
        }
      },
      {
        key: "setSelectedCamera",
        value: function setSelectedCamera(_1) {
          return;
        }
      },
      {
        key: "setSelectedCameraSettings",
        value: function setSelectedCameraSettings(_1) {
          return;
        }
      },
      {
        key: "setupCameras",
        value: function setupCameras() {
          return promise$1.resolve();
        }
      },
      {
        key: "stopStream",
        value: function stopStream() {
          return;
        }
      },
      {
        key: "applyCameraSettings",
        value: function applyCameraSettings(_1) {
          return promise$1.resolve();
        }
      },
      {
        key: "reinitializeCamera",
        value: function reinitializeCamera(_1) {
          return promise$1.resolve();
        }
      },
      {
        key: "initializeCameraWithSettings",
        value: function initializeCameraWithSettings(_1, _2) {
          return promise$1.resolve();
        }
      },
      {
        key: "setTorchEnabled",
        value: function setTorchEnabled(_1) {
          return;
        }
      },
      {
        key: "toggleTorch",
        value: function toggleTorch() {
          return;
        }
      },
      {
        key: "setZoom",
        value: function setZoom(_1, _2) {
          return;
        }
      }
    ]);
    return DummyCameraManager;
  })(CameraManager);
  var $JSON$1 = _core$1.JSON || (_core$1.JSON = { stringify: JSON.stringify });
  var stringify = function stringify(it) {
    return $JSON$1.stringify.apply($JSON$1, arguments);
  };
  var stringify$1 = stringify;
  function engine() {
    var dbName = "scandit_wasm_cache";
    var dbStoreName = "scandit_wasm_cache";
    var dbStoreKey = "wasm";
    var scanQueue = [];
    var parseQueue = [];
    var gpuAccelerationAvailable = "function" === typeof self.OffscreenCanvas;
    var imageBufferPointer;
    var licenseKey;
    var settings;
    var imageSettings;
    var scanWorkSubmitted = false;
    var wasmLoaded = false;
    var scannerSettingsReady = false;
    var scannerImageSettingsReady = false;
    var contextAvailable = false;
    var blurryDecodingEnabled = false;
    var fsSyncInProgress;
    var fsSyncScheduled = false;
    var db;
    function loadLibrary(deviceId, libraryLocation, locationPath) {
      var _getLibraryLocationUR = getLibraryLocationURIs(libraryLocation),
        jsURI = _getLibraryLocationUR.jsURI,
        wasmURI = _getLibraryLocationUR.wasmURI;
      var customModule = {
        arguments: [deviceId],
        canvas: gpuAccelerationAvailable ? new self.OffscreenCanvas(32, 32) : void 0,
        instantiateWasm: function instantiateWasm(importObject, successCallback) {
          var wasmJSVersion = self.wasmJSVersion;
          if (null == wasmJSVersion) wasmJSVersion = "undefined";
          if ("4.1.1" !== wasmJSVersion)
            console.error(
              "The Scandit SDK Engine library JS file found at ".concat(jsURI, " seems invalid: ") +
                "expected version doesn't match (received: ".concat(wasmJSVersion, ", expected: ", "4.1.1", "). ") +
                "Please ensure the correct Scandit SDK Engine file (with correct version) is retrieved."
            );
          var wasmVersion = "4.1.1"
            .split(".")
            .map(function(n, i) {
              return parseInt(n, 10) * Math.pow(10, 6 - 3 * i);
            })
            .reduce(function(a, b) {
              return a + b;
            });
          instantiateWasmWithCache(wasmURI, wasmVersion, importObject, successCallback);
          return {};
        },
        noInitialRun: true,
        preRun: function preRun() {
          try {
            FS.mkdir("/scandit_sync_folder");
          } catch (error) {
            if ("EEXIST" !== error.code) throw error;
          }
          FS.mount(IDBFS, {}, "/scandit_sync_folder");
          FS.syncfs(true, function() {
            Module.callMain();
            wasmLoaded = true;
            postMessage(["status", "ready"]);
            workOnScanQueue();
            workOnParseQueue();
          });
        }
      };
      self.window = self.document = self;
      self.Module = customModule;
      self.path = locationPath;
      try {
        return importScripts(jsURI);
      } catch (error) {
        console.warn(error);
        console.error(
          "Couldn't retrieve Scandit SDK Engine library at ".concat(
            jsURI,
            ", did you configure the path for it correctly?"
          )
        );
        return Promise.reject(error);
      }
    }
    function createContext(newLicenseKey) {
      licenseKey = newLicenseKey;
      if (contextAvailable || null == licenseKey || !wasmLoaded) return;
      var licenseKeyLength = Module.lengthBytesUTF8(licenseKey) + 1;
      var licenseKeyPointer = Module._malloc(licenseKeyLength);
      Module.stringToUTF8(licenseKey, licenseKeyPointer, licenseKeyLength);
      Module._create_context(licenseKeyPointer, false);
      Module._free(licenseKeyPointer);
      contextAvailable = true;
    }
    function setBlurryDecodingEnabled(enabled) {
      blurryDecodingEnabled = enabled;
      applySettings();
    }
    function setSettings(newSettings) {
      settings = newSettings;
      applySettings();
    }
    function setImageSettings(newImageSettings) {
      imageSettings = newImageSettings;
      applyImageSettings();
    }
    function workOnScanQueue() {
      if ((!scannerSettingsReady || !scannerImageSettingsReady) && 0 !== scanQueue.length) {
        createContext(licenseKey);
        applySettings();
        applyImageSettings();
      }
      if (!scannerSettingsReady || !scannerImageSettingsReady || 0 === scanQueue.length) return;
      var currentScanWorkUnit;
      var resultData;
      while (0 !== scanQueue.length) {
        currentScanWorkUnit = scanQueue.shift();
        if (currentScanWorkUnit.highQualitySingleFrameMode) applySettings(true);
        if (1 === imageSettings.format.valueOf())
          resultData = scanImage(convertImageDataToGrayscale(currentScanWorkUnit.data, 3));
        else if (2 === imageSettings.format.valueOf())
          resultData = scanImage(convertImageDataToGrayscale(currentScanWorkUnit.data, 4));
        else resultData = scanImage(currentScanWorkUnit.data);
        if (currentScanWorkUnit.highQualitySingleFrameMode) applySettings(false);
        var result = JSON.parse(resultData);
        if (null != result.error)
          postMessage(["work-error", { requestId: currentScanWorkUnit.requestId, error: result.error }]);
        else if (null != result.scanResult) {
          if (result.scanResult.length > 0 || null == fsSyncInProgress) syncFS();
          postMessage(["work-result", { requestId: currentScanWorkUnit.requestId, result: result }]);
        } else {
          console.error("Unrecognized Scandit Engine result:", result);
          postMessage([""], [currentScanWorkUnit.data.buffer]);
        }
      }
    }
    function workOnParseQueue() {
      if (!contextAvailable && 0 !== parseQueue.length) createContext(licenseKey);
      if (!contextAvailable || !wasmLoaded || 0 === parseQueue.length) return;
      var currentParseWorkUnit;
      var resultData;
      while (0 !== parseQueue.length) {
        currentParseWorkUnit = parseQueue.shift();
        resultData = parseString(
          currentParseWorkUnit.dataFormat,
          currentParseWorkUnit.dataString,
          currentParseWorkUnit.options
        );
        var result = JSON.parse(resultData);
        if (null != result.error)
          postMessage(["parse-string-error", { requestId: currentParseWorkUnit.requestId, error: result.error }]);
        else if (null != result.result)
          postMessage(["parse-string-result", { requestId: currentParseWorkUnit.requestId, result: result.result }]);
        else {
          console.error("Unrecognized Scandit Parser result:", result);
          postMessage([
            "parse-string-error",
            {
              requestId: currentParseWorkUnit.requestId,
              error: { errorCode: -1, errorMessage: "Unknown Scandit Parser error" }
            }
          ]);
        }
      }
      syncFS();
    }
    function addScanWorkUnit(scanWorkUnit) {
      scanWorkSubmitted = true;
      scanQueue.push(scanWorkUnit);
      workOnScanQueue();
    }
    function addParseWorkUnit(parseWorkUnit) {
      parseQueue.push(parseWorkUnit);
      workOnParseQueue();
    }
    function clearSession() {
      if (scannerSettingsReady) Module._scanner_session_clear();
    }
    function getLibraryLocationURIs(libraryLocation) {
      var cdnURI = false;
      if (/^http(s):\/\/([^\/.]*\.)*cdn.jsdelivr.net\//.test(libraryLocation)) {
        libraryLocation = "https://cdn.jsdelivr.net/npm/scandit-sdk@4.1.1/build/";
        cdnURI = true;
      } else if (/^http(s):\/\/([^\/.]*\.)*unpkg.com\//.test(libraryLocation)) {
        libraryLocation = "https://unpkg.com/scandit-sdk@4.1.1/build/";
        cdnURI = true;
      }
      if (cdnURI)
        return {
          jsURI: "".concat(libraryLocation, "scandit-engine-sdk.min.js"),
          wasmURI: "".concat(libraryLocation, "scandit-engine-sdk.wasm")
        };
      return {
        jsURI: "".concat(libraryLocation, "scandit-engine-sdk.min.js?v=4.1.1"),
        wasmURI: "".concat(libraryLocation, "scandit-engine-sdk.wasm?v=4.1.1")
      };
    }
    function arrayBufferToHexString(arrayBuffer) {
      return Array.from(new Uint8Array(arrayBuffer))
        .map(function(byteNumber) {
          var byteHex = byteNumber.toString(16);
          return 1 === byteHex.length ? "0".concat(byteHex) : byteHex;
        })
        .join("");
    }
    function applySettings() {
      var highQualitySingleFrameMode = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
      if (null == settings || !contextAvailable || !wasmLoaded || !scanWorkSubmitted) return;
      scannerSettingsReady = false;
      var parsedSettings = JSON.parse(settings);
      var settingsLength = Module.lengthBytesUTF8(settings) + 1;
      var settingsPointer = Module._malloc(settingsLength);
      Module.stringToUTF8(settings, settingsPointer, settingsLength);
      var resultPointer = Module._scanner_settings_new_from_json(
        settingsPointer,
        blurryDecodingEnabled,
        parsedSettings.matrixScanEnabled,
        highQualitySingleFrameMode,
        gpuAccelerationAvailable && parsedSettings.gpuAcceleration
      );
      Module._free(settingsPointer);
      var result = Module.UTF8ToString(resultPointer);
      if ("" !== result) {
        scannerSettingsReady = true;
        console.debug(JSON.parse(result));
      }
    }
    function applyImageSettings() {
      if (null == imageSettings || !wasmLoaded || !scanWorkSubmitted) return;
      scannerImageSettingsReady = false;
      Module._scanner_image_settings_new(imageSettings.width, imageSettings.height, 1);
      if (null != imageBufferPointer) {
        Module._free(imageBufferPointer);
        imageBufferPointer = void 0;
      }
      imageBufferPointer = Module._malloc(imageSettings.width * imageSettings.height);
      scannerImageSettingsReady = true;
    }
    function convertImageDataToGrayscale(imageData, channels) {
      var grayscaleImageData = new Uint8ClampedArray(imageData.length / channels);
      var grayscaleImageDataIndex = imageData.length / channels - 1;
      var imageDataIndex = imageData.length - channels;
      while (imageDataIndex >= 0) {
        grayscaleImageData[grayscaleImageDataIndex--] =
          0.299 * imageData[imageDataIndex] +
          0.587 * imageData[imageDataIndex + 1] +
          0.114 * imageData[imageDataIndex + 2];
        imageDataIndex -= channels;
      }
      return grayscaleImageData;
    }
    function scanImage(imageData) {
      Module.HEAPU8.set(imageData, imageBufferPointer);
      return Module.UTF8ToString(Module._scanner_scan(imageBufferPointer));
    }
    function parseString(dataFormat, dataString, options) {
      var dataStringLength = Module.lengthBytesUTF8(dataString) + 1;
      var dataStringPointer = Module._malloc(dataStringLength);
      Module.stringToUTF8(dataString, dataStringPointer, dataStringLength);
      var optionsLength = Module.lengthBytesUTF8(options) + 1;
      var optionsPointer = Module._malloc(optionsLength);
      Module.stringToUTF8(options, optionsPointer, optionsLength);
      var resultPointer = Module._parser_parse_string(
        dataFormat.valueOf(),
        dataStringPointer,
        dataStringLength - 1,
        optionsPointer
      );
      Module._free(dataStringPointer);
      Module._free(optionsPointer);
      return Module.UTF8ToString(resultPointer);
    }
    function loadDatabase(wasmVersion, resolve, reject) {
      var openDBRequest;
      try {
        openDBRequest = indexedDB.open(dbName, wasmVersion);
      } catch (error) {
        return reject("Failed to open scandit-sdk WebAssembly cache database: ".concat(error));
      }
      openDBRequest.onerror = function() {
        return reject("Failed to open scandit-sdk WebAssembly cache database");
      };
      openDBRequest.onsuccess = function() {
        db = openDBRequest.result;
        var store = db.transaction([dbStoreName]).objectStore(dbStoreName);
        var request = store.get(dbStoreKey);
        request.onerror = function() {
          return reject("Failed to open scandit-sdk WebAssembly cache database");
        };
        request.onsuccess = function() {
          if (null != request.result) return resolve(request.result);
          else return reject("No cached version of the scandit-sdk WebAssembly code has been found");
        };
      };
      openDBRequest.onupgradeneeded = function() {
        db = openDBRequest.result;
        if (db.objectStoreNames.contains(dbStoreName)) db.deleteObjectStore(dbStoreName);
        db.createObjectStore(dbStoreName);
      };
    }
    function storeWebAssemblyInDatabase(moduleObject) {
      try {
        var store = db.transaction([dbStoreName], "readwrite").objectStore(dbStoreName);
        var request = store.put(moduleObject, dbStoreKey);
        request.onerror = function(error) {
          console.debug("Failed to cache scandit-sdk WebAssembly code: ".concat(error));
        };
        request.onsuccess = function() {
          console.debug("Successfully cached scandit-sdk WebAssembly code");
        };
      } catch (error) {
        if ("DataCloneError" === error.name)
          console.debug("Could not cache scandit-sdk WebAssembly code: This browser doesn't support this feature yet");
        else console.debug("Failed to cache scandit-sdk WebAssembly code: ".concat(error));
      }
    }
    function verifiedWasmFetch(wasmURI) {
      return fetch(wasmURI).then(function(response) {
        response
          .clone()
          .arrayBuffer()
          .then(function(responseData) {
            crypto.subtle.digest("SHA-256", responseData).then(function(hash) {
              var hashString = arrayBufferToHexString(hash);
              if ("b41063919c158e206174957e102376eaa39c83fa692e00ecbd10763bc2fc420f" !== hashString)
                console.error(
                  "The Scandit SDK Engine library WASM file found at ".concat(wasmURI, " seems invalid: ") +
                    "expected file hash doesn't match (received: ".concat(hashString, ", ") +
                    "expected: ".concat("b41063919c158e206174957e102376eaa39c83fa692e00ecbd10763bc2fc420f", "). ") +
                    "Please ensure the correct Scandit SDK Engine file (with correct version) is retrieved."
                );
            });
          });
        return response;
      });
    }
    function instantiateWebAssembly(importObject, wasmURI, successCallback, wasmRequest) {
      if (null == wasmRequest) wasmRequest = verifiedWasmFetch(wasmURI);
      wasmRequest
        .then(function(response) {
          return response.arrayBuffer();
        })
        .then(function(bytes) {
          return self.WebAssembly.instantiate(bytes, importObject).then(function(results) {
            if (null != db) storeWebAssemblyInDatabase(results.module);
            successCallback(results.instance);
          });
        })
        .catch(function(error) {
          console.warn(error);
          console.error(
            "Couldn't retrieve Scandit SDK Engine library at ".concat(
              wasmURI,
              ", did you configure the path for it correctly?"
            )
          );
        });
    }
    function instantiateWebAssemblyStreaming(importObject, wasmURI, successCallback) {
      var wasmRequest = verifiedWasmFetch(wasmURI);
      self.WebAssembly.instantiateStreaming(wasmRequest, importObject)
        .then(function(results) {
          if (null != db) storeWebAssemblyInDatabase(results.module);
          successCallback(results.instance);
        })
        .catch(function(error) {
          console.warn(
            "WebAssembly streaming compile failed: ".concat(error, ". Falling back to ArrayBuffer instantiation") +
              "(this will make things slower)"
          );
          instantiateWebAssembly(importObject, wasmURI, successCallback, wasmRequest);
        });
    }
    function instantiateWasmWithCache(wasmURI, wasmVersion, importObject, successCallback) {
      loadDatabase(
        wasmVersion,
        function(moduleObject) {
          console.debug("Found cached scandit-sdk WebAssembly code");
          self.WebAssembly.instantiate(moduleObject, importObject).then(function(instance) {
            successCallback(instance);
          });
        },
        function(errMsg) {
          console.debug(errMsg);
          if ("function" === typeof self.WebAssembly.instantiateStreaming)
            instantiateWebAssemblyStreaming(importObject, wasmURI, successCallback);
          else instantiateWebAssembly(importObject, wasmURI, successCallback);
        }
      );
    }
    function syncFS() {
      if (true === fsSyncInProgress) fsSyncScheduled = true;
      else {
        fsSyncInProgress = true;
        fsSyncScheduled = false;
        FS.syncfs(false, function() {
          fsSyncInProgress = false;
          if (fsSyncScheduled) syncFS();
        });
      }
    }
    return {
      loadLibrary: loadLibrary,
      createContext: createContext,
      setBlurryDecodingEnabled: setBlurryDecodingEnabled,
      setSettings: setSettings,
      setImageSettings: setImageSettings,
      workOnScanQueue: workOnScanQueue,
      workOnParseQueue: workOnParseQueue,
      addScanWorkUnit: addScanWorkUnit,
      addParseWorkUnit: addParseWorkUnit,
      clearSession: clearSession
    };
  }
  function engineWorkerFunction() {
    var engineInstance = engine();
    onmessage = function onmessage(e) {
      var data = e.data;
      switch (data.type) {
        case "enable-blurry-decoding":
          engineInstance.setBlurryDecodingEnabled(true);
          engineInstance.workOnScanQueue();
          break;
        case "load-library":
          engineInstance.loadLibrary(data.deviceId, data.libraryLocation, data.path);
          break;
        case "license-key":
          engineInstance.createContext(data.licenseKey);
          engineInstance.workOnParseQueue();
          break;
        case "settings":
          engineInstance.setSettings(data.settings);
          engineInstance.workOnScanQueue();
          break;
        case "image-settings":
          engineInstance.setImageSettings(data.imageSettings);
          engineInstance.workOnScanQueue();
          break;
        case "work":
          engineInstance.addScanWorkUnit({
            requestId: data.requestId,
            data: data.data,
            highQualitySingleFrameMode: data.highQualitySingleFrameMode
          });
          break;
        case "parse-string":
          engineInstance.addParseWorkUnit({
            requestId: data.requestId,
            dataFormat: data.dataFormat,
            dataString: data.dataString,
            options: data.options
          });
          break;
        case "clear-session":
          engineInstance.clearSession();
      }
    };
  }
  var engineWorkerBlob = new Blob(["".concat(engine.toString(), "(").concat(engineWorkerFunction.toString(), ")()")], {
    type: "text/javascript"
  });
  exports.Parser = (function() {
    function Parser(scanner, dataFormat) {
      classCallCheck(this, Parser);
      this.scanner = scanner;
      this.dataFormat = dataFormat;
    }
    createClass(Parser, [
      {
        key: "setOptions",
        value: function setOptions(options) {
          this.options = options;
        }
      },
      {
        key: "parseRawData",
        value: function parseRawData(dataRaw) {
          var dataString = "";
          try {
            dataRaw.forEach(function(byte) {
              dataString += String.fromCharCode(byte);
            });
            dataString = decodeURIComponent(escape(dataString));
          } catch (error) {
            dataString = "";
          }
          return this.scanner.parseString(this.dataFormat, dataString, this.options);
        }
      },
      {
        key: "parseString",
        value: function parseString(dataString) {
          return this.scanner.parseString(this.dataFormat, dataString, this.options);
        }
      }
    ]);
    return Parser;
  })();
  (function(Parser) {
    (function(DataFormat) {
      DataFormat[(DataFormat["GS1_AI"] = 1)] = "GS1_AI";
      DataFormat[(DataFormat["HIBC"] = 2)] = "HIBC";
      DataFormat[(DataFormat["DLID"] = 3)] = "DLID";
      DataFormat[(DataFormat["MRTD"] = 4)] = "MRTD";
      DataFormat[(DataFormat["SWISSQR"] = 5)] = "SWISSQR";
    })(Parser.DataFormat || (Parser.DataFormat = {}));
  })(exports.Parser || (exports.Parser = {}));
  var core_getIterator = (_core$1.getIterator = function(it) {
    var iterFn = core_getIteratorMethod(it);
    if ("function" != typeof iterFn) throw TypeError(it + " is not iterable!");
    return _anObject$1(iterFn.call(it));
  });
  var getIterator = core_getIterator;
  var getIterator$1 = getIterator;
  var isEnum$1 = _objectPie.f;
  var _objectToArray = function(isEntries) {
    return function(it) {
      var O = _toIobject(it);
      var keys = _objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) if (isEnum$1.call(O, (key = keys[i++]))) result.push(isEntries ? [key, O[key]] : O[key]);
      return result;
    };
  };
  var $values = _objectToArray(false);
  _export(_export.S, "Object", {
    values: function values(it) {
      return $values(it);
    }
  });
  var values = _core$1.Object.values;
  var values$1 = values;
  var SET = "Set";
  _collection(
    SET,
    function(get) {
      return function Set() {
        return get(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    },
    {
      add: function add(value) {
        return _collectionStrong.def(_validateCollection(this, SET), (value = 0 === value ? 0 : value), value);
      }
    },
    _collectionStrong
  );
  _export(_export.P + _export.R, "Set", { toJSON: _collectionToJson("Set") });
  _setCollectionOf("Set");
  _setCollectionFrom("Set");
  var set = _core$1.Set;
  var set$1 = set;
  exports.SymbologySettings = (function() {
    function SymbologySettings() {
      var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        _ref$enabled = _ref.enabled,
        enabled = void 0 === _ref$enabled ? false : _ref$enabled,
        _ref$colorInvertedEna = _ref.colorInvertedEnabled,
        colorInvertedEnabled = void 0 === _ref$colorInvertedEna ? false : _ref$colorInvertedEna,
        _ref$activeSymbolCoun = _ref.activeSymbolCounts,
        activeSymbolCounts = void 0 === _ref$activeSymbolCoun ? [] : _ref$activeSymbolCoun,
        extensions = _ref.extensions,
        checksums = _ref.checksums;
      classCallCheck(this, SymbologySettings);
      this.enabled = enabled;
      this.colorInvertedEnabled = colorInvertedEnabled;
      this.activeSymbolCounts = activeSymbolCounts;
      this.customExtensions = null != extensions;
      this.customChecksums = null != checksums;
      if (null == extensions) extensions = [];
      if (null == checksums) checksums = [];
      this.extensions = new set$1(
        from_1$1(extensions).filter(function(e) {
          return (
            e in SymbologySettings.Extension || -1 !== values$1(SymbologySettings.Extension).indexOf(e.toLowerCase())
          );
        })
      );
      this.checksums = new set$1(
        from_1$1(checksums).filter(function(c) {
          return (
            c in SymbologySettings.Checksum || -1 !== values$1(SymbologySettings.Checksum).indexOf(c.toLowerCase())
          );
        })
      );
    }
    createClass(SymbologySettings, [
      {
        key: "isEnabled",
        value: function isEnabled() {
          return this.enabled;
        }
      },
      {
        key: "setEnabled",
        value: function setEnabled(enabled) {
          this.enabled = enabled;
          return this;
        }
      },
      {
        key: "isColorInvertedEnabled",
        value: function isColorInvertedEnabled() {
          return this.colorInvertedEnabled;
        }
      },
      {
        key: "setColorInvertedEnabled",
        value: function setColorInvertedEnabled(enabled) {
          this.colorInvertedEnabled = enabled;
          return this;
        }
      },
      {
        key: "getActiveSymbolCounts",
        value: function getActiveSymbolCounts() {
          return this.activeSymbolCounts;
        }
      },
      {
        key: "setActiveSymbolCounts",
        value: function setActiveSymbolCounts(activeSymbolCounts) {
          this.activeSymbolCounts = activeSymbolCounts;
          return this;
        }
      },
      {
        key: "setActiveSymbolCountsRange",
        value: function setActiveSymbolCountsRange(minCount, maxCount) {
          this.activeSymbolCounts = from_1$1({ length: maxCount - minCount + 1 }, function(_, k) {
            return k + minCount;
          });
          return this;
        }
      },
      {
        key: "getEnabledExtensions",
        value: function getEnabledExtensions() {
          return this.extensions;
        }
      },
      {
        key: "enableExtensions",
        value: function enableExtensions(extension) {
          this.customExtensions = true;
          if ("object" === _typeof_1(extension))
            this.extensions = new set$1(
              toConsumableArray(this.extensions).concat(
                toConsumableArray(
                  from_1$1(extension).filter(function(e) {
                    return (
                      e in SymbologySettings.Extension ||
                      -1 !== values$1(SymbologySettings.Extension).indexOf(e.toLowerCase())
                    );
                  })
                )
              )
            );
          else if (
            extension in SymbologySettings.Extension ||
            -1 !== values$1(SymbologySettings.Extension).indexOf(extension.toLowerCase())
          )
            this.extensions.add(extension);
          return this;
        }
      },
      {
        key: "disableExtensions",
        value: function disableExtensions(extension) {
          if ("object" === _typeof_1(extension))
            this.extensions = new set$1(
              toConsumableArray(this.extensions).filter(function(x) {
                return extension instanceof Array ? -1 === extension.indexOf(x) : !extension.has(x);
              })
            );
          else this.extensions.delete(extension);
          return this;
        }
      },
      {
        key: "getEnabledChecksums",
        value: function getEnabledChecksums() {
          return this.checksums;
        }
      },
      {
        key: "enableChecksums",
        value: function enableChecksums(checksum) {
          this.customChecksums = true;
          if ("object" === _typeof_1(checksum))
            this.checksums = new set$1(
              toConsumableArray(this.checksums).concat(
                toConsumableArray(
                  from_1$1(checksum).filter(function(c) {
                    return (
                      c in SymbologySettings.Checksum ||
                      -1 !== values$1(SymbologySettings.Checksum).indexOf(c.toLowerCase())
                    );
                  })
                )
              )
            );
          else if (
            checksum in SymbologySettings.Checksum ||
            -1 !== values$1(SymbologySettings.Checksum).indexOf(checksum.toLowerCase())
          )
            this.checksums.add(checksum);
          return this;
        }
      },
      {
        key: "disableChecksums",
        value: function disableChecksums(checksum) {
          if ("object" === _typeof_1(checksum))
            this.checksums = new set$1(
              toConsumableArray(this.checksums).filter(function(x) {
                return checksum instanceof Array ? -1 === checksum.indexOf(x) : !checksum.has(x);
              })
            );
          else this.checksums.delete(checksum);
          return this;
        }
      },
      {
        key: "toJSON",
        value: function toJSON() {
          return {
            enabled: this.enabled,
            colorInvertedEnabled: this.colorInvertedEnabled,
            activeSymbolCounts: 0 === this.activeSymbolCounts.length ? void 0 : this.activeSymbolCounts,
            extensions: this.customExtensions ? from_1$1(this.extensions) : void 0,
            checksums: this.customChecksums ? from_1$1(this.checksums) : void 0
          };
        }
      }
    ]);
    return SymbologySettings;
  })();
  (function(SymbologySettings) {
    (function(Extension) {
      Extension["DIRECT_PART_MARKING_MODE"] = "direct_part_marking_mode";
      Extension["FULL_ASCII"] = "full_ascii";
      Extension["RELAXED_SHARP_QUIET_ZONE_CHECK"] = "relaxed_sharp_quiet_zone_check";
      Extension["REMOVE_LEADING_ZERO"] = "remove_leading_zero";
      Extension["REMOVE_LEADING_UPCA_ZERO"] = "remove_leading_upca_zero";
      Extension["RETURN_AS_UPCA"] = "return_as_upca";
      Extension["STRIP_LEADING_FNC1"] = "strip_leading_fnc1";
    })(SymbologySettings.Extension || (SymbologySettings.Extension = {}));
    (function(Checksum) {
      Checksum["MOD_10"] = "mod10";
      Checksum["MOD_11"] = "mod11";
      Checksum["MOD_16"] = "mod16";
      Checksum["MOD_43"] = "mod43";
      Checksum["MOD_47"] = "mod47";
      Checksum["MOD_103"] = "mod103";
      Checksum["MOD_1010"] = "mod1010";
      Checksum["MOD_1110"] = "mod1110";
    })(SymbologySettings.Checksum || (SymbologySettings.Checksum = {}));
  })(exports.SymbologySettings || (exports.SymbologySettings = {}));
  var ScanSettings = (function() {
    function ScanSettings() {
      var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        _ref$enabledSymbologi = _ref.enabledSymbologies,
        enabledSymbologies = void 0 === _ref$enabledSymbologi ? [] : _ref$enabledSymbologi,
        _ref$codeDuplicateFil = _ref.codeDuplicateFilter,
        codeDuplicateFilter = void 0 === _ref$codeDuplicateFil ? 0 : _ref$codeDuplicateFil,
        _ref$maxNumberOfCodes = _ref.maxNumberOfCodesPerFrame,
        maxNumberOfCodesPerFrame = void 0 === _ref$maxNumberOfCodes ? 1 : _ref$maxNumberOfCodes,
        _ref$searchArea = _ref.searchArea,
        searchArea = void 0 === _ref$searchArea ? { x: 0, y: 0, width: 1, height: 1 } : _ref$searchArea,
        _ref$gpuAcceleration = _ref.gpuAcceleration,
        gpuAcceleration = void 0 === _ref$gpuAcceleration ? true : _ref$gpuAcceleration;
      classCallCheck(this, ScanSettings);
      this.symbologySettings = new map$1();
      this.enableSymbologies(enabledSymbologies);
      this.codeDuplicateFilter = codeDuplicateFilter;
      this.maxNumberOfCodesPerFrame = maxNumberOfCodesPerFrame;
      this.baseSearchArea = { x: 0, y: 0, width: 1, height: 1 };
      this.searchArea = searchArea;
      this.gpuAcceleration = gpuAcceleration;
    }
    createClass(ScanSettings, [
      {
        key: "toJSONString",
        value: function toJSONString() {
          var symbologies = {};
          this.symbologySettings.forEach(function(symbologySettings, symbology) {
            symbologies[exports.Barcode.Symbology.toJSONName(symbology)] = symbologySettings;
          });
          var combinedSearchArea = {
            x: Math.min(1, this.baseSearchArea.x + this.searchArea.x * this.baseSearchArea.width),
            y: Math.min(1, this.baseSearchArea.y + this.searchArea.y * this.baseSearchArea.height),
            width: Math.min(1, this.baseSearchArea.width * this.searchArea.width),
            height: Math.min(1, this.baseSearchArea.height * this.searchArea.height)
          };
          var isFullSearchArea =
            0 === Math.round(100 * combinedSearchArea.x) &&
            0 === Math.round(100 * combinedSearchArea.y) &&
            100 === Math.round(100 * combinedSearchArea.width) &&
            100 === Math.round(100 * combinedSearchArea.height);
          return stringify$1({
            symbologies: symbologies,
            codeDuplicateFilter: this.codeDuplicateFilter,
            maxNumberOfCodesPerFrame: this.maxNumberOfCodesPerFrame,
            searchArea: combinedSearchArea,
            codeLocation1d: isFullSearchArea
              ? void 0
              : {
                  area: {
                    x: combinedSearchArea.x,
                    y: combinedSearchArea.y + (0.75 * combinedSearchArea.height) / 2,
                    width: combinedSearchArea.width,
                    height: 0.25 * combinedSearchArea.height
                  }
                },
            codeLocation2d: isFullSearchArea ? void 0 : { area: combinedSearchArea },
            gpuAcceleration: this.gpuAcceleration
          });
        }
      },
      {
        key: "getSymbologySettings",
        value: function getSymbologySettings(symbology) {
          if (this.symbologySettings.has(symbology)) return this.symbologySettings.get(symbology);
          else if (
            symbology in exports.Barcode.Symbology ||
            -1 !== values$1(exports.Barcode.Symbology).indexOf(symbology)
          ) {
            this.symbologySettings.set(symbology, new exports.SymbologySettings());
            return this.symbologySettings.get(symbology);
          } else throw new TypeError('Invalid symbology "'.concat(symbology, '"'));
        }
      },
      {
        key: "isSymbologyEnabled",
        value: function isSymbologyEnabled(symbology) {
          return this.getSymbologySettings(symbology).isEnabled();
        }
      },
      {
        key: "enableSymbologies",
        value: function enableSymbologies(symbology) {
          return this.setSymbologiesEnabled(symbology, true);
        }
      },
      {
        key: "disableSymbologies",
        value: function disableSymbologies(symbology) {
          return this.setSymbologiesEnabled(symbology, false);
        }
      },
      {
        key: "getCodeDuplicateFilter",
        value: function getCodeDuplicateFilter() {
          return this.codeDuplicateFilter;
        }
      },
      {
        key: "setCodeDuplicateFilter",
        value: function setCodeDuplicateFilter(durationMilliseconds) {
          this.codeDuplicateFilter = durationMilliseconds;
          return this;
        }
      },
      {
        key: "getMaxNumberOfCodesPerFrame",
        value: function getMaxNumberOfCodesPerFrame() {
          return this.maxNumberOfCodesPerFrame;
        }
      },
      {
        key: "setMaxNumberOfCodesPerFrame",
        value: function setMaxNumberOfCodesPerFrame(limit) {
          this.maxNumberOfCodesPerFrame = limit;
          return this;
        }
      },
      {
        key: "getSearchArea",
        value: function getSearchArea() {
          return this.searchArea;
        }
      },
      {
        key: "setSearchArea",
        value: function setSearchArea(searchArea) {
          this.searchArea = searchArea;
          return this;
        }
      },
      {
        key: "getBaseSearchArea",
        value: function getBaseSearchArea() {
          return this.baseSearchArea;
        }
      },
      {
        key: "setBaseSearchArea",
        value: function setBaseSearchArea(baseSearchArea) {
          this.baseSearchArea = baseSearchArea;
          return this;
        }
      },
      {
        key: "isGpuAccelerationEnabled",
        value: function isGpuAccelerationEnabled() {
          return this.gpuAcceleration;
        }
      },
      {
        key: "setGpuAccelerationEnabled",
        value: function setGpuAccelerationEnabled(enabled) {
          this.gpuAcceleration = enabled;
          return this;
        }
      },
      {
        key: "setSymbologiesEnabled",
        value: function setSymbologiesEnabled(symbology, enabled) {
          if ("object" === _typeof_1(symbology)) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (
                var _step, _iterator = getIterator$1(symbology);
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                var s = _step.value;
                if (!(s in exports.Barcode.Symbology || -1 !== values$1(exports.Barcode.Symbology).indexOf(s)))
                  throw new TypeError('Invalid symbology "'.concat(s, '"'));
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && null != _iterator.return) _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (
                var _step2, _iterator2 = getIterator$1(symbology);
                !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
                _iteratorNormalCompletion2 = true
              ) {
                var _s = _step2.value;
                if (this.symbologySettings.has(_s)) this.symbologySettings.get(_s).setEnabled(enabled);
                else this.symbologySettings.set(_s, new exports.SymbologySettings({ enabled: enabled }));
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && null != _iterator2.return) _iterator2.return();
              } finally {
                if (_didIteratorError2) throw _iteratorError2;
              }
            }
          } else if (
            symbology in exports.Barcode.Symbology ||
            -1 !== values$1(exports.Barcode.Symbology).indexOf(symbology)
          )
            if (this.symbologySettings.has(symbology)) this.symbologySettings.get(symbology).setEnabled(enabled);
            else this.symbologySettings.set(symbology, new exports.SymbologySettings({ enabled: enabled }));
          else throw new TypeError('Invalid symbology "'.concat(symbology, '"'));
          return this;
        }
      }
    ]);
    return ScanSettings;
  })();
  var Scanner$$1 = (function() {
    function Scanner$$1() {
      var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        _ref$scanSettings = _ref.scanSettings,
        scanSettings = void 0 === _ref$scanSettings ? new ScanSettings() : _ref$scanSettings,
        imageSettings = _ref.imageSettings;
      classCallCheck(this, Scanner$$1);
      var browserCompatibility = exports.BrowserHelper.checkBrowserCompatibility();
      if (!browserCompatibility.scannerSupport)
        throw new CustomError({
          name: "UnsupportedBrowserError",
          message: "This OS / Browser has one or more missing features preventing it from working correctly",
          data: browserCompatibility
        });
      if (null == exports.userLicenseKey || "" === exports.userLicenseKey.trim())
        throw new CustomError({
          name: "LibraryNotConfiguredError",
          message: "The library has not correctly been configured yet, please call 'configure' with valid parameters"
        });
      this.isReadyToWork = false;
      this.workerScanQueueLength = 0;
      this.engineWorker = new Worker(URL.createObjectURL(engineWorkerBlob));
      this.engineWorker.onmessage = this.engineWorkerOnMessage.bind(this);
      this.engineWorker.postMessage({
        type: "load-library",
        deviceId: deviceId,
        libraryLocation: exports.scanditEngineLocation,
        path: self.location.pathname
      });
      this.eventEmitter = new eventemitter3_1();
      this.workerParseRequestId = 0;
      this.workerScanRequestId = 0;
      this.applyLicenseKey(exports.userLicenseKey);
      this.applyScanSettings(scanSettings);
      if (null != imageSettings) this.applyImageSettings(imageSettings);
    }
    createClass(Scanner$$1, [
      {
        key: "destroy",
        value: function destroy() {
          if (null != this.engineWorker) this.engineWorker.terminate();
          this.eventEmitter.removeAllListeners();
        }
      },
      {
        key: "applyScanSettings",
        value: function applyScanSettings(scanSettings) {
          this.scanSettings = scanSettings;
          this.engineWorker.postMessage({ type: "settings", settings: this.scanSettings.toJSONString() });
          return this;
        }
      },
      {
        key: "applyImageSettings",
        value: function applyImageSettings(imageSettings) {
          this.imageSettings = imageSettings;
          this.engineWorker.postMessage({ type: "image-settings", imageSettings: imageSettings });
          return this;
        }
      },
      {
        key: "clearSession",
        value: function clearSession() {
          this.engineWorker.postMessage({ type: "clear-session" });
          return this;
        }
      },
      {
        key: "processImage",
        value: function processImage(imageData) {
          var _this = this;
          var highQualitySingleFrameMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
          if (null == this.imageSettings)
            return promise$1.reject(
              new CustomError({ name: "NoImageSettings", message: "No image settings set up in the scanner" })
            );
          var channels;
          switch (this.imageSettings.format.valueOf()) {
            case exports.ImageSettings.Format.GRAY_8U:
              channels = 1;
              break;
            case exports.ImageSettings.Format.RGB_8U:
              channels = 3;
              break;
            case exports.ImageSettings.Format.RGBA_8U:
              channels = 4;
              break;
            default:
              channels = 1;
          }
          if (this.imageSettings.width * this.imageSettings.height * channels !== imageData.length)
            return promise$1.reject(
              new CustomError({
                name: "ImageSettingsDataMismatch",
                message: "The provided image data doesn't match the previously set image settings"
              })
            );
          this.workerScanRequestId++;
          this.workerScanQueueLength++;
          return new promise$1(function(resolve, reject) {
            var workResultEvent = "work-result-".concat(_this.workerScanRequestId);
            var workErrorEvent = "work-error-".concat(_this.workerScanRequestId);
            _this.eventEmitter.once(workResultEvent, function(workResult) {
              _this.eventEmitter.removeAllListeners(workErrorEvent);
              resolve({
                barcodes: workResult.scanResult.map(exports.Barcode.createFromWASMResult),
                imageData: imageData,
                imageSettings: _this.imageSettings
              });
            });
            _this.eventEmitter.once(workErrorEvent, function(error) {
              console.error("Scandit Engine error (".concat(error.errorCode, "):"), error.errorMessage);
              _this.eventEmitter.removeAllListeners(workResultEvent);
              var errorObject = new CustomError({
                name: "ScanditEngineError",
                message: "".concat(error.errorMessage, " (").concat(error.errorCode, ")")
              });
              reject(errorObject);
            });
            _this.engineWorker.postMessage({
              type: "work",
              requestId: _this.workerScanRequestId,
              data: imageData,
              highQualitySingleFrameMode: highQualitySingleFrameMode
            });
          });
        }
      },
      {
        key: "isBusyProcessing",
        value: function isBusyProcessing() {
          return 0 !== this.workerScanQueueLength;
        }
      },
      {
        key: "isReady",
        value: function isReady() {
          return this.isReadyToWork;
        }
      },
      {
        key: "onReady",
        value: function onReady(listener) {
          if (this.isReadyToWork) listener();
          else this.eventEmitter.once("ready", listener, this);
          return this;
        }
      },
      {
        key: "createParserForFormat",
        value: function createParserForFormat(dataFormat) {
          return new exports.Parser(this, dataFormat);
        }
      },
      {
        key: "getImageSettings",
        value: function getImageSettings() {
          return this.imageSettings;
        }
      },
      {
        key: "getScanSettings",
        value: function getScanSettings() {
          return this.scanSettings;
        }
      },
      {
        key: "parseString",
        value: function parseString(dataFormat, dataString, options) {
          var _this2 = this;
          this.workerParseRequestId++;
          return new promise$1(function(resolve, reject) {
            var parseStringResultEvent = "parse-string-result-".concat(_this2.workerParseRequestId);
            var parseStringErrorEvent = "parse-string-error-".concat(_this2.workerParseRequestId);
            _this2.eventEmitter.once(parseStringResultEvent, function(result) {
              _this2.eventEmitter.removeAllListeners(parseStringErrorEvent);
              var parserResult = { jsonString: result, fields: [], fieldsByName: {} };
              JSON.parse(result).forEach(function(parserField) {
                parserResult.fields.push(parserField);
                parserResult.fieldsByName[parserField.name] = parserField;
              });
              resolve(parserResult);
            });
            _this2.eventEmitter.once(parseStringErrorEvent, function(error) {
              console.error("Scandit Engine error (".concat(error.errorCode, "):"), error.errorMessage);
              _this2.eventEmitter.removeAllListeners(parseStringResultEvent);
              var errorObject = new CustomError({
                name: "ScanditEngineError",
                message: "".concat(error.errorMessage, " (").concat(error.errorCode, ")")
              });
              reject(errorObject);
            });
            _this2.engineWorker.postMessage({
              type: "parse-string",
              requestId: _this2.workerParseRequestId,
              dataFormat: dataFormat,
              dataString: dataString,
              options: null == options ? "{}" : stringify$1(options)
            });
          });
        }
      },
      {
        key: "applyLicenseKey",
        value: function applyLicenseKey(licenseKey) {
          this.engineWorker.postMessage({ type: "license-key", licenseKey: licenseKey });
          return this;
        }
      },
      {
        key: "engineWorkerOnMessage",
        value: function engineWorkerOnMessage(ev) {
          var messageType = ev.data[0];
          var messageData = ev.data[1];
          if ("status" === messageType) {
            if ("ready" === messageData) {
              this.isReadyToWork = true;
              this.eventEmitter.emit("ready");
            }
          } else if ("work-result" === messageType && null != messageData) {
            this.eventEmitter.emit("work-result-".concat(messageData.requestId), messageData.result);
            this.workerScanQueueLength--;
          } else if ("work-error" === messageType && null != messageData) {
            this.eventEmitter.emit("work-error-".concat(messageData.requestId), messageData.error);
            this.workerScanQueueLength--;
          } else if ("parse-string-result" === messageType && null != messageData)
            this.eventEmitter.emit("parse-string-result-".concat(messageData.requestId), messageData.result);
          else if ("parse-string-error" === messageType && null != messageData)
            this.eventEmitter.emit("parse-string-error-".concat(messageData.requestId), messageData.error);
        }
      }
    ]);
    return Scanner$$1;
  })();
  exports.BarcodePicker = (function() {
    function BarcodePicker(originElement, _ref) {
      var _this = this;
      var visible = _ref.visible,
        singleImageMode = _ref.singleImageMode,
        playSoundOnScan = _ref.playSoundOnScan,
        vibrateOnScan = _ref.vibrateOnScan,
        scanningPaused = _ref.scanningPaused,
        guiStyle = _ref.guiStyle,
        videoFit = _ref.videoFit,
        scanner = _ref.scanner,
        scanSettings = _ref.scanSettings,
        targetScanningFPS = _ref.targetScanningFPS;
      classCallCheck(this, BarcodePicker);
      this.isReadyToWork = false;
      this.destroyed = false;
      this.scanningPaused = scanningPaused;
      howler_core_min_1.autoSuspend = false;
      this.beepSound = new howler_core_min_2({ src: beepSound });
      this.vibrateFunction =
        navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
      this.eventEmitter = new eventemitter3_1();
      this.setPlaySoundOnScanEnabled(playSoundOnScan);
      this.setVibrateOnScanEnabled(vibrateOnScan);
      this.setTargetScanningFPS(targetScanningFPS);
      if (null == scanner) this.scanner = new Scanner$$1({ scanSettings: scanSettings });
      else {
        this.scanner = scanner;
        this.scanner.applyScanSettings(scanSettings);
      }
      this.scanner.onReady(function() {
        _this.isReadyToWork = true;
        _this.eventEmitter.emit("ready");
      });
      this.barcodePickerGui = new BarcodePickerGui(
        this.scanner,
        originElement,
        singleImageMode,
        scanningPaused,
        visible,
        guiStyle,
        videoFit,
        this.processVideoFrame.bind(this, true)
      );
      if (singleImageMode) this.cameraManager = new DummyCameraManager();
      else {
        this.scheduleVideoProcessing();
        this.cameraManager = new BarcodePickerCameraManager(this.triggerFatalError.bind(this), this.barcodePickerGui);
      }
      this.barcodePickerGui.setCameraManager(this.cameraManager);
    }
    createClass(
      BarcodePicker,
      [
        {
          key: "destroy",
          value: function destroy() {
            var destroyScanner = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
            this.pauseScanning(true);
            this.destroyed = true;
            if (destroyScanner) this.scanner.destroy();
            this.barcodePickerGui.destroy();
            this.eventEmitter.removeAllListeners();
          }
        },
        {
          key: "applyScanSettings",
          value: function applyScanSettings(scanSettings) {
            this.scanner.applyScanSettings(scanSettings);
            return this;
          }
        },
        {
          key: "isScanningPaused",
          value: function isScanningPaused() {
            return this.scanningPaused;
          }
        },
        {
          key: "pauseScanning",
          value: function pauseScanning() {
            var pauseCamera = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
            this.scanningPaused = true;
            if (pauseCamera) this.cameraManager.stopStream();
            if (this.scanner.isReady()) this.barcodePickerGui.pauseScanning();
            return this;
          }
        },
        {
          key: "resumeScanning",
          value: function resumeScanning() {
            var _this2 = this;
            this.scanningPaused = false;
            if (this.scanner.isReady()) this.barcodePickerGui.resumeScanning();
            if (null == this.cameraManager.activeCamera && this.cameraAccess)
              return this.cameraManager.setupCameras().then(function() {
                return _this2;
              });
            return promise$1.resolve(this);
          }
        },
        {
          key: "getActiveCamera",
          value: function getActiveCamera() {
            return this.cameraManager.activeCamera;
          }
        },
        {
          key: "setActiveCamera",
          value: function setActiveCamera(camera, cameraSettings) {
            var _this3 = this;
            if (null == camera || !this.cameraAccess) {
              this.cameraManager.setSelectedCamera(camera);
              this.cameraManager.setSelectedCameraSettings(cameraSettings);
              if (this.cameraAccess)
                return this.cameraManager.setupCameras().then(function() {
                  return _this3;
                });
              else return promise$1.resolve(this);
            } else
              return this.cameraManager.initializeCameraWithSettings(camera, cameraSettings).then(function() {
                return _this3;
              });
          }
        },
        {
          key: "applyCameraSettings",
          value: function applyCameraSettings(cameraSettings) {
            var _this4 = this;
            if (!this.cameraAccess) {
              this.cameraManager.setSelectedCameraSettings(cameraSettings);
              return promise$1.resolve(this);
            }
            return this.cameraManager.applyCameraSettings(cameraSettings).then(function() {
              return _this4;
            });
          }
        },
        {
          key: "isVisible",
          value: function isVisible() {
            return this.barcodePickerGui.isVisible();
          }
        },
        {
          key: "setVisible",
          value: function setVisible(visible) {
            this.barcodePickerGui.setVisible(visible);
            return this;
          }
        },
        {
          key: "isMirrorImageEnabled",
          value: function isMirrorImageEnabled() {
            return this.barcodePickerGui.isMirrorImageEnabled();
          }
        },
        {
          key: "setMirrorImageEnabled",
          value: function setMirrorImageEnabled(enabled) {
            this.barcodePickerGui.setMirrorImageEnabled(enabled, true);
            return this;
          }
        },
        {
          key: "isPlaySoundOnScanEnabled",
          value: function isPlaySoundOnScanEnabled() {
            return this.playSoundOnScan;
          }
        },
        {
          key: "setPlaySoundOnScanEnabled",
          value: function setPlaySoundOnScanEnabled(enabled) {
            this.playSoundOnScan = enabled;
            return this;
          }
        },
        {
          key: "isVibrateOnScanEnabled",
          value: function isVibrateOnScanEnabled() {
            return this.vibrateOnScan;
          }
        },
        {
          key: "setVibrateOnScanEnabled",
          value: function setVibrateOnScanEnabled(enabled) {
            this.vibrateOnScan = enabled;
            return this;
          }
        },
        {
          key: "isCameraSwitcherEnabled",
          value: function isCameraSwitcherEnabled() {
            return this.cameraManager.isCameraSwitcherEnabled();
          }
        },
        {
          key: "setCameraSwitcherEnabled",
          value: function setCameraSwitcherEnabled(enabled) {
            this.cameraManager.setCameraSwitcherEnabled(enabled);
            return this;
          }
        },
        {
          key: "isTorchToggleEnabled",
          value: function isTorchToggleEnabled() {
            return this.cameraManager.isTorchToggleEnabled();
          }
        },
        {
          key: "setTorchToggleEnabled",
          value: function setTorchToggleEnabled(enabled) {
            this.cameraManager.setTorchToggleEnabled(enabled);
            return this;
          }
        },
        {
          key: "isTapToFocusEnabled",
          value: function isTapToFocusEnabled() {
            return this.cameraManager.isTapToFocusEnabled();
          }
        },
        {
          key: "setTapToFocusEnabled",
          value: function setTapToFocusEnabled(enabled) {
            this.cameraManager.setTapToFocusEnabled(enabled);
            return this;
          }
        },
        {
          key: "isPinchToZoomEnabled",
          value: function isPinchToZoomEnabled() {
            return this.cameraManager.isPinchToZoomEnabled();
          }
        },
        {
          key: "setPinchToZoomEnabled",
          value: function setPinchToZoomEnabled(enabled) {
            this.cameraManager.setPinchToZoomEnabled(enabled);
            return this;
          }
        },
        {
          key: "setTorchEnabled",
          value: function setTorchEnabled(enabled) {
            this.cameraManager.setTorchEnabled(enabled);
            return this;
          }
        },
        {
          key: "setZoom",
          value: function setZoom(zoomPercentage) {
            this.cameraManager.setZoom(zoomPercentage);
            return this;
          }
        },
        {
          key: "isReady",
          value: function isReady() {
            return this.isReadyToWork;
          }
        },
        {
          key: "onReady",
          value: function onReady(listener) {
            if (this.isReadyToWork) listener();
            else this.eventEmitter.once("ready", listener, this);
            return this;
          }
        },
        {
          key: "onScan",
          value: function onScan(listener) {
            var once = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
            if (true === once) this.eventEmitter.once("scan", listener, this);
            else this.eventEmitter.on("scan", listener, this);
            return this;
          }
        },
        {
          key: "removeScanListener",
          value: function removeScanListener(listener) {
            this.eventEmitter.removeListener("scan", listener);
            return this;
          }
        },
        {
          key: "removeScanListeners",
          value: function removeScanListeners() {
            this.eventEmitter.removeAllListeners("scan");
            return this;
          }
        },
        {
          key: "onScanError",
          value: function onScanError(listener) {
            var once = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
            if (true === once) this.eventEmitter.once("scanError", listener, this);
            else this.eventEmitter.on("scanError", listener, this);
            return this;
          }
        },
        {
          key: "removeScanErrorListener",
          value: function removeScanErrorListener(listener) {
            this.eventEmitter.removeListener("scanError", listener);
            return this;
          }
        },
        {
          key: "removeScanErrorListeners",
          value: function removeScanErrorListeners() {
            this.eventEmitter.removeAllListeners("scanError");
            return this;
          }
        },
        {
          key: "onSubmitFrame",
          value: function onSubmitFrame(listener) {
            var once = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
            if (true === once) this.eventEmitter.once("submitFrame", listener, this);
            else this.eventEmitter.on("submitFrame", listener, this);
            return this;
          }
        },
        {
          key: "removeSubmitFrameListener",
          value: function removeSubmitFrameListener(listener) {
            this.eventEmitter.removeListener("submitFrame", listener);
            return this;
          }
        },
        {
          key: "removeSubmitFrameListeners",
          value: function removeSubmitFrameListeners() {
            this.eventEmitter.removeAllListeners("submitFrame");
            return this;
          }
        },
        {
          key: "onProcessFrame",
          value: function onProcessFrame(listener) {
            var once = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
            if (true === once) this.eventEmitter.once("processFrame", listener, this);
            else this.eventEmitter.on("processFrame", listener, this);
            return this;
          }
        },
        {
          key: "removeProcessFrameListener",
          value: function removeProcessFrameListener(listener) {
            this.eventEmitter.removeListener("processFrame", listener);
            return this;
          }
        },
        {
          key: "removeProcessFrameListeners",
          value: function removeProcessFrameListeners() {
            this.eventEmitter.removeAllListeners("processFrame");
            return this;
          }
        },
        {
          key: "setGuiStyle",
          value: function setGuiStyle(guiStyle) {
            this.barcodePickerGui.setGuiStyle(guiStyle);
            return this;
          }
        },
        {
          key: "setVideoFit",
          value: function setVideoFit(objectFit) {
            this.barcodePickerGui.setVideoFit(objectFit);
            return this;
          }
        },
        {
          key: "accessCamera",
          value: function accessCamera() {
            var _this5 = this;
            if (!this.cameraAccess || null == this.cameraManager.activeCamera)
              return new promise$1(function(resolve, reject) {
                _this5.cameraManager
                  .setupCameras()
                  .then(function() {
                    _this5.cameraAccess = true;
                    return resolve(_this5);
                  })
                  .catch(reject);
              });
            return promise$1.resolve(this);
          }
        },
        {
          key: "createParserForFormat",
          value: function createParserForFormat(dataFormat) {
            return this.scanner.createParserForFormat(dataFormat);
          }
        },
        {
          key: "reassignOriginElement",
          value: function reassignOriginElement(originElement) {
            this.barcodePickerGui.reassignOriginElement(originElement);
            return this;
          }
        },
        {
          key: "setTargetScanningFPS",
          value: function setTargetScanningFPS(targetScanningFPS) {
            if (targetScanningFPS > 0) this.targetScanningFPS = targetScanningFPS;
            return this;
          }
        },
        {
          key: "getScanner",
          value: function getScanner() {
            return this.scanner;
          }
        },
        {
          key: "clearSession",
          value: function clearSession() {
            this.scanner.clearSession();
            return this;
          }
        },
        {
          key: "triggerFatalError",
          value: function triggerFatalError(error) {
            this.fatalError = error;
            console.error(error);
          }
        },
        {
          key: "handleScanResult",
          value: function handleScanResult(scanResult) {
            this.eventEmitter.emit("processFrame", scanResult);
            if (0 !== scanResult.barcodes.length) {
              this.barcodePickerGui.flashGUI();
              if (this.playSoundOnScan) this.beepSound.play();
              if (this.vibrateOnScan && null != this.vibrateFunction) this.vibrateFunction.call(navigator, 300);
              this.eventEmitter.emit("scan", scanResult);
            }
          }
        },
        {
          key: "scheduleVideoProcessing",
          value: function scheduleVideoProcessing() {
            var _this6 = this;
            var timeout = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            window.setTimeout(function() {
              _this6.videoProcessing();
            }, timeout);
          }
        },
        {
          key: "scheduleNextVideoProcessing",
          value: function scheduleNextVideoProcessing(processingStartTime) {
            if (this.targetScanningFPS < 30) {
              if (null == this.averageProcessingTime)
                this.averageProcessingTime = performance.now() - processingStartTime;
              else
                this.averageProcessingTime =
                  0.9 * this.averageProcessingTime + 0.1 * (performance.now() - processingStartTime);
              var nextProcessingCallDelay = 1e3 / this.targetScanningFPS - this.averageProcessingTime;
              if (nextProcessingCallDelay > 16) this.scheduleVideoProcessing(nextProcessingCallDelay);
              else this.scheduleVideoProcessing();
            } else this.scheduleVideoProcessing();
          }
        },
        {
          key: "processVideoFrame",
          value: function processVideoFrame(highQualitySingleFrameMode) {
            var _this7 = this;
            var imageData = this.barcodePickerGui.getVideoImageData();
            if (null == imageData) return promise$1.resolve();
            if (this.eventEmitter.listenerCount("submitFrame") > 0 && !this.scanningPaused)
              this.eventEmitter.emit("submitFrame", {
                barcodes: [],
                imageData: imageData.slice(),
                imageSettings: this.scanner.getImageSettings()
              });
            return new promise$1(function(resolve) {
              _this7.scanner
                .processImage(imageData, highQualitySingleFrameMode)
                .then(function(scanResult) {
                  if (!_this7.scanningPaused) _this7.handleScanResult(scanResult);
                  resolve();
                })
                .catch(function(scanError) {
                  if (!_this7.scanningPaused) {
                    _this7.pauseScanning();
                    _this7.eventEmitter.emit("scanError", scanError);
                  }
                  resolve();
                });
            });
          }
        },
        {
          key: "videoProcessing",
          value: function videoProcessing() {
            var _this8 = this;
            if (this.destroyed) return;
            if (
              null == this.cameraManager.activeCamera ||
              null == this.cameraManager.activeCamera.currentResolution ||
              null != this.fatalError ||
              this.scanningPaused ||
              !this.scanner.isReady() ||
              this.scanner.isBusyProcessing() ||
              this.latestVideoTimeProcessed === this.barcodePickerGui.getVideoCurrentTime()
            ) {
              this.scheduleVideoProcessing();
              return;
            }
            if (null == this.latestVideoTimeProcessed) this.resumeScanning();
            var processingStartTime = performance.now();
            this.latestVideoTimeProcessed = this.barcodePickerGui.getVideoCurrentTime();
            try {
              this.processVideoFrame(false).then(function() {
                _this8.scheduleNextVideoProcessing(processingStartTime);
              });
            } catch (error) {
              this.triggerFatalError(error);
            }
          }
        }
      ],
      [
        {
          key: "create",
          value: function create(originElement) {
            var _ref2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
              _ref2$visible = _ref2.visible,
              visible = void 0 === _ref2$visible ? true : _ref2$visible,
              _ref2$singleImageMode = _ref2.singleImageMode,
              singleImageMode =
                void 0 === _ref2$singleImageMode
                  ? { desktop: { always: false, allowFallback: true }, mobile: { always: false, allowFallback: true } }
                  : _ref2$singleImageMode,
              _ref2$playSoundOnScan = _ref2.playSoundOnScan,
              playSoundOnScan = void 0 === _ref2$playSoundOnScan ? false : _ref2$playSoundOnScan,
              _ref2$vibrateOnScan = _ref2.vibrateOnScan,
              vibrateOnScan = void 0 === _ref2$vibrateOnScan ? false : _ref2$vibrateOnScan,
              _ref2$scanningPaused = _ref2.scanningPaused,
              scanningPaused = void 0 === _ref2$scanningPaused ? false : _ref2$scanningPaused,
              _ref2$guiStyle = _ref2.guiStyle,
              guiStyle = void 0 === _ref2$guiStyle ? BarcodePicker.GuiStyle.LASER : _ref2$guiStyle,
              _ref2$videoFit = _ref2.videoFit,
              videoFit = void 0 === _ref2$videoFit ? BarcodePicker.ObjectFit.CONTAIN : _ref2$videoFit,
              scanner = _ref2.scanner,
              _ref2$scanSettings = _ref2.scanSettings,
              scanSettings = void 0 === _ref2$scanSettings ? new ScanSettings() : _ref2$scanSettings,
              _ref2$enableCameraSwi = _ref2.enableCameraSwitcher,
              enableCameraSwitcher = void 0 === _ref2$enableCameraSwi ? true : _ref2$enableCameraSwi,
              _ref2$enableTorchTogg = _ref2.enableTorchToggle,
              enableTorchToggle = void 0 === _ref2$enableTorchTogg ? true : _ref2$enableTorchTogg,
              _ref2$enableTapToFocu = _ref2.enableTapToFocus,
              enableTapToFocus = void 0 === _ref2$enableTapToFocu ? true : _ref2$enableTapToFocu,
              _ref2$enablePinchToZo = _ref2.enablePinchToZoom,
              enablePinchToZoom = void 0 === _ref2$enablePinchToZo ? true : _ref2$enablePinchToZo,
              _ref2$accessCamera = _ref2.accessCamera,
              accessCamera = void 0 === _ref2$accessCamera ? true : _ref2$accessCamera,
              camera = _ref2.camera,
              cameraSettings = _ref2.cameraSettings,
              _ref2$targetScanningF = _ref2.targetScanningFPS,
              targetScanningFPS = void 0 === _ref2$targetScanningF ? 30 : _ref2$targetScanningF;
            var singleImageModeForced;
            var singleImageModeFallbackAllowed;
            var deviceType = exports.BrowserHelper.userAgentInfo.getDevice().type;
            if ("mobile" === deviceType || "tablet" === deviceType) {
              singleImageModeForced = singleImageMode.mobile.always;
              singleImageModeFallbackAllowed = singleImageMode.mobile.allowFallback;
            } else {
              singleImageModeForced = singleImageMode.desktop.always;
              singleImageModeFallbackAllowed = singleImageMode.desktop.allowFallback;
            }
            var browserCompatibility = exports.BrowserHelper.checkBrowserCompatibility();
            if (
              !browserCompatibility.scannerSupport ||
              (!singleImageModeForced && !singleImageModeFallbackAllowed && !browserCompatibility.fullSupport)
            )
              return promise$1.reject(
                new CustomError({
                  name: "UnsupportedBrowserError",
                  message: "This OS / Browser has one or more missing features preventing it from working correctly",
                  data: browserCompatibility
                })
              );
            if (null == exports.userLicenseKey || "" === exports.userLicenseKey.trim())
              return promise$1.reject(
                new CustomError({
                  name: "LibraryNotConfiguredError",
                  message:
                    "The library has not correctly been configured yet, please call 'configure' with valid parameters"
                })
              );
            if (!(originElement instanceof HTMLElement))
              return promise$1.reject(
                new CustomError({ name: "NoOriginElementError", message: "A valid origin HTML element must be given" })
              );
            if (targetScanningFPS <= 0) targetScanningFPS = 30;
            var barcodePicker = new BarcodePicker(originElement, {
              visible: visible,
              singleImageMode: browserCompatibility.fullSupport ? singleImageModeForced : true,
              playSoundOnScan: playSoundOnScan,
              vibrateOnScan: vibrateOnScan,
              scanningPaused: scanningPaused,
              guiStyle: guiStyle,
              videoFit: videoFit,
              scanner: scanner,
              scanSettings: scanSettings,
              targetScanningFPS: targetScanningFPS
            });
            barcodePicker.cameraManager.setInteractionOptions(
              enableCameraSwitcher,
              enableTorchToggle,
              enableTapToFocus,
              enablePinchToZoom
            );
            barcodePicker.cameraManager.setSelectedCamera(camera);
            barcodePicker.cameraManager.setSelectedCameraSettings(cameraSettings);
            barcodePicker.cameraAccess = accessCamera;
            barcodePicker.onScanError(function(error) {
              if (-1 !== ["localhost", "127.0.0.1", ""].indexOf(window.location.hostname)) alert(error);
            });
            if (accessCamera)
              return barcodePicker.cameraManager.setupCameras().then(function() {
                return barcodePicker;
              });
            return promise$1.resolve(barcodePicker);
          }
        }
      ]
    );
    return BarcodePicker;
  })();
  (function(BarcodePicker) {
    (function(GuiStyle) {
      GuiStyle["NONE"] = "none";
      GuiStyle["LASER"] = "laser";
      GuiStyle["VIEWFINDER"] = "viewfinder";
    })(BarcodePicker.GuiStyle || (BarcodePicker.GuiStyle = {}));
    (function(ObjectFit) {
      ObjectFit["CONTAIN"] = "contain";
      ObjectFit["COVER"] = "cover";
    })(BarcodePicker.ObjectFit || (BarcodePicker.ObjectFit = {}));
  })(exports.BarcodePicker || (exports.BarcodePicker = {}));
  var deviceId = exports.BrowserHelper.getDeviceId();
  function configure(licenseKey) {
    var _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      _ref$engineLocation = _ref.engineLocation,
      engineLocation = void 0 === _ref$engineLocation ? "/" : _ref$engineLocation;
    var browserCompatibility = exports.BrowserHelper.checkBrowserCompatibility();
    if (!browserCompatibility.fullSupport && !browserCompatibility.scannerSupport)
      return promise$1.reject(
        new CustomError({
          name: "UnsupportedBrowserError",
          message: "This OS / Browser has one or more missing features preventing it from working correctly",
          data: browserCompatibility
        })
      );
    if (null == licenseKey || "" === licenseKey.trim())
      return promise$1.reject(new CustomError({ name: "NoLicenseKeyError", message: "No license key provided" }));
    exports.userLicenseKey = licenseKey;
    engineLocation += "/" === engineLocation.slice(-1) ? "" : "/";
    if (/^https?:\/\//.test(engineLocation)) exports.scanditEngineLocation = "".concat(engineLocation);
    else {
      engineLocation = engineLocation
        .split("/")
        .filter(function(s) {
          return s.length > 0;
        })
        .join("/");
      if ("" === engineLocation) engineLocation = "/";
      else engineLocation = "/".concat(engineLocation, "/");
      exports.scanditEngineLocation = "".concat(location.origin).concat(engineLocation);
    }
    return promise$1.resolve();
  }
  exports.deviceId = deviceId;
  exports.configure = configure;
  exports.UAParser = uaParser_1;
  exports.CustomError = CustomError;
  exports.Scanner = Scanner$$1;
  exports.ScanSettings = ScanSettings;
  exports.engine = engine;
  exports.engineWorkerFunction = engineWorkerFunction;
  exports.engineWorkerBlob = engineWorkerBlob;
  Object.defineProperty(exports, "__esModule", { value: true });
});

});

var ScanditSDKWeb = unwrapExports(browser);

const SCANDIT_KEY_WEB = 'AdUcQCAfPcDNJN3lljyPTyI/AtdVI/XfV0/rZPVr16vYJeJEsTqhfIA1hoNuYc5SeCbtu8hIKrZdEVaTOlvP+ulg9oqFFCezMV9AB8ooO/azf3IFtVe2yvp1CxqjTmLzfxNmBWkrSb97AUuGxa4YrSy3tRZyS/fAJvUVMwdSCcanVu8tgH+24Br6USnlHBTenQfNVFC/nHiQ+9qFz3uAyC/VcPU9GbIBaTOizpTdrCUyUvjt/XM/unEjFIL/GDE5zizsiIj7zwvcDpKvIG/FSjuNJpBmxTkTBqGTMh8/yyEusuUcRjwC4bZyWFhJ0Sr2++ZSQeCYPnZ7PXrlaxlfHYsD8+FmyADDIOePjJy5qx7Voax5kYfm9U9dgHsrzoBmWdVEc6BTFXr9yELjPEqo5yi2KX7DiI2xvaQk7uAA9lF9x9O54iDPVM7pt7tAGFJG1fQbxPHozeaYsJvID5G1ehLTkl7Rbn81R3eTD0hHm7djq9oEbrfDfNT/ByPd3W6dsK8KwVFNV2LVdc62MnIj1yosA+m2zlLpAyak5lRA50RugVJoWlYk3bL/jkNaGzpxlkMeWnRcJ3Bxjj27nry8IlPAjECUBg+pErrqldFbA64v7J1CFrJRTPGdDjavBWzDI3Jo0/nkrC4MAsI0djCmUAUmG24H8O+FZx0+JRkm8U3zDD0FUYPCrQOZ4KAZDQZlOfs7lPDGdkn5IAbt62un641Vl0PbKCaqNmT6mXR4mNnaRXpxGk+Pk3kAokup/jqEAtz6xT4NQkzWSuHz1vKN4QRg5g9BezKdZwn6Iyihj4OxjOcN2NrIxUz4Mw==';
const SCANDIT_KEY_MOBILE = 'Ace8ayQfOR2wL4B3nAG1l9IgknlWGPYBPlUyU/xWjgr+K/ThFm9mjDAfBlymFna3K3IpbdYAXpz4ZaPrGnUnnR8UFbLkXHOdsB7FkZct266nE7X7Ijl7G5I5AnKMByxOijMVqiEGFCq3N/eO0q+urPsxwE4VRrhKZQ5uES/YQU1TCYaT//q7je74OUZemIHUmRaTYGJEwJfNdoWw0HohI6uvk1EsI/QO/d8Szk5kEw0keaGDuCmr3DKfWM4WEaHbUadImcuNnmQabmpujoWOyjwHh5qLOMlWnqlgbEiygLGYGljYOybPZDr/Leu6HwSr/Egxa61quxex7M9kDmOqbI2EHFBCpzG43as0FhrRVfwu/+GJYw+cKimwMdprjFpGb7hl9C2a73UhmEEep+FMNB3bk7rl+zfGB2MCoPeeMG3LA2yFObj5wCxf9nv0mEn5ialsZVlbYOxZSL4aV6S59nkvAcV5jkGk1jlV9IdvolqSX+3QLdbESfTdP6Zes1k1usRLfiUW7zalUN9RvzWhRP3za/A196NfNEaClUwMuBL8CNvsaNM7oMlP6B9HKaNTyRB5g0SoKmH//bZpY5EaTDN8IicvWpsd5s4d8hKqNxN27wLVZitbSvu+qRDclxLuRY9zg/4vd4pDJE+AgfuvOR779GgJj3py6SOwx5MR2KyPNzY4wDbQCDv5exEwMYI1N0P7Gjxr00nQ/bzrYJg0ntEXf09mwQL1l1oBKhX8efgnZfReatjFrxHGzmJvMPMgmD2PO6szZT/yDFaof3XJgTpz6NYs0dPn0N+Rb+7JNA==';
const ENABLED_SYMBOLOGIES = [
    ScanditSDKWeb.Barcode.Symbology.EAN8,
    ScanditSDKWeb.Barcode.Symbology.EAN13,
    ScanditSDKWeb.Barcode.Symbology.UPCA,
    ScanditSDKWeb.Barcode.Symbology.UPCE,
    ScanditSDKWeb.Barcode.Symbology.CODE128,
    ScanditSDKWeb.Barcode.Symbology.CODE39,
    ScanditSDKWeb.Barcode.Symbology.CODE93,
    ScanditSDKWeb.Barcode.Symbology.INTERLEAVED_2_OF_5
];
class YooScanditComponent {
    constructor() {
        this.scanMode = 'default';
        this.isScanditSupported = true;
    }
    pauseScanning() {
        if (this.barcodePickerWeb) {
            this.barcodePickerWeb.pauseScanning();
        }
        if (this.barcodePickerCordovaRef) {
            this.barcodePickerCordovaRef.pauseScanning();
        }
    }
    cleanUpScandit() {
        if (this.barcodePickerWeb) {
            this.barcodePickerWeb.destroy();
            this.barcodePickerWeb = null;
        }
        if (this.barcodePickerCordovaRef) {
            this.barcodePickerCordovaRef.cancel();
            this.barcodePickerCordovaRef = null;
        }
    }
    restartOcrScanner() {
        if (isCordova()) {
            this.cleanUpScandit();
            setTimeout(() => {
                this.onInitOcrScannerCordova();
            }, 300);
        }
    }
    componentWillLoad() {
        if (!isCordova()) {
            return ScanditSDKWeb.configure(SCANDIT_KEY_WEB, {
                engineLocation: 'assets/scandit'
            }).then(() => { }, (err) => {
                if (err && err.name && err.name === 'UnsupportedBrowserError') {
                    this.isScanditSupported = false;
                }
            });
        }
        else if (window['Scandit']) {
            Scandit.License.setAppKey(SCANDIT_KEY_MOBILE);
        }
    }
    componentDidLoad() {
        if (isCordova()) {
            setTimeout(() => {
                this.onInitBarCodePickerForCordova();
            }, 300);
        }
        else {
            if (this.isScanditSupported) {
                this.onInitBarCodePickerForWeb();
            }
            else {
                setTimeout(() => {
                    showAlert('', [translate('OK')], '', translate('SCANDITNOTSUPPORTED'));
                }, 1000);
            }
        }
    }
    componentDidUnload() {
        this.cleanUpScandit();
    }
    isScanMode(compareMode) {
        return this.scanMode === compareMode;
    }
    onHasResult(result) {
        if (this.isScanMode('default') || this.isScanMode('batch')) {
            this.onSingleScanSuccess(result);
        }
        else if (this.isScanMode('ocr')) {
            this.onOcrScanSuccess(result);
        }
    }
    onHasError(error) {
    }
    onOcrScanSuccess(result) {
        if (this.barcodePickerCordovaRef) {
            this.barcodePickerCordovaRef.stopScanning();
        }
        if (result && result.text) {
            this.scannedSuccess.emit(result.text);
        }
    }
    onSingleScanSuccess(result) {
        let reference;
        if (result && result.allRecognizedCodes && result.allRecognizedCodes[0] && result.allRecognizedCodes[0].data) {
            reference = result.allRecognizedCodes[0].data;
        }
        else if (result && result.barcodes && result.barcodes[0] && result.barcodes[0].data) {
            reference = result.barcodes[0].data;
        }
        else if (result && result.newlyRecognizedCodes[0] && result.newlyRecognizedCodes[0].data) {
            reference = result.newlyRecognizedCodes[0].data;
        }
        if (result && result.pauseScanning) {
            result.pauseScanning();
        }
        else {
            this.pauseScanning();
        }
        this.scannedSuccess.emit(reference);
    }
    onInitBarCodePickerForWeb() {
        if (this.barcodePickerWebEl) {
            ScanditSDKWeb.BarcodePicker.create(this.barcodePickerWebEl, {
                playSoundOnScan: true,
                vibrateOnScan: true
            }).then((barcodePicker) => {
                this.barcodePickerWeb = barcodePicker;
                const scanSettings = new ScanditSDKWeb.ScanSettings({
                    enabledSymbologies: ENABLED_SYMBOLOGIES,
                    codeDuplicateFilter: 1000
                });
                this.isScannerInit = true;
                this.barcodePickerWeb.applyScanSettings(scanSettings);
                this.barcodePickerWeb.onScan((scanResult) => {
                    this.onHasResult(scanResult);
                });
            });
        }
    }
    onInitBarCodePickerForCordova() {
        this.initScannerBasedOnModeCordova();
    }
    onInitSingleScannerCordova() {
        let settings = new Scandit.ScanSettings();
        ENABLED_SYMBOLOGIES.forEach(symbol => {
            settings.setSymbologyEnabled(symbol, true);
        });
        this.barcodePickerCordovaRef = new Scandit.BarcodePicker(settings);
        this.barcodePickerCordovaRef.continuousMode = this.isScanMode('batch');
        this.barcodePickerCordovaRef.setMargins(new Scandit.Margins(0, 150, 0, 0), new Scandit.Margins(0, 150, 0, 0), 0);
        this.barcodePickerCordovaRef.getOverlayView().setGuiStyle(Scandit.ScanOverlay.GuiStyle.MATRIXSCAN);
        this.barcodePickerCordovaRef.getOverlayView().setTextRecognitionSwitchVisible(false);
        this.barcodePickerCordovaRef.show((result) => {
            this.onHasResult(result);
        }, null, (error) => {
            this.onHasError(error);
        });
        this.barcodePickerCordovaRef.startScanning();
    }
    onInitOcrScannerCordova() {
        let settings = new Scandit.ScanSettings();
        settings.recognitionMode = Scandit.ScanSettings.RecognitionMode.TEXT;
        settings.textRecognition = new Scandit.TextRecognitionSettings();
        settings.textRecognition.regex = this.currentOcrRegex.regex;
        this.barcodePickerCordovaRef = new Scandit.BarcodePicker(settings);
        this.barcodePickerCordovaRef.continuousMode = false;
        this.barcodePickerCordovaRef.setMargins(new Scandit.Margins(0, 230, 0, 0), new Scandit.Margins(0, 230, 0, 0), 0);
        this.barcodePickerCordovaRef.getOverlayView().setTextRecognitionSwitchVisible(false);
        this.barcodePickerCordovaRef.show({
            didRecognizeText: (ev) => { this.onHasResult(ev); }
        });
        this.barcodePickerCordovaRef.startScanning();
    }
    initScannerBasedOnModeCordova() {
        if (this.isScanMode('default') || this.isScanMode('batch')) {
            this.onInitSingleScannerCordova();
        }
        if (this.isScanMode('ocr')) {
            this.onInitOcrScannerCordova();
        }
    }
    renderSideElement() {
        return [
            h("div", { class: "rect" }),
            h("div", { class: "rect-large" })
        ];
    }
    renderScannerCamera() {
        return [
            h("div", { class: "barcode-picker", ref: el => this.barcodePickerWebEl = el })
        ];
    }
    renderWebOverlay() {
        return [
            h("div", { class: {
                    "scanner-overlay": true,
                    'active': this.isScannerInit
                } },
                h("div", { class: "left-part" }, this.renderSideElement()),
                h("div", { class: "right-part" }, this.renderSideElement()),
                h("div", { class: "bottom-part" }, translate(this.isScanMode('ocr') ? 'SCANADATE' : 'SCANABARCODE')))
        ];
    }
    renderScannerContent() {
        return [
            h("div", { class: {
                    'scanner-container': true
                } },
                this.renderScannerCamera(),
                this.renderWebOverlay())
        ];
    }
    hostData() {
        return {
            class: Object.assign({}, getAppContext())
        };
    }
    render() {
        return [
            !isCordova() && this.renderScannerContent()
        ];
    }
    static get is() { return "yoo-scandit"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "cleanUpScandit": {
            "method": true
        },
        "currentOcrRegex": {
            "type": "Any",
            "attr": "current-ocr-regex",
            "watchCallbacks": ["restartOcrScanner"]
        },
        "host": {
            "elementRef": true
        },
        "isScanditSupported": {
            "state": true
        },
        "isScannerInit": {
            "state": true
        },
        "pauseScanning": {
            "method": true
        },
        "restartOcrScanner": {
            "method": true
        },
        "scanMode": {
            "type": String,
            "attr": "scan-mode"
        }
    }; }
    static get events() { return [{
            "name": "scannedSuccess",
            "method": "scannedSuccess",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return ":host {\n  width: 100%;\n  height: 100%; }\n  :host .scanner-container {\n    position: absolute;\n    width: 100%;\n    height: 100%; }\n    :host .scanner-container .barcode-picker {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n      background: var(--black, #000000); }\n      :host .scanner-container .barcode-picker .scandit.scandit-container {\n        width: 100%;\n        height: 100%;\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-pack: center;\n        justify-content: center;\n        -ms-flex-align: center;\n        align-items: center;\n        overflow: hidden; }\n      :host .scanner-container .barcode-picker .scandit.scandit-barcode-picker {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        background-color: #000; }\n      :host .scanner-container .barcode-picker .scandit .scandit-video {\n        width: 100%;\n        height: 100%;\n        position: relative;\n        display: block; }\n        :host .scanner-container .barcode-picker .scandit .scandit-video.mirrored {\n          -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1); }\n      :host .scanner-container .barcode-picker .scandit .scandit-logo {\n        position: absolute;\n        bottom: 5%;\n        right: 5%;\n        max-width: 35%;\n        max-height: 12.5%;\n        pointer-events: none;\n        -webkit-transform: translateZ(0);\n        transform: translateZ(0); }\n      :host .scanner-container .barcode-picker .scandit .scandit-laser {\n        z-index: 10;\n        position: absolute;\n        margin: auto;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        max-width: 75%;\n        max-height: 10%;\n        -webkit-animation-duration: 0.25s;\n        animation-duration: 0.25s;\n        -webkit-transition: opacity 0.25s ease;\n        transition: opacity 0.25s ease;\n        pointer-events: none;\n        -webkit-transform: translateZ(0);\n        transform: translateZ(0); }\n      :host .scanner-container .barcode-picker .scandit .scandit-viewfinder {\n        z-index: 10;\n        position: absolute;\n        -webkit-box-sizing: border-box;\n        box-sizing: border-box;\n        width: 90%;\n        height: 60%;\n        border: 2px #fff solid;\n        border-radius: 10px;\n        margin: auto;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        -webkit-animation-duration: 0.25s;\n        animation-duration: 0.25s;\n        -webkit-transition: opacity 0.25s ease;\n        transition: opacity 0.25s ease;\n        pointer-events: none;\n        -webkit-transform: translateZ(0);\n        transform: translateZ(0); }\n        :host .scanner-container .barcode-picker .scandit .scandit-viewfinder.paused {\n          opacity: 0.4; }\n      :host .scanner-container .barcode-picker .scandit .scandit-camera-switcher,\n      :host .scanner-container .barcode-picker .scandit .scandit-torch-toggle {\n        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\n        position: absolute;\n        top: 5%;\n        max-width: 15%;\n        max-height: 15%;\n        z-index: 10;\n        cursor: pointer;\n        -webkit-filter: drop-shadow(0 2px 0 #808080);\n        filter: drop-shadow(0 2px 0 #808080);\n        -webkit-transform: translateZ(0);\n        transform: translateZ(0); }\n      :host .scanner-container .barcode-picker .scandit .scandit-camera-switcher {\n        left: 5%; }\n      :host .scanner-container .barcode-picker .scandit .scandit-torch-toggle {\n        right: 5%; }\n      :host .scanner-container .barcode-picker .scandit .scandit-camera-upload {\n        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-direction: column;\n        flex-direction: column;\n        -ms-flex-pack: center;\n        justify-content: center;\n        -ms-flex-align: center;\n        align-items: center;\n        width: 100%;\n        height: 100%;\n        z-index: 5; }\n        :host .scanner-container .barcode-picker .scandit .scandit-camera-upload label {\n          cursor: pointer;\n          text-align: center;\n          width: 224px;\n          height: 224px;\n          min-width: 224px;\n          min-height: 224px;\n          z-index: 10;\n          margin: 4px;\n          padding: 20px;\n          -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n          border-radius: 50%;\n          -webkit-filter: drop-shadow(0 0 0.15rem #000);\n          filter: drop-shadow(0 0 0.15rem #000); }\n          :host .scanner-container .barcode-picker .scandit .scandit-camera-upload label input[type=\"file\"] {\n            position: absolute;\n            top: -9999px; }\n          :host .scanner-container .barcode-picker .scandit .scandit-camera-upload label img {\n            width: 60%;\n            height: 60%; }\n          :host .scanner-container .barcode-picker .scandit .scandit-camera-upload label div {\n            font-family: sans-serif;\n            color: #fff;\n            font-size: 16pt; }\n      :host .scanner-container .barcode-picker .scandit .radial-progress {\n        width: 224px;\n        height: 224px;\n        background-color: rgba(0, 0, 0, 0);\n        border-width: 4px;\n        border-color: white;\n        border-style: solid;\n        border-radius: 50%;\n        position: absolute;\n        -webkit-transition: opacity 1s ease, border-color 0.5s;\n        transition: opacity 1s ease, border-color 0.5s;\n        -webkit-animation-duration: 0.25s;\n        animation-duration: 0.25s;\n        z-index: 7;\n        -webkit-box-shadow: 0 0 0.3rem #000, 0 0 0.3rem #000 inset;\n        box-shadow: 0 0 0.3rem #000, 0 0 0.3rem #000 inset; }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"0\"] {\n          border-color: rgba(255, 255, 255, 0.2); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"5\"] {\n          border-color: rgba(255, 255, 255, 0.24); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"10\"] {\n          border-color: rgba(255, 255, 255, 0.28); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"15\"] {\n          border-color: rgba(255, 255, 255, 0.32); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"20\"] {\n          border-color: rgba(255, 255, 255, 0.36); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"25\"] {\n          border-color: rgba(255, 255, 255, 0.4); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"30\"] {\n          border-color: rgba(255, 255, 255, 0.44); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"35\"] {\n          border-color: rgba(255, 255, 255, 0.48); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"40\"] {\n          border-color: rgba(255, 255, 255, 0.52); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"45\"] {\n          border-color: rgba(255, 255, 255, 0.56); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"50\"] {\n          border-color: rgba(255, 255, 255, 0.6); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"55\"] {\n          border-color: rgba(255, 255, 255, 0.64); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"60\"] {\n          border-color: rgba(255, 255, 255, 0.68); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"65\"] {\n          border-color: rgba(255, 255, 255, 0.72); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"70\"] {\n          border-color: rgba(255, 255, 255, 0.76); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"75\"] {\n          border-color: rgba(255, 255, 255, 0.8); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"80\"] {\n          border-color: rgba(255, 255, 255, 0.84); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"85\"] {\n          border-color: rgba(255, 255, 255, 0.88); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"90\"] {\n          border-color: rgba(255, 255, 255, 0.92); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"95\"] {\n          border-color: rgba(255, 255, 255, 0.96); }\n        :host .scanner-container .barcode-picker .scandit .radial-progress[data-progress=\"100\"] {\n          border-color: white; }\n      :host .scanner-container .barcode-picker .scandit .scandit-flash-color {\n        -webkit-animation-name: scandit-flash-color;\n        animation-name: scandit-flash-color; }\n      :host .scanner-container .barcode-picker .scandit .scandit-flash-white {\n        -webkit-animation-name: scandit-flash-white;\n        animation-name: scandit-flash-white; }\n      :host .scanner-container .barcode-picker .scandit .scandit-flash-white-inset {\n        -webkit-animation-name: scandit-flash-white-inset;\n        animation-name: scandit-flash-white-inset; }\n      :host .scanner-container .barcode-picker .scandit .scandit-opacity-pulse {\n        -webkit-animation-duration: 0.333s, 1s;\n        animation-duration: 0.333s, 1s;\n        -webkit-animation-iteration-count: 1, infinite;\n        animation-iteration-count: 1, infinite;\n        -webkit-animation-delay: 0s, 0.333s;\n        animation-delay: 0s, 0.333s;\n        -webkit-animation-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1), cubic-bezier(0.645, 0.045, 0.355, 1);\n        animation-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1), cubic-bezier(0.645, 0.045, 0.355, 1);\n        -webkit-animation-name: scandit-opacity-pulse-before, scandit-opacity-pulse;\n        animation-name: scandit-opacity-pulse-before, scandit-opacity-pulse; }\n      :host .scanner-container .barcode-picker .scandit .scandit-hidden-opacity {\n        opacity: 0; }\n      :host .scanner-container .barcode-picker .scandit-hidden {\n        display: none !important;\n        /* stylelint-disable-line declaration-no-important */ }\n\n\@-webkit-keyframes scandit-flash-color {\n  0% {\n    -webkit-filter: none;\n    filter: none; }\n  50% {\n    -webkit-filter: drop-shadow(0 0 0.75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2);\n    filter: drop-shadow(0 0 0.75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2); }\n  100% {\n    -webkit-filter: none;\n    filter: none; } }\n\n\@keyframes scandit-flash-color {\n  0% {\n    -webkit-filter: none;\n    filter: none; }\n  50% {\n    -webkit-filter: drop-shadow(0 0 0.75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2);\n    filter: drop-shadow(0 0 0.75rem #fff) drop-shadow(0 0 2.5rem #7ed9e2); }\n  100% {\n    -webkit-filter: none;\n    filter: none; } }\n\n\@-webkit-keyframes scandit-flash-white {\n  0% {\n    -webkit-filter: none;\n    filter: none; }\n  50% {\n    -webkit-filter: drop-shadow(0 0 0.5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff);\n    filter: drop-shadow(0 0 0.5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff); }\n  100% {\n    -webkit-filter: none;\n    filter: none; } }\n\n\@keyframes scandit-flash-white {\n  0% {\n    -webkit-filter: none;\n    filter: none; }\n  50% {\n    -webkit-filter: drop-shadow(0 0 0.5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff);\n    filter: drop-shadow(0 0 0.5rem #fff) drop-shadow(0 0 1rem #fff) drop-shadow(0 0 2.5rem #fff); }\n  100% {\n    -webkit-filter: none;\n    filter: none; } }\n\n\@-webkit-keyframes scandit-flash-white-inset {\n  0% {\n    -webkit-box-shadow: none;\n    box-shadow: none; }\n  50% {\n    -webkit-box-shadow: 0 0 0.5rem #fff inset, 0 0 1rem #fff inset, 0 0 2.5rem #fff inset;\n    box-shadow: 0 0 0.5rem #fff inset, 0 0 1rem #fff inset, 0 0 2.5rem #fff inset; }\n  100% {\n    -webkit-box-shadow: none;\n    box-shadow: none; } }\n\n\@keyframes scandit-flash-white-inset {\n  0% {\n    -webkit-box-shadow: none;\n    box-shadow: none; }\n  50% {\n    -webkit-box-shadow: 0 0 0.5rem #fff inset, 0 0 1rem #fff inset, 0 0 2.5rem #fff inset;\n    box-shadow: 0 0 0.5rem #fff inset, 0 0 1rem #fff inset, 0 0 2.5rem #fff inset; }\n  100% {\n    -webkit-box-shadow: none;\n    box-shadow: none; } }\n\n\@-webkit-keyframes scandit-opacity-pulse-before {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0.4; } }\n\n\@keyframes scandit-opacity-pulse-before {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0.4; } }\n\n\@-webkit-keyframes scandit-opacity-pulse {\n  0% {\n    opacity: 0.4; }\n  50% {\n    opacity: 0.6; }\n  100% {\n    opacity: 0.4; } }\n\n\@keyframes scandit-opacity-pulse {\n  0% {\n    opacity: 0.4; }\n  50% {\n    opacity: 0.6; }\n  100% {\n    opacity: 0.4; } }\n\n\@-webkit-keyframes scandit-opacity-pulse-after {\n  0% {\n    opacity: 0.5; }\n  100% {\n    opacity: 1; } }\n\n\@keyframes scandit-opacity-pulse-after {\n  0% {\n    opacity: 0.5; }\n  100% {\n    opacity: 1; } }\n      :host .scanner-container .barcode-picker .scandit-logo {\n        display: none; }\n    :host .scanner-container .scanner-overlay {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      -webkit-transition: opacity .5s ease;\n      transition: opacity .5s ease;\n      opacity: 0;\n      overflow: hidden;\n      z-index: 1; }\n      :host .scanner-container .scanner-overlay.active {\n        opacity: 1; }\n      :host .scanner-container .scanner-overlay .rect {\n        width: 5px; }\n      :host .scanner-container .scanner-overlay .rect-large {\n        width: 10px; }\n      :host .scanner-container .scanner-overlay .rect,\n      :host .scanner-container .scanner-overlay .rect-large {\n        height: 110px;\n        background: var(--light, #FFFFFF); }\n      :host .scanner-container .scanner-overlay .left-part {\n        left: 15px; }\n        :host .scanner-container .scanner-overlay .left-part .rect-large {\n          margin-left: 5px; }\n      :host .scanner-container .scanner-overlay .right-part {\n        right: 15px; }\n        :host .scanner-container .scanner-overlay .right-part .rect {\n          margin-right: 5px; }\n        :host .scanner-container .scanner-overlay .right-part .rect-large {\n          margin-right: 0; }\n      :host .scanner-container .scanner-overlay .left-part,\n      :host .scanner-container .scanner-overlay .right-part {\n        display: -ms-flexbox;\n        display: flex;\n        position: absolute;\n        position: absolute;\n        top: 50%;\n        margin-top: -50px; }\n      :host .scanner-container .scanner-overlay .bottom-part {\n        display: -ms-flexbox;\n        display: flex;\n        -ms-flex-align: center;\n        align-items: center;\n        -ms-flex-pack: center;\n        justify-content: center;\n        position: absolute;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        height: 40px;\n        margin: 0.5rem;\n        border-radius: var(--button-border-radius, 5px);\n        background-color: #ffffff;\n        text-align: center; }\n        :host .scanner-container .scanner-overlay .bottom-part .modal-icon {\n          right: 0px;\n          width: 50px;\n          height: 50px; }"; }
}

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.7
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/**!
* tippy.js v4.2.0
* (c) 2017-2019 atomiks
* MIT License
*/

var css = ".tippy-iOS{cursor:pointer!important}.tippy-notransition{transition:none}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px) rotateX(0);transform:perspective(700px) translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(60deg);transform:perspective(700px) translateY(0) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px) rotateX(0);transform:perspective(700px) translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(-60deg);transform:perspective(700px) translateY(0) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px) rotateY(0);transform:perspective(700px) translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(-60deg);transform:perspective(700px) translateX(0) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px) rotateY(0);transform:perspective(700px) translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(60deg);transform:perspective(700px) translateX(0) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:\"\";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=visible]{opacity:1}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}";

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

var version = "4.2.0";

var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser$1 ? navigator.userAgent : '';
var isIE$1 = /MSIE |Trident\//.test(ua);
var isUCBrowser = /UCBrowser\//.test(ua);
var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;

var defaultProps = {
  a11y: true,
  allowHTML: true,
  animateFill: true,
  animation: 'shift-away',
  appendTo: function appendTo() {
    return document.body;
  },
  aria: 'describedby',
  arrow: false,
  arrowType: 'sharp',
  boundary: 'scrollParent',
  content: '',
  delay: 0,
  distance: 10,
  duration: [325, 275],
  flip: true,
  flipBehavior: 'flip',
  flipOnUpdate: false,
  followCursor: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  lazy: true,
  maxWidth: 350,
  multiple: false,
  offset: 0,
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  placement: 'top',
  popperOptions: {},
  role: 'tooltip',
  showOnInit: false,
  size: 'regular',
  sticky: false,
  target: '',
  theme: 'dark',
  touch: true,
  touchHold: false,
  trigger: 'mouseenter focus',
  updateDuration: 0,
  wait: null,
  zIndex: 9999
  /**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */

};
var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];

var Selectors = {
  POPPER: '.tippy-popper',
  TOOLTIP: '.tippy-tooltip',
  CONTENT: '.tippy-content',
  BACKDROP: '.tippy-backdrop',
  ARROW: '.tippy-arrow',
  ROUND_ARROW: '.tippy-roundarrow'
};

var elementProto = isBrowser$1 ? Element.prototype : {};
var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */

function arrayFrom(value) {
  return [].slice.call(value);
}
/**
 * Ponyfill for Element.prototype.closest
 */

function closest(element, parentSelector) {
  return (elementProto.closest || function (selector) {
    // @ts-ignore
    var el = this;

    while (el) {
      if (matches.call(el, selector)) {
        return el;
      }

      el = el.parentElement;
    }
  }).call(element, parentSelector);
}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */

function closestCallback(element, callback) {
  while (element) {
    if (callback(element)) {
      return element;
    }

    element = element.parentElement;
  }
}

var PASSIVE = {
  passive: true
};
var PADDING = 4;

var keys = Object.keys(defaultProps);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */

function getDataAttributeOptions(reference) {
  return keys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */

function polyfillElementPrototypeProperties(virtualReference) {
  var polyfills = {
    isVirtual: true,
    attributes: virtualReference.attributes || {},
    setAttribute: function setAttribute(key, value) {
      virtualReference.attributes[key] = value;
    },
    getAttribute: function getAttribute(key) {
      return virtualReference.attributes[key];
    },
    removeAttribute: function removeAttribute(key) {
      delete virtualReference.attributes[key];
    },
    hasAttribute: function hasAttribute(key) {
      return key in virtualReference.attributes;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    classList: {
      classNames: {},
      add: function add(key) {
        virtualReference.classList.classNames[key] = true;
      },
      remove: function remove(key) {
        delete virtualReference.classList.classNames[key];
      },
      contains: function contains(key) {
        return key in virtualReference.classList.classNames;
      }
    }
  };

  for (var key in polyfills) {
    virtualReference[key] = polyfills[key];
  }
}

/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */

function isBareVirtualElement(value) {
  return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
/**
 * Returns an array of elements based on the value
 */

function getArrayOfElements(value) {
  if (isSingular(value)) {
    // TODO: VirtualReference is not compatible to type Element
    return [value];
  }

  if (value instanceof NodeList) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  try {
    return arrayFrom(document.querySelectorAll(value));
  } catch (e) {
    return [];
  }
}
/**
 * Returns a value at a given index depending on if it's an array or number
 */

function getValue(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? defaultValue : v;
  }

  return value;
}
/**
 * Debounce utility
 */

function debounce$1(fn, ms) {
  var timeoutId;
  return function () {
    var _this = this,
        _arguments = arguments;

    clearTimeout(timeoutId); // @ts-ignore

    timeoutId = setTimeout(function () {
      return fn.apply(_this, _arguments);
    }, ms);
  };
}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */

function getModifier(obj, key) {
  return obj && obj.modifiers && obj.modifiers[key];
}
/**
 * Determines if an array or string includes a value
 */

function includes(a, b) {
  return a.indexOf(b) > -1;
}
/**
 * Determines if the value is singular-like
 */

function isSingular(value) {
  return !!(value && hasOwnProperty(value, 'isVirtual')) || value instanceof Element;
}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */

function innerHTML() {
  return 'innerHTML';
}
/**
 * Evaluates a function if one, or returns the value
 */

function evaluateValue(value, args) {
  return typeof value === 'function' ? value.apply(null, args) : value;
}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */

function setFlipModifierEnabled(modifiers, value) {
  modifiers.filter(function (m) {
    return m.name === 'flip';
  })[0].enabled = value;
}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */

function canReceiveFocus(element) {
  return element instanceof Element ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
}
/**
 * Returns a new `div` element
 */

function div() {
  return document.createElement('div');
}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */

function evaluateProps(reference, props) {
  var out = _extends$1({}, props, {
    content: evaluateValue(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));

  if (out.arrow || isUCBrowser) {
    out.animateFill = false;
  }

  return out;
}
/**
 * Validates an object of options with the valid default props object
 */

function validateOptions(options, defaultProps) {
  Object.keys(options).forEach(function (option) {
    if (!hasOwnProperty(defaultProps, option)) {
      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
    }
  });
}

/**
 * Sets the innerHTML of an element
 */

function setInnerHTML(element, html) {
  element[innerHTML()] = html instanceof Element ? html[innerHTML()] : html;
}
/**
 * Sets the content of a tooltip
 */

function setContent(contentEl, props) {
  if (props.content instanceof Element) {
    setInnerHTML(contentEl, '');
    contentEl.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    var key = props.allowHTML ? 'innerHTML' : 'textContent';
    contentEl[key] = props.content;
  }
}
/**
 * Returns the child elements of a popper element
 */

function getChildren(popper) {
  return {
    tooltip: popper.querySelector(Selectors.TOOLTIP),
    backdrop: popper.querySelector(Selectors.BACKDROP),
    content: popper.querySelector(Selectors.CONTENT),
    arrow: popper.querySelector(Selectors.ARROW) || popper.querySelector(Selectors.ROUND_ARROW)
  };
}
/**
 * Adds `data-inertia` attribute
 */

function addInertia(tooltip) {
  tooltip.setAttribute('data-inertia', '');
}
/**
 * Removes `data-inertia` attribute
 */

function removeInertia(tooltip) {
  tooltip.removeAttribute('data-inertia');
}
/**
 * Creates an arrow element and returns it
 */

function createArrowElement(arrowType) {
  var arrow = div();

  if (arrowType === 'round') {
    arrow.className = 'tippy-roundarrow';
    setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
  } else {
    arrow.className = 'tippy-arrow';
  }

  return arrow;
}
/**
 * Creates a backdrop element and returns it
 */

function createBackdropElement() {
  var backdrop = div();
  backdrop.className = 'tippy-backdrop';
  backdrop.setAttribute('data-state', 'hidden');
  return backdrop;
}
/**
 * Adds interactive-related attributes
 */

function addInteractive(popper, tooltip) {
  popper.setAttribute('tabindex', '-1');
  tooltip.setAttribute('data-interactive', '');
}
/**
 * Removes interactive-related attributes
 */

function removeInteractive(popper, tooltip) {
  popper.removeAttribute('tabindex');
  tooltip.removeAttribute('data-interactive');
}
/**
 * Applies a transition duration to a list of elements
 */

function applyTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = "".concat(value, "ms");
    }
  });
}
/**
 * Add/remove transitionend listener from tooltip
 */

function toggleTransitionEndListener(tooltip, action, listener) {
  // UC Browser hasn't adopted the `transitionend` event despite supporting
  // unprefixed transitions...
  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
  tooltip[action + 'EventListener'](eventName, listener);
}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */

function getPopperPlacement(popper) {
  var fullPlacement = popper.getAttribute('x-placement');
  return fullPlacement ? fullPlacement.split('-')[0] : '';
}
/**
 * Sets the visibility state to elements so they can begin to transition
 */

function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
/**
 * Triggers reflow
 */

function reflow(popper) {
  void popper.offsetHeight;
}
/**
 * Adds/removes theme from tooltip's classList
 */

function toggleTheme(tooltip, action, theme) {
  theme.split(' ').forEach(function (themeName) {
    tooltip.classList[action](themeName + '-theme');
  });
}
/**
 * Constructs the popper element and returns it
 */

function createPopperElement(id, props) {
  var popper = div();
  popper.className = 'tippy-popper';
  popper.id = "tippy-".concat(id);
  popper.style.zIndex = '' + props.zIndex;

  if (props.role) {
    popper.setAttribute('role', props.role);
  }

  var tooltip = div();
  tooltip.className = 'tippy-tooltip';
  tooltip.style.maxWidth = props.maxWidth + (typeof props.maxWidth === 'number' ? 'px' : '');
  tooltip.setAttribute('data-size', props.size);
  tooltip.setAttribute('data-animation', props.animation);
  tooltip.setAttribute('data-state', 'hidden');
  toggleTheme(tooltip, 'add', props.theme);
  var content = div();
  content.className = 'tippy-content';
  content.setAttribute('data-state', 'hidden');

  if (props.interactive) {
    addInteractive(popper, tooltip);
  }

  if (props.arrow) {
    tooltip.appendChild(createArrowElement(props.arrowType));
  }

  if (props.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute('data-animatefill', '');
  }

  if (props.inertia) {
    addInertia(tooltip);
  }

  setContent(content, props);
  tooltip.appendChild(content);
  popper.appendChild(tooltip);
  return popper;
}
/**
 * Updates the popper element based on the new props
 */

function updatePopperElement(popper, prevProps, nextProps) {
  var _getChildren = getChildren(popper),
      tooltip = _getChildren.tooltip,
      content = _getChildren.content,
      backdrop = _getChildren.backdrop,
      arrow = _getChildren.arrow;

  popper.style.zIndex = '' + nextProps.zIndex;
  tooltip.setAttribute('data-size', nextProps.size);
  tooltip.setAttribute('data-animation', nextProps.animation);
  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');

  if (nextProps.role) {
    popper.setAttribute('role', nextProps.role);
  } else {
    popper.removeAttribute('role');
  }

  if (prevProps.content !== nextProps.content) {
    setContent(content, nextProps);
  } // animateFill


  if (!prevProps.animateFill && nextProps.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute('data-animatefill', '');
  } else if (prevProps.animateFill && !nextProps.animateFill) {
    tooltip.removeChild(backdrop);
    tooltip.removeAttribute('data-animatefill');
  } // arrow


  if (!prevProps.arrow && nextProps.arrow) {
    tooltip.appendChild(createArrowElement(nextProps.arrowType));
  } else if (prevProps.arrow && !nextProps.arrow) {
    tooltip.removeChild(arrow);
  } // arrowType


  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
  } // interactive


  if (!prevProps.interactive && nextProps.interactive) {
    addInteractive(popper, tooltip);
  } else if (prevProps.interactive && !nextProps.interactive) {
    removeInteractive(popper, tooltip);
  } // inertia


  if (!prevProps.inertia && nextProps.inertia) {
    addInertia(tooltip);
  } else if (prevProps.inertia && !nextProps.inertia) {
    removeInertia(tooltip);
  } // theme


  if (prevProps.theme !== nextProps.theme) {
    toggleTheme(tooltip, 'remove', prevProps.theme);
    toggleTheme(tooltip, 'add', nextProps.theme);
  }
}
/**
 * Runs the callback after the popper's position has been updated
 * update() is debounced with Promise.resolve() or setTimeout()
 * scheduleUpdate() is update() wrapped in requestAnimationFrame()
 */

function afterPopperPositionUpdates(popperInstance, callback) {
  var popper = popperInstance.popper,
      options = popperInstance.options;
  var onCreate = options.onCreate,
      onUpdate = options.onUpdate;

  options.onCreate = options.onUpdate = function (data) {
    reflow(popper);
    callback();

    if (onUpdate) {
      onUpdate(data);
    }

    options.onCreate = onCreate;
    options.onUpdate = onUpdate;
  };
}
/**
 * Hides all visible poppers on the document
 */

function hideAll() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      checkHideOnClick = _ref.checkHideOnClick,
      exclude = _ref.exclude,
      duration = _ref.duration;

  arrayFrom(document.querySelectorAll(Selectors.POPPER)).forEach(function (popper) {
    var instance = popper._tippy;

    if (instance && (checkHideOnClick ? instance.props.hideOnClick === true : true) && (!exclude || popper !== exclude.popper)) {
      instance.hide(duration);
    }
  });
}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */

function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
  if (!popperPlacement) {
    return true;
  }

  var x = event.clientX,
      y = event.clientY;
  var interactiveBorder = props.interactiveBorder,
      distance = props.distance;
  var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
  var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
  var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
  var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */

function getOffsetDistanceInPx(distance) {
  return -(distance - 10) + 'px';
}

var isUsingTouch = false;
function onDocumentTouch() {
  if (isUsingTouch) {
    return;
  }

  isUsingTouch = true;

  if (isIOS) {
    document.body.classList.add('tippy-iOS');
  }

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
var lastMouseMoveTime = 0;
function onDocumentMouseMove() {
  var now = performance.now(); // Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference

  if (now - lastMouseMoveTime < 20) {
    isUsingTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);

    if (!isIOS) {
      document.body.classList.remove('tippy-iOS');
    }
  }

  lastMouseMoveTime = now;
}
function onDocumentClick(event) {
  // Simulated events dispatched on the document
  if (!(event.target instanceof Element)) {
    return hideAll();
  } // Clicked on an interactive popper


  var popper = closest(event.target, Selectors.POPPER);

  if (popper && popper._tippy && popper._tippy.props.interactive) {
    return;
  } // Clicked on a reference


  var reference = closestCallback(event.target, function (el) {
    return el._tippy && el._tippy.reference === el;
  });

  if (reference) {
    var instance = reference._tippy;

    if (instance) {
      var isClickTrigger = includes(instance.props.trigger || '', 'click');

      if (isUsingTouch || isClickTrigger) {
        return hideAll({
          exclude: instance,
          checkHideOnClick: true
        });
      }

      if (instance.props.hideOnClick !== true || isClickTrigger) {
        return;
      }

      instance.clearDelayTimeouts();
    }
  }

  hideAll({
    checkHideOnClick: true
  });
}
function onWindowBlur() {
  var _document = document,
      activeElement = _document.activeElement;

  if (activeElement && activeElement.blur && activeElement._tippy) {
    activeElement.blur();
  }
}
/**
 * Adds the needed global event listeners
 */

function bindGlobalEventListeners() {
  document.addEventListener('click', onDocumentClick, true);
  document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
  window.addEventListener('blur', onWindowBlur);
}

var idCounter = 1;
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */

function createTippy(reference, collectionProps) {
  var props = evaluateProps(reference, collectionProps); // If the reference shouldn't have multiple tippys, return null early

  if (!props.multiple && reference._tippy) {
    return null;
  }
  /* =======================  Private members  ======================= */
  // The last trigger event type that caused the tippy to show


  var lastTriggerEventType; // The last mousemove event object created by the document mousemove event

  var lastMouseMoveEvent; // Timeout created by the show delay

  var showTimeoutId; // Timeout created by the hide delay

  var hideTimeoutId; // Frame created by scheduleHide()

  var animationFrameId; // Flag to determine if the tippy is scheduled to show due to the show timeout

  var isScheduledToShow = false; // The current `transitionend` callback reference

  var transitionEndListener; // Array of event listeners currently attached to the reference element

  var listeners = []; // Private onMouseMove handler reference, debounced or not

  var debouncedOnMouseMove = props.interactiveDebounce > 0 ? debounce$1(onMouseMove, props.interactiveDebounce) : onMouseMove; // Node the tippy is currently appended to

  var parentNode;
  /* =======================  Public members  ======================= */
  // id used for the `aria-describedby` / `aria-labelledby` attribute

  var id = idCounter++; // Popper element reference

  var popper = createPopperElement(id, props); // Popper element children: { arrow, backdrop, content, tooltip }

  var popperChildren = getChildren(popper);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false // Popper.js instance for the tippy is lazily created

  };
  var popperInstance = null;
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: popper,
    popperChildren: popperChildren,
    popperInstance: popperInstance,
    props: props,
    state: state,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    set: set,
    setContent: setContent$$1,
    show: show,
    hide: hide,
    enable: enable,
    disable: disable,
    destroy: destroy
  };
  addTriggersToReference();

  if (!props.lazy) {
    createPopperInstance();
    instance.popperInstance.disableEventListeners();
  }

  if (props.showOnInit) {
    scheduleShow();
  } // Ensure the reference element can receive focus (and is not a delegate)


  if (props.a11y && !props.target && !canReceiveFocus(reference)) {
    reference.setAttribute('tabindex', '0');
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function (event) {
    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
      scheduleShow(event);
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
      document.addEventListener('mousemove', debouncedOnMouseMove);
    }
  }); // Install shortcuts

  reference._tippy = instance;
  popper._tippy = instance;
  return instance;
  /* =======================  Private methods  ======================= */

  /**
   * Positions the virtual reference near the cursor
   */

  function positionVirtualReferenceNearCursor(event) {
    var _lastMouseMoveEvent = lastMouseMoveEvent = event,
        clientX = _lastMouseMoveEvent.clientX,
        clientY = _lastMouseMoveEvent.clientY;

    if (!instance.popperInstance) {
      return;
    } // Ensure virtual reference is padded to prevent tooltip from
    // overflowing. Maybe Popper.js issue?


    var placement = getPopperPlacement(instance.popper);
    var padding = instance.props.arrow ? PADDING + (instance.props.arrowType === 'round' ? 18 : 16) : PADDING;
    var isVerticalPlacement = includes(['top', 'bottom'], placement);
    var isHorizontalPlacement = includes(['left', 'right'], placement); // Top / left boundary

    var x = isVerticalPlacement ? Math.max(padding, clientX) : clientX;
    var y = isHorizontalPlacement ? Math.max(padding, clientY) : clientY; // Bottom / right boundary

    if (isVerticalPlacement && x > padding) {
      x = Math.min(clientX, window.innerWidth - padding);
    }

    if (isHorizontalPlacement && y > padding) {
      y = Math.min(clientY, window.innerHeight - padding);
    }

    var rect = instance.reference.getBoundingClientRect();
    var followCursor = instance.props.followCursor;
    var isHorizontal = followCursor === 'horizontal';
    var isVertical = followCursor === 'vertical';
    instance.popperInstance.reference = _extends$1({}, instance.popperInstance.reference, {
      getBoundingClientRect: function getBoundingClientRect() {
        return {
          width: 0,
          height: 0,
          top: isHorizontal ? rect.top : y,
          bottom: isHorizontal ? rect.bottom : y,
          left: isVertical ? rect.left : x,
          right: isVertical ? rect.right : x
        };
      },
      clientWidth: 0,
      clientHeight: 0
    });
    instance.popperInstance.scheduleUpdate();

    if (followCursor === 'initial' && instance.state.isVisible) {
      removeFollowCursorListener();
    }
  }
  /**
   * Creates the tippy instance for a delegate when it's been triggered
   */


  function createDelegateChildTippy(event) {
    if (event) {
      var targetEl = closest(event.target, instance.props.target);

      if (targetEl && !targetEl._tippy) {
        createTippy(targetEl, _extends$1({}, instance.props, {
          content: evaluateValue(collectionProps.content, [targetEl]),
          appendTo: collectionProps.appendTo,
          target: '',
          showOnInit: true
        }));
        scheduleShow(event);
      }
    }
  }
  /**
   * Setup before show() is invoked (delays, etc.)
   */


  function scheduleShow(event) {
    clearDelayTimeouts();

    if (instance.state.isVisible) {
      return;
    } // Is a delegate, create an instance for the child target


    if (instance.props.target) {
      return createDelegateChildTippy(event);
    }

    isScheduledToShow = true;

    if (instance.props.wait) {
      return instance.props.wait(instance, event);
    } // If the tooltip has a delay, we need to be listening to the mousemove as
    // soon as the trigger event is fired, so that it's in the correct position
    // upon mount.
    // Edge case: if the tooltip is still mounted, but then scheduleShow() is
    // called, it causes a jump.


    if (hasFollowCursorBehavior() && !instance.state.isMounted) {
      document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
    }

    var delay = getValue(instance.props.delay, 0, defaultProps.delay);

    if (delay) {
      showTimeoutId = setTimeout(function () {
        show();
      }, delay);
    } else {
      show();
    }
  }
  /**
   * Setup before hide() is invoked (delays, etc.)
   */


  function scheduleHide() {
    clearDelayTimeouts();

    if (!instance.state.isVisible) {
      return removeFollowCursorListener();
    }

    isScheduledToShow = false;
    var delay = getValue(instance.props.delay, 1, defaultProps.delay);

    if (delay) {
      hideTimeoutId = setTimeout(function () {
        if (instance.state.isVisible) {
          hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      animationFrameId = requestAnimationFrame(function () {
        hide();
      });
    }
  }
  /**
   * Removes the follow cursor listener
   */


  function removeFollowCursorListener() {
    document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
  }
  /**
   * Cleans up old listeners
   */


  function cleanupOldMouseListeners() {
    document.body.removeEventListener('mouseleave', scheduleHide);
    document.removeEventListener('mousemove', debouncedOnMouseMove);
  }
  /**
   * Event listener invoked upon trigger
   */


  function onTrigger(event) {
    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
      return;
    }

    if (!instance.state.isVisible) {
      lastTriggerEventType = event.type;

      if (event instanceof MouseEvent) {
        lastMouseMoveEvent = event;
      }
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
      scheduleHide();
    } else {
      scheduleShow(event);
    }
  }
  /**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */


  function onMouseMove(event) {
    var referenceTheCursorIsOver = closestCallback(event.target, function (el) {
      return el._tippy;
    });
    var isCursorOverPopper = closest(event.target, Selectors.POPPER) === instance.popper;
    var isCursorOverReference = referenceTheCursorIsOver === instance.reference;

    if (isCursorOverPopper || isCursorOverReference) {
      return;
    }

    if (isCursorOutsideInteractiveBorder(getPopperPlacement(instance.popper), instance.popper.getBoundingClientRect(), event, instance.props)) {
      cleanupOldMouseListeners();
      scheduleHide();
    }
  }
  /**
   * Event listener invoked upon mouseleave
   */


  function onMouseLeave(event) {
    if (isEventListenerStopped(event)) {
      return;
    }

    if (instance.props.interactive) {
      document.body.addEventListener('mouseleave', scheduleHide);
      document.addEventListener('mousemove', debouncedOnMouseMove);
      return;
    }

    scheduleHide();
  }
  /**
   * Event listener invoked upon blur
   */


  function onBlur(event) {
    if (event.target !== instance.reference) {
      return;
    }

    if (instance.props.interactive && event.relatedTarget && instance.popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide();
  }
  /**
   * Event listener invoked when a child target is triggered
   */


  function onDelegateShow(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleShow(event);
    }
  }
  /**
   * Event listener invoked when a child target should hide
   */


  function onDelegateHide(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleHide();
    }
  }
  /**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */


  function isEventListenerStopped(event) {
    var supportsTouch = 'ontouchstart' in window;
    var isTouchEvent = includes(event.type, 'touch');
    var touchHold = instance.props.touchHold;
    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
  }
  /**
   * Creates the popper instance for the instance
   */


  function createPopperInstance() {
    var popperOptions = instance.props.popperOptions;
    var _instance$popperChild = instance.popperChildren,
        tooltip = _instance$popperChild.tooltip,
        arrow = _instance$popperChild.arrow;
    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');

    function applyMutations(data) {
      if (instance.props.flip && !instance.props.flipOnUpdate) {
        if (data.flipped) {
          instance.popperInstance.options.placement = data.placement;
        }

        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
      }

      tooltip.setAttribute('x-placement', data.placement);
      var basePlacement = getPopperPlacement(instance.popper);
      var styles = tooltip.style; // Account for the `distance` offset

      styles.top = styles.bottom = styles.left = styles.right = '';
      styles[basePlacement] = getOffsetDistanceInPx(instance.props.distance);
      var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
      var isPaddingNumber = typeof padding === 'number';

      var computedPadding = _extends$1({
        top: isPaddingNumber ? padding : padding.top,
        bottom: isPaddingNumber ? padding : padding.bottom,
        left: isPaddingNumber ? padding : padding.left,
        right: isPaddingNumber ? padding : padding.right
      }, !isPaddingNumber && padding);

      computedPadding[basePlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basePlacement] || 0) + instance.props.distance;
      instance.popperInstance.modifiers.filter(function (m) {
        return m.name === 'preventOverflow';
      })[0].padding = computedPadding;
    }

    var config = _extends$1({
      placement: instance.props.placement
    }, popperOptions, {
      modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {
        preventOverflow: _extends$1({
          boundariesElement: instance.props.boundary,
          padding: PADDING
        }, preventOverflowModifier),
        arrow: _extends$1({
          element: arrow,
          enabled: !!arrow
        }, getModifier(popperOptions, 'arrow')),
        flip: _extends$1({
          enabled: instance.props.flip,
          // The tooltip is offset by 10px from the popper in CSS,
          // we need to account for its distance
          padding: instance.props.distance + PADDING,
          behavior: instance.props.flipBehavior
        }, getModifier(popperOptions, 'flip')),
        offset: _extends$1({
          offset: instance.props.offset
        }, getModifier(popperOptions, 'offset'))
      }),
      // This gets invoked when calling `.set()` and updating a popper
      // instance dependency, since a new popper instance gets created
      onCreate: function onCreate(data) {
        applyMutations(data);

        if (popperOptions && popperOptions.onCreate) {
          popperOptions.onCreate(data);
        }
      },
      // This gets invoked on initial create and show()/scroll/resize update.
      // This is due to `afterPopperPositionUpdates` overwriting onCreate()
      // with onUpdate()
      onUpdate: function onUpdate(data) {
        applyMutations(data);

        if (popperOptions && popperOptions.onUpdate) {
          popperOptions.onUpdate(data);
        }
      }
    });

    instance.popperInstance = new Popper(instance.reference, instance.popper, config);
  }
  /**
   * Mounts the tooltip to the DOM, callback to show tooltip is run **after**
   * popper's position has updated
   */


  function mount(callback) {
    var shouldEnableListeners = !hasFollowCursorBehavior() && !(instance.props.followCursor === 'initial' && isUsingTouch);

    if (!instance.popperInstance) {
      createPopperInstance();

      if (!shouldEnableListeners) {
        instance.popperInstance.disableEventListeners();
      }
    } else {
      if (!hasFollowCursorBehavior()) {
        instance.popperInstance.scheduleUpdate();

        if (shouldEnableListeners) {
          instance.popperInstance.enableEventListeners();
        }
      }

      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
    } // If the instance previously had followCursor behavior, it will be
    // positioned incorrectly if triggered by `focus` afterwards.
    // Update the reference back to the real DOM element


    instance.popperInstance.reference = instance.reference;
    var arrow = instance.popperChildren.arrow;

    if (hasFollowCursorBehavior()) {
      if (arrow) {
        arrow.style.margin = '0';
      }

      if (lastMouseMoveEvent) {
        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
      }
    } else if (arrow) {
      arrow.style.margin = '';
    } // Allow followCursor: 'initial' on touch devices


    if (isUsingTouch && lastMouseMoveEvent && instance.props.followCursor === 'initial') {
      positionVirtualReferenceNearCursor(lastMouseMoveEvent);

      if (arrow) {
        arrow.style.margin = '0';
      }
    }

    afterPopperPositionUpdates(instance.popperInstance, callback);
    var appendTo = instance.props.appendTo;
    parentNode = appendTo === 'parent' ? instance.reference.parentNode : evaluateValue(appendTo, [instance.reference]);

    if (!parentNode.contains(instance.popper)) {
      parentNode.appendChild(instance.popper);
      instance.props.onMount(instance);
      instance.state.isMounted = true;
    }
  }
  /**
   * Determines if the instance is in `followCursor` mode
   */


  function hasFollowCursorBehavior() {
    return instance.props.followCursor && !isUsingTouch && lastTriggerEventType !== 'focus';
  }
  /**
   * Updates the tooltip's position on each animation frame
   */


  function makeSticky() {
    applyTransitionDuration([instance.popper], isIE$1 ? 0 : instance.props.updateDuration);

    function updatePosition() {
      if (instance.popperInstance) {
        instance.popperInstance.scheduleUpdate();
      }

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      } else {
        applyTransitionDuration([instance.popper], 0);
      }
    }

    updatePosition();
  }
  /**
   * Invokes a callback once the tooltip has fully transitioned out
   */


  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && parentNode && parentNode.contains(instance.popper)) {
        callback();
      }
    });
  }
  /**
   * Invokes a callback once the tooltip has fully transitioned in
   */


  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  /**
   * Invokes a callback once the tooltip's CSS transition ends
   */


  function onTransitionEnd(duration, callback) {
    var tooltip = instance.popperChildren.tooltip;
    /**
     * Listener added as the `transitionend` handler
     */

    function listener(event) {
      if (event.target === tooltip) {
        toggleTransitionEndListener(tooltip, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    toggleTransitionEndListener(tooltip, 'remove', transitionEndListener);
    toggleTransitionEndListener(tooltip, 'add', listener);
    transitionEndListener = listener;
  }
  /**
   * Adds an event listener to the reference and stores it in `listeners`
   */


  function on(eventType, handler) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    instance.reference.addEventListener(eventType, handler, options);
    listeners.push({
      eventType: eventType,
      handler: handler,
      options: options
    });
  }
  /**
   * Adds event listeners to the reference based on the `trigger` prop
   */


  function addTriggersToReference() {
    if (instance.props.touchHold && !instance.props.target) {
      on('touchstart', onTrigger, PASSIVE);
      on('touchend', onMouseLeave, PASSIVE);
    }

    instance.props.trigger.trim().split(' ').forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      } // Non-delegates


      if (!instance.props.target) {
        on(eventType, onTrigger);

        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave);
            break;

          case 'focus':
            on(isIE$1 ? 'focusout' : 'blur', onBlur);
            break;
        }
      } else {
        // Delegates
        switch (eventType) {
          case 'mouseenter':
            on('mouseover', onDelegateShow);
            on('mouseout', onDelegateHide);
            break;

          case 'focus':
            on('focusin', onDelegateShow);
            on('focusout', onDelegateHide);
            break;

          case 'click':
            on(eventType, onDelegateShow);
            break;
        }
      }
    });
  }
  /**
   * Removes event listeners from the reference
   */


  function removeTriggersFromReference() {
    listeners.forEach(function (_ref) {
      var eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      instance.reference.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  /**
   * Returns inner elements used in show/hide methods
   */


  function getInnerElements() {
    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
  }
  /* =======================  Public methods  ======================= */

  /**
   * Enables the instance to allow it to show or hide
   */


  function enable() {
    instance.state.isEnabled = true;
  }
  /**
   * Disables the instance to disallow it to show or hide
   */


  function disable() {
    instance.state.isEnabled = false;
  }
  /**
   * Clears pending timeouts related to the `delay` prop if any
   */


  function clearDelayTimeouts() {
    clearTimeout(showTimeoutId);
    clearTimeout(hideTimeoutId);
    cancelAnimationFrame(animationFrameId);
  }
  /**
   * Sets new props for the instance and redraws the tooltip
   */


  function set(options) {
    // Backwards-compatible after TypeScript change
    options = options || {};
    validateOptions(options, defaultProps);
    var prevProps = instance.props;
    var nextProps = evaluateProps(instance.reference, _extends$1({}, instance.props, options, {
      ignoreAttributes: true
    }));
    nextProps.ignoreAttributes = hasOwnProperty(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
    instance.props = nextProps;

    if (hasOwnProperty(options, 'trigger') || hasOwnProperty(options, 'touchHold')) {
      removeTriggersFromReference();
      addTriggersToReference();
    }

    if (hasOwnProperty(options, 'interactiveDebounce')) {
      cleanupOldMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, options.interactiveDebounce || 0);
    }

    updatePopperElement(instance.popper, prevProps, nextProps);
    instance.popperChildren = getChildren(instance.popper);

    if (instance.popperInstance) {
      instance.popperInstance.update();

      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
        return hasOwnProperty(options, prop);
      })) {
        instance.popperInstance.destroy();
        createPopperInstance();

        if (!instance.state.isVisible) {
          instance.popperInstance.disableEventListeners();
        }

        if (instance.props.followCursor && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        }
      }
    }
  }
  /**
   * Shortcut for .set({ content: newContent })
   */


  function setContent$$1(content) {
    set({
      content: content
    });
  }
  /**
   * Shows the tooltip
   */


  function show() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);

    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
      return;
    } // Destroy tooltip if the reference element is no longer on the DOM


    if (!hasOwnProperty(instance.reference, 'isVirtual') && !document.documentElement.contains(instance.reference)) {
      return destroy();
    } // Do not show tooltip if the reference element has a `disabled` attribute


    if (instance.reference.hasAttribute('disabled')) {
      return;
    }

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.popper.style.visibility = 'visible';
    instance.state.isVisible = true;

    if (instance.props.interactive) {
      instance.reference.classList.add('tippy-active');
    } // Prevent a transition if the popper is at the opposite placement


    applyTransitionDuration([instance.popper, instance.popperChildren.tooltip, instance.popperChildren.backdrop], 0);
    mount(function () {
      if (!instance.state.isVisible) {
        return;
      } // Arrow will sometimes not be positioned correctly. Force another update


      if (!hasFollowCursorBehavior()) {
        instance.popperInstance.update();
      }

      applyTransitionDuration([instance.popper], props.updateDuration);
      applyTransitionDuration(getInnerElements(), duration);

      if (instance.popperChildren.backdrop) {
        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
      }

      if (instance.props.sticky) {
        makeSticky();
      }

      setVisibilityState(getInnerElements(), 'visible');
      onTransitionedIn(duration, function () {
        instance.popperChildren.tooltip.classList.add('tippy-notransition');

        if (instance.props.aria) {
          instance.reference.setAttribute("aria-".concat(instance.props.aria), instance.popper.id);
        }

        instance.props.onShown(instance);
        instance.state.isShown = true;
      });
    });
  }
  /**
   * Hides the tooltip
   */


  function hide() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);

    if (instance.state.isDestroyed || !instance.state.isEnabled) {
      return;
    }

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.popperChildren.tooltip.classList.remove('tippy-notransition');

    if (instance.props.interactive) {
      instance.reference.classList.remove('tippy-active');
    }

    instance.popper.style.visibility = 'hidden';
    instance.state.isVisible = false;
    instance.state.isShown = false;
    applyTransitionDuration(getInnerElements(), duration);
    setVisibilityState(getInnerElements(), 'hidden');
    onTransitionedOut(duration, function () {
      if (!isScheduledToShow) {
        removeFollowCursorListener();
      }

      if (instance.props.aria) {
        instance.reference.removeAttribute("aria-".concat(instance.props.aria));
      }

      instance.popperInstance.disableEventListeners();
      instance.popperInstance.options.placement = instance.props.placement;
      parentNode.removeChild(instance.popper);
      instance.props.onHidden(instance);
      instance.state.isMounted = false;
    });
  }
  /**
   * Destroys the tooltip
   */


  function destroy(destroyTargetInstances) {
    if (instance.state.isDestroyed) {
      return;
    } // If the popper is currently mounted to the DOM, we want to ensure it gets
    // hidden and unmounted instantly upon destruction


    if (instance.state.isMounted) {
      hide(0);
    }

    removeTriggersFromReference();
    delete instance.reference._tippy;

    if (instance.props.target && destroyTargetInstances) {
      arrayFrom(instance.reference.querySelectorAll(instance.props.target)).forEach(function (child) {
        if (child._tippy) {
          child._tippy.destroy();
        }
      });
    }

    if (instance.popperInstance) {
      instance.popperInstance.destroy();
    }

    instance.state.isDestroyed = true;
  }
}

/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */

function group(instances) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 0 : _ref$duration;

  // Already grouped. Cannot group instances more than once (yet) or stale lifecycle
  // closures will be invoked, causing a stack overflow
  if (instances.some(function (instance) {
    return hasOwnProperty(instance, '_originalProps');
  })) {
    return;
  }

  var isAnyTippyOpen = false;
  instances.forEach(function (instance) {
    instance._originalProps = _extends$1({}, instance.props);
  });

  function setIsAnyTippyOpen(value) {
    isAnyTippyOpen = value;
    updateInstances();
  }

  function onShow(instance) {
    instance._originalProps.onShow(instance);

    instances.forEach(function (instance) {
      instance.set({
        duration: duration
      });
      instance.hide();
    });
    setIsAnyTippyOpen(true);
  }

  function onHide(instance) {
    instance._originalProps.onHide(instance);

    setIsAnyTippyOpen(false);
  }

  function onShown(instance) {
    instance._originalProps.onShown(instance);

    instance.set({
      duration: instance._originalProps.duration
    });
  }

  function updateInstances() {
    instances.forEach(function (instance) {
      instance.set({
        onShow: onShow,
        onShown: onShown,
        onHide: onHide,
        delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay,
        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
      });
    });
  }

  updateInstances();
}

var globalEventListenersBound = false;
/**
 * Exported module
 */

function tippy(targets, options) {
  validateOptions(options || {}, defaultProps);

  if (!globalEventListenersBound) {
    bindGlobalEventListeners();
    globalEventListenersBound = true;
  }

  var props = _extends$1({}, defaultProps, options); // If they are specifying a virtual positioning reference, we need to polyfill
  // some native DOM props


  if (isBareVirtualElement(targets)) {
    polyfillElementPrototypeProperties(targets);
  }

  var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, props);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isSingular(targets) ? instances[0] : instances;
}
/**
 * Static props
 */


tippy.version = version;
tippy.defaults = defaultProps;
/**
 * Static methods
 */

tippy.setDefaults = function (partialDefaults) {
  Object.keys(partialDefaults).forEach(function (key) {
    // @ts-ignore
    defaultProps[key] = partialDefaults[key];
  });
};

tippy.hideAll = hideAll;
tippy.group = group;
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */

function autoInit() {
  arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
    var content = el.getAttribute('data-tippy');

    if (content) {
      tippy(el, {
        content: content
      });
    }
  });
}

if (isBrowser$1) {
  setTimeout(autoInit);
}

/**
 * Injects a string of CSS styles to a style node in <head>
 */

function injectCSS(css) {
  if (isBrowser$1) {
    var style = document.createElement('style');
    style.type = 'text/css';
    style.textContent = css;
    var head = document.head;
    var firstChild = head.firstChild;

    if (firstChild) {
      head.insertBefore(style, firstChild);
    } else {
      head.appendChild(style);
    }
  }
}

injectCSS(css);

class YooTooltipComponent {
    constructor() {
        this.tippy = null;
    }
    onOptionsChange() {
        if (!this.cssOnly) {
            this.loadTippy();
        }
    }
    onTextChange() {
        if (!this.cssOnly) {
            this.loadTippy();
        }
    }
    componentWillLoad() {
        if (!this.cssOnly) {
            this.loadTippy();
        }
    }
    loadTippy() {
        if (this.tippy) {
            this.tippy.destroy(this.tippy);
        }
        let tippyOptions = Object.assign({ theme: 'light', placement: this.placement, arrow: true, arrowType: 'round', zIndex: 25000 }, this.options, { content: this.content });
        // Moved tooltip to always be on the host element
        this.tippy = tippy(this.host, tippyOptions);
    }
    renderCssOnly() {
        return h("div", { class: `css-only hint--${this.placement} hint--rounded`, "aria-label": this.content },
            h("slot", null));
    }
    hostData() {
        return {
            class: {
                'css-only': this.cssOnly
            }
        };
    }
    render() {
        return this.cssOnly ? this.renderCssOnly() : h("slot", null);
    }
    static get is() { return "yoo-tooltip"; }
    static get encapsulation() { return "scoped"; }
    static get properties() { return {
        "content": {
            "type": String,
            "attr": "content",
            "watchCallbacks": ["onTextChange"]
        },
        "cssOnly": {
            "type": Boolean,
            "attr": "css-only"
        },
        "host": {
            "elementRef": true
        },
        "options": {
            "type": "Any",
            "attr": "options",
            "watchCallbacks": ["onOptionsChange"]
        },
        "placement": {
            "type": String,
            "attr": "placement"
        }
    }; }
    static get style() { return "[class*=\"hint--\"].sc-yoo-tooltip {\n  position: relative;\n  display: inline-block;\n  \n   }\n  [class*=\"hint--\"].sc-yoo-tooltip:before, [class*=\"hint--\"].sc-yoo-tooltip:after {\n    position: absolute;\n    -webkit-transform: translate3d(0, 0, 0);\n    -moz-transform: translate3d(0, 0, 0);\n    transform: translate3d(0, 0, 0);\n    visibility: hidden;\n    opacity: 0;\n    z-index: 1000000;\n    pointer-events: none;\n    -webkit-transition: 0.3s ease;\n    -moz-transition: 0.3s ease;\n    transition: 0.3s ease;\n    -webkit-transition-delay: 0ms;\n    -moz-transition-delay: 0ms;\n    transition-delay: 0ms; }\n  [class*=\"hint--\"].sc-yoo-tooltip:hover:before, [class*=\"hint--\"].sc-yoo-tooltip:hover:after {\n    visibility: visible;\n    opacity: 1; }\n  [class*=\"hint--\"].sc-yoo-tooltip:hover:before, [class*=\"hint--\"].sc-yoo-tooltip:hover:after {\n    -webkit-transition-delay: 100ms;\n    -moz-transition-delay: 100ms;\n    transition-delay: 100ms; }\n  [class*=\"hint--\"].sc-yoo-tooltip:before {\n    content: '';\n    position: absolute;\n    background: transparent;\n    border: 6px solid transparent;\n    z-index: 1000001; }\n  [class*=\"hint--\"].sc-yoo-tooltip:after {\n    background: #383838;\n    color: white;\n    padding: 8px 10px;\n    font-size: 12px;\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    line-height: 12px;\n    white-space: nowrap; }\n  [class*=\"hint--\"][aria-label].sc-yoo-tooltip:after {\n    content: attr(aria-label); }\n  [class*=\"hint--\"][data-hint].sc-yoo-tooltip:after {\n    content: attr(data-hint); }\n\n[aria-label=''].sc-yoo-tooltip:before, [aria-label=''].sc-yoo-tooltip:after, [data-hint=''].sc-yoo-tooltip:before, [data-hint=''].sc-yoo-tooltip:after {\n  display: none !important; }\n\n\n\n.hint--top-left.sc-yoo-tooltip:before {\n  border-top-color: #383838; }\n\n.hint--top-right.sc-yoo-tooltip:before {\n  border-top-color: #383838; }\n\n.hint--top.sc-yoo-tooltip:before {\n  border-top-color: #383838; }\n\n.hint--bottom-left.sc-yoo-tooltip:before {\n  border-bottom-color: #383838; }\n\n.hint--bottom-right.sc-yoo-tooltip:before {\n  border-bottom-color: #383838; }\n\n.hint--bottom.sc-yoo-tooltip:before {\n  border-bottom-color: #383838; }\n\n.hint--left.sc-yoo-tooltip:before {\n  border-left-color: #383838; }\n\n.hint--right.sc-yoo-tooltip:before {\n  border-right-color: #383838; }\n\n\n.hint--top.sc-yoo-tooltip:before {\n  margin-bottom: -11px; }\n\n.hint--top.sc-yoo-tooltip:before, .hint--top.sc-yoo-tooltip:after {\n  bottom: 100%;\n  left: 50%; }\n\n.hint--top.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--top.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-50%);\n  -moz-transform: translateX(-50%);\n  transform: translateX(-50%); }\n\n.hint--top.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--top.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(-50%) translateY(-8px);\n  -moz-transform: translateX(-50%) translateY(-8px);\n  transform: translateX(-50%) translateY(-8px); }\n\n\n.hint--bottom.sc-yoo-tooltip:before {\n  margin-top: -11px; }\n\n.hint--bottom.sc-yoo-tooltip:before, .hint--bottom.sc-yoo-tooltip:after {\n  top: 100%;\n  left: 50%; }\n\n.hint--bottom.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--bottom.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-50%);\n  -moz-transform: translateX(-50%);\n  transform: translateX(-50%); }\n\n.hint--bottom.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--bottom.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(-50%) translateY(8px);\n  -moz-transform: translateX(-50%) translateY(8px);\n  transform: translateX(-50%) translateY(8px); }\n\n\n.hint--right.sc-yoo-tooltip:before {\n  margin-left: -11px;\n  margin-bottom: -6px; }\n\n.hint--right.sc-yoo-tooltip:after {\n  margin-bottom: -14px; }\n\n.hint--right.sc-yoo-tooltip:before, .hint--right.sc-yoo-tooltip:after {\n  left: 100%;\n  bottom: 50%; }\n\n.hint--right.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateX(8px);\n  -moz-transform: translateX(8px);\n  transform: translateX(8px); }\n\n.hint--right.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(8px);\n  -moz-transform: translateX(8px);\n  transform: translateX(8px); }\n\n\n.hint--left.sc-yoo-tooltip:before {\n  margin-right: -11px;\n  margin-bottom: -6px; }\n\n.hint--left.sc-yoo-tooltip:after {\n  margin-bottom: -14px; }\n\n.hint--left.sc-yoo-tooltip:before, .hint--left.sc-yoo-tooltip:after {\n  right: 100%;\n  bottom: 50%; }\n\n.hint--left.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateX(-8px);\n  -moz-transform: translateX(-8px);\n  transform: translateX(-8px); }\n\n.hint--left.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(-8px);\n  -moz-transform: translateX(-8px);\n  transform: translateX(-8px); }\n\n\n.hint--top-left.sc-yoo-tooltip:before {\n  margin-bottom: -11px; }\n\n.hint--top-left.sc-yoo-tooltip:before, .hint--top-left.sc-yoo-tooltip:after {\n  bottom: 100%;\n  left: 50%; }\n\n.hint--top-left.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--top-left.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-100%);\n  -moz-transform: translateX(-100%);\n  transform: translateX(-100%); }\n\n.hint--top-left.sc-yoo-tooltip:after {\n  margin-left: 12px; }\n\n.hint--top-left.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--top-left.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(-100%) translateY(-8px);\n  -moz-transform: translateX(-100%) translateY(-8px);\n  transform: translateX(-100%) translateY(-8px); }\n\n\n.hint--top-right.sc-yoo-tooltip:before {\n  margin-bottom: -11px; }\n\n.hint--top-right.sc-yoo-tooltip:before, .hint--top-right.sc-yoo-tooltip:after {\n  bottom: 100%;\n  left: 50%; }\n\n.hint--top-right.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--top-right.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(0);\n  -moz-transform: translateX(0);\n  transform: translateX(0); }\n\n.hint--top-right.sc-yoo-tooltip:after {\n  margin-left: -12px; }\n\n.hint--top-right.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--top-right.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n\n.hint--bottom-left.sc-yoo-tooltip:before {\n  margin-top: -11px; }\n\n.hint--bottom-left.sc-yoo-tooltip:before, .hint--bottom-left.sc-yoo-tooltip:after {\n  top: 100%;\n  left: 50%; }\n\n.hint--bottom-left.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--bottom-left.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-100%);\n  -moz-transform: translateX(-100%);\n  transform: translateX(-100%); }\n\n.hint--bottom-left.sc-yoo-tooltip:after {\n  margin-left: 12px; }\n\n.hint--bottom-left.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--bottom-left.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateX(-100%) translateY(8px);\n  -moz-transform: translateX(-100%) translateY(8px);\n  transform: translateX(-100%) translateY(8px); }\n\n\n.hint--bottom-right.sc-yoo-tooltip:before {\n  margin-top: -11px; }\n\n.hint--bottom-right.sc-yoo-tooltip:before, .hint--bottom-right.sc-yoo-tooltip:after {\n  top: 100%;\n  left: 50%; }\n\n.hint--bottom-right.sc-yoo-tooltip:before {\n  left: calc(50% - 6px); }\n\n.hint--bottom-right.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(0);\n  -moz-transform: translateX(0);\n  transform: translateX(0); }\n\n.hint--bottom-right.sc-yoo-tooltip:after {\n  margin-left: -12px; }\n\n.hint--bottom-right.sc-yoo-tooltip:hover:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--bottom-right.sc-yoo-tooltip:hover:after {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n\n.hint--small.sc-yoo-tooltip:after, .hint--medium.sc-yoo-tooltip:after, .hint--large.sc-yoo-tooltip:after {\n  white-space: normal;\n  line-height: 1.4em;\n  word-wrap: break-word; }\n\n.hint--small.sc-yoo-tooltip:after {\n  width: 80px; }\n\n.hint--medium.sc-yoo-tooltip:after {\n  width: 150px; }\n\n.hint--large.sc-yoo-tooltip:after {\n  width: 300px; }\n\n\n[class*=\"hint--\"].sc-yoo-tooltip {\n   }\n  [class*=\"hint--\"].sc-yoo-tooltip:after {\n    text-shadow: 0 -1px 0px black;\n    -webkit-box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3);\n    box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3); }\n\n\n\n.hint--error.sc-yoo-tooltip:after {\n  background-color: #b34e4d;\n  text-shadow: 0 -1px 0px #592726; }\n\n.hint--error.hint--top-left.sc-yoo-tooltip:before {\n  border-top-color: #b34e4d; }\n\n.hint--error.hint--top-right.sc-yoo-tooltip:before {\n  border-top-color: #b34e4d; }\n\n.hint--error.hint--top.sc-yoo-tooltip:before {\n  border-top-color: #b34e4d; }\n\n.hint--error.hint--bottom-left.sc-yoo-tooltip:before {\n  border-bottom-color: #b34e4d; }\n\n.hint--error.hint--bottom-right.sc-yoo-tooltip:before {\n  border-bottom-color: #b34e4d; }\n\n.hint--error.hint--bottom.sc-yoo-tooltip:before {\n  border-bottom-color: #b34e4d; }\n\n.hint--error.hint--left.sc-yoo-tooltip:before {\n  border-left-color: #b34e4d; }\n\n.hint--error.hint--right.sc-yoo-tooltip:before {\n  border-right-color: #b34e4d; }\n\n\n.hint--warning.sc-yoo-tooltip:after {\n  background-color: #c09854;\n  text-shadow: 0 -1px 0px #6c5328; }\n\n.hint--warning.hint--top-left.sc-yoo-tooltip:before {\n  border-top-color: #c09854; }\n\n.hint--warning.hint--top-right.sc-yoo-tooltip:before {\n  border-top-color: #c09854; }\n\n.hint--warning.hint--top.sc-yoo-tooltip:before {\n  border-top-color: #c09854; }\n\n.hint--warning.hint--bottom-left.sc-yoo-tooltip:before {\n  border-bottom-color: #c09854; }\n\n.hint--warning.hint--bottom-right.sc-yoo-tooltip:before {\n  border-bottom-color: #c09854; }\n\n.hint--warning.hint--bottom.sc-yoo-tooltip:before {\n  border-bottom-color: #c09854; }\n\n.hint--warning.hint--left.sc-yoo-tooltip:before {\n  border-left-color: #c09854; }\n\n.hint--warning.hint--right.sc-yoo-tooltip:before {\n  border-right-color: #c09854; }\n\n\n.hint--info.sc-yoo-tooltip:after {\n  background-color: #3986ac;\n  text-shadow: 0 -1px 0px #1a3c4d; }\n\n.hint--info.hint--top-left.sc-yoo-tooltip:before {\n  border-top-color: #3986ac; }\n\n.hint--info.hint--top-right.sc-yoo-tooltip:before {\n  border-top-color: #3986ac; }\n\n.hint--info.hint--top.sc-yoo-tooltip:before {\n  border-top-color: #3986ac; }\n\n.hint--info.hint--bottom-left.sc-yoo-tooltip:before {\n  border-bottom-color: #3986ac; }\n\n.hint--info.hint--bottom-right.sc-yoo-tooltip:before {\n  border-bottom-color: #3986ac; }\n\n.hint--info.hint--bottom.sc-yoo-tooltip:before {\n  border-bottom-color: #3986ac; }\n\n.hint--info.hint--left.sc-yoo-tooltip:before {\n  border-left-color: #3986ac; }\n\n.hint--info.hint--right.sc-yoo-tooltip:before {\n  border-right-color: #3986ac; }\n\n\n.hint--success.sc-yoo-tooltip:after {\n  background-color: #458746;\n  text-shadow: 0 -1px 0px #1a321a; }\n\n.hint--success.hint--top-left.sc-yoo-tooltip:before {\n  border-top-color: #458746; }\n\n.hint--success.hint--top-right.sc-yoo-tooltip:before {\n  border-top-color: #458746; }\n\n.hint--success.hint--top.sc-yoo-tooltip:before {\n  border-top-color: #458746; }\n\n.hint--success.hint--bottom-left.sc-yoo-tooltip:before {\n  border-bottom-color: #458746; }\n\n.hint--success.hint--bottom-right.sc-yoo-tooltip:before {\n  border-bottom-color: #458746; }\n\n.hint--success.hint--bottom.sc-yoo-tooltip:before {\n  border-bottom-color: #458746; }\n\n.hint--success.hint--left.sc-yoo-tooltip:before {\n  border-left-color: #458746; }\n\n.hint--success.hint--right.sc-yoo-tooltip:before {\n  border-right-color: #458746; }\n\n\n.hint--always.sc-yoo-tooltip:after, .hint--always.sc-yoo-tooltip:before {\n  opacity: 1;\n  visibility: visible; }\n\n.hint--always.hint--top.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--always.hint--top.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-50%) translateY(-8px);\n  -moz-transform: translateX(-50%) translateY(-8px);\n  transform: translateX(-50%) translateY(-8px); }\n\n.hint--always.hint--top-left.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--always.hint--top-left.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-100%) translateY(-8px);\n  -moz-transform: translateX(-100%) translateY(-8px);\n  transform: translateX(-100%) translateY(-8px); }\n\n.hint--always.hint--top-right.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--always.hint--top-right.sc-yoo-tooltip:after {\n  -webkit-transform: translateY(-8px);\n  -moz-transform: translateY(-8px);\n  transform: translateY(-8px); }\n\n.hint--always.hint--bottom.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--always.hint--bottom.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-50%) translateY(8px);\n  -moz-transform: translateX(-50%) translateY(8px);\n  transform: translateX(-50%) translateY(8px); }\n\n.hint--always.hint--bottom-left.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--always.hint--bottom-left.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-100%) translateY(8px);\n  -moz-transform: translateX(-100%) translateY(8px);\n  transform: translateX(-100%) translateY(8px); }\n\n.hint--always.hint--bottom-right.sc-yoo-tooltip:before {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--always.hint--bottom-right.sc-yoo-tooltip:after {\n  -webkit-transform: translateY(8px);\n  -moz-transform: translateY(8px);\n  transform: translateY(8px); }\n\n.hint--always.hint--left.sc-yoo-tooltip:before {\n  -webkit-transform: translateX(-8px);\n  -moz-transform: translateX(-8px);\n  transform: translateX(-8px); }\n\n.hint--always.hint--left.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(-8px);\n  -moz-transform: translateX(-8px);\n  transform: translateX(-8px); }\n\n.hint--always.hint--right.sc-yoo-tooltip:before {\n  -webkit-transform: translateX(8px);\n  -moz-transform: translateX(8px);\n  transform: translateX(8px); }\n\n.hint--always.hint--right.sc-yoo-tooltip:after {\n  -webkit-transform: translateX(8px);\n  -moz-transform: translateX(8px);\n  transform: translateX(8px); }\n\n\n.hint--rounded.sc-yoo-tooltip:after {\n  border-radius: 4px; }\n\n\n.hint--no-animate.sc-yoo-tooltip:before, .hint--no-animate.sc-yoo-tooltip:after {\n  -webkit-transition-duration: 0ms;\n  -moz-transition-duration: 0ms;\n  transition-duration: 0ms; }\n\n.hint--bounce.sc-yoo-tooltip:before, .hint--bounce.sc-yoo-tooltip:after {\n  -webkit-transition: opacity 0.3s ease, visibility 0.3s ease, -webkit-transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24);\n  -moz-transition: opacity 0.3s ease, visibility 0.3s ease, -moz-transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24);\n  transition: opacity 0.3s ease, visibility 0.3s ease, -webkit-transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24);\n  transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24);\n  transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24), -webkit-transform 0.3s cubic-bezier(0.71, 1.7, 0.77, 1.24); }\n\n.sc-yoo-tooltip-h {\n  display: block;\n  outline: none;\n  cursor: pointer; }\n  .sc-yoo-tooltip-h   [class*=\"hint--\"].sc-yoo-tooltip:after {\n    font-family: \"Lato\";\n    font-size: 0.875rem; }"; }
}

export { YooAccordionComponent as YooAccordion, YooCalendarComponent as YooCalendar, YooChatMessageComponent as YooChatMessage, YooColorSelectorComponent as YooColorSelector, YooDeviceComponent as YooDevice, YooEntitySearchDialogComponent as YooEntitySearchDialog, YooEntitySearchFiltersComponent as YooEntitySearchFilters, YooEntitySearchSortsComponent as YooEntitySearchSorts, YooEntitySearchTagsComponent as YooEntitySearchTags, YooFormBarcodeDialogComponent as YooFormBarcodeDialog, YooFormCreatorComponent as YooFormCreator, YooFormCreatorBlockExpandableComponent as YooFormCreatorBlockExpandable, YooFormCreatorBlockSimpleComponent as YooFormCreatorBlockSimple, YooFormCreatorHeaderComponent as YooFormCreatorHeader, YooFormCreatorPageCardComponent as YooFormCreatorPageCard, YooFormDateTimeComponent as YooFormDateTime, YooFormFooterComponent as YooFormFooter, YooFormTimeComponent as YooFormTime, YooFromCreatorPageCardListComponent as YooFromCreatorPageCardList, YooIonInfiniteScrollComponent as YooIonInfiniteScroll, YooIonItemComponent as YooIonItem, YooIonItemOptionsComponent as YooIonItemOptions, YooIonItemSlidingComponent as YooIonItemSliding, YooIonListComponent as YooIonList, YooIonRefresherComponent as YooIonRefresher, YooIonRefresherContentComponent as YooIonRefresherContent, YooNavbarComponent as YooNavbar, YooScanditComponent as YooScandit, YooTooltipComponent as YooTooltip };
